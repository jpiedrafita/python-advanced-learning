# 1.3 Demo: Getting Started with AsyncIO

This demo explores **how AsyncIO code executes** and demonstrates **where performance improvements come from** through practical examples.

## Demo Evolution: From Basic to Optimized

### Initial Basic Code

Starting with the basic example from lesson 1.2:

```python
import asyncio

async def call_api():
    print("calling")

async def main():
    await call_api()
    
    task = asyncio.create_task(call_api())
    await task

asyncio.run(main())
```

```bash
❯ python why_async.py
calling
calling
```

### Adding Performance Measurement

To understand execution timing, we add performance counters:

```python
import asyncio
import time

async def call_api():
    print("calling")

async def main():
    start_time = time.perf_counter()
    
    await call_api()
    
    task = asyncio.create_task(call_api())
    await task
    
    end_time = time.perf_counter()
    print(f"Duration: {round(end_time - start_time, 2)} seconds")

asyncio.run(main())
```

Output:
```bash
❯ python why_async.py
calling
calling
Duration: 0.0 seconds
```

**Execution Time**: `0.0 seconds` (negligible - too fast to measure)

### Simulating Real I/O Operations

To demonstrate AsyncIO benefits, we simulate API calls with delays:

```python
import asyncio
import time

async def call_api():
    print("Calling API...")
    await asyncio.sleep(1)  # Simulates 1-second API call
    print("API response received.")

async def main():
    start_time = time.perf_counter()
    
    await call_api()  # Direct execution
    
    task = asyncio.create_task(call_api())
    await task  # Task execution
    
    end_time = time.perf_counter()
    print(f"Duration: {round(end_time - start_time, 3)} seconds")

asyncio.run(main())
```

## Performance Analysis: Sequential vs Concurrent

### Sequential Execution (Initial Version)

**Expected Duration**: 2 seconds (1 + 1)  
**Actual Duration**: **2 seconds** ❌

```bash
❯ python why_async.py
Calling API...
API response received.
Calling API...
API response received.
Duration: 2.004 seconds
```

### Why No Performance Gain?

| **Execution Step** | **What Happens** | **Duration** |
|-------------------|------------------|--------------|
| `await call_api()` | Starts AND waits for completion | 1 second |
| `task = asyncio.create_task(call_api())` | Starts execution | 0 seconds |
| `await task` | Waits for completion | 1 second |
| **Total** | Sequential execution | **2 seconds** |

### Optimized Concurrent Execution

**Key Insight**: Tasks offer flexibility to **start execution** and **wait for completion** at different points.

```python
import asyncio
import time

async def call_api():
    print("Calling API...")
    await asyncio.sleep(1)
    print("API response received.")

async def main():
    start_time = time.perf_counter()
    
    task = asyncio.create_task(call_api())  # start
    await call_api()  # start + finish
    await task  # finish
    
    end_time = time.perf_counter()
    print(f"Duration: {round(end_time - start_time, 3)} seconds")

asyncio.run(main())
```

**Result**: **1 second**  (50% improvement!)

```bash
❯ python why_async.py
Calling API...
Calling API...
API response received.
API response received.
Duration: 1.001 seconds
```

### Execution Flow Analysis

| **Timeline** | **Task Execution** | **Direct Call** |
|--------------|-------------------|-----------------|
| **0.0s** | `task` starts | `await call_api()` starts |
| **1.0s** | `task` completes | Direct call completes |
| **1.0s** | `await task` returns | Move to next line |

**Result**: Both operations run **concurrently**, completing in parallel.

## Critical Mistake: Using Blocking Operations

### Wrong Approach: `time.sleep()`

```python
async def call_api():
    print("Calling API...")
    time.sleep(1)  # ❌ BLOCKING operation
    print("API response received.")
```

**Result**: **2 seconds** (no concurrency)

```bash
❯ python why_async.py
Calling API...
API response received.
Calling API...
API response received.
Duration: 2.003 seconds
```

### Why Blocking Operations Fail

| **Operation Type** | **Effect on Thread** | **Concurrency** | **Performance** |
|-------------------|---------------------|-----------------|-----------------|
| `await asyncio.sleep(1)` | **Non-blocking** | ✅ Allows other tasks | ✅ Performance gain |
| `time.sleep(1)` | **Blocking** | ❌ Blocks main thread | ❌ No performance gain |

> **Critical Rule**: Use **async operations throughout the full call stack** for performance benefits.

## Key Takeaways

### 1. Direct Await vs Tasks

| **Approach** | **Execution** | **Concurrency** | **Use Case** |
|--------------|---------------|-----------------|--------------|
| **Direct Await** | `await coroutine()` | ❌ Sequential | Simple, immediate execution |
| **Tasks** | `task = create_task()` + `await task` | ✅ Concurrent | Performance-critical operations |

### 2. Task Flexibility

**Tasks provide the opportunity to**:
- **Start execution immediately** with `asyncio.create_task()`
- **Add code between start and completion**
- **Wait for completion later** with `await task`
- **Enable concurrent execution** of multiple operations

### 3. Blocking vs Non-Blocking Operations

**For concurrency benefits**:
- ✅ Use `await asyncio.sleep()` instead of `time.sleep()`
- ✅ Use `await` with async libraries (`aiohttp`, `asyncpg`, etc.)
- ❌ Avoid blocking operations that lock the main thread

## Performance Summary

| **Code Version** | **Execution Pattern** | **Duration** | **Improvement** |
|------------------|----------------------|--------------|-----------------|
| **Basic Example** | No I/O simulation | 0.0s | N/A |
| **Sequential Async** | `await` → `create_task` → `await task` | 2.0s | Baseline |
| **Concurrent Async** | `create_task` → `await` → `await task` | 1.0s | **50% faster** |
| **Blocking Operations** | Using `time.sleep()` | 2.0s | No benefit |
