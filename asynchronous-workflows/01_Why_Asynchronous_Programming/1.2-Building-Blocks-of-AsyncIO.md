# 1.2 Building Blocks of AsyncIO

AsyncIO has **three key building blocks** that work together closely to enable asynchronous programming in Python:

1. **Event Loop** - Central coordinator for managing and coordinating execution
2. **Coroutines** - Special Python functions that can pause and resume execution
3. **Tasks** - Wrappers for coroutines that enable concurrent execution

## Event Loop

The **event loop** is the mechanism that makes asynchronous programming possible.

### Key Responsibilities

| **Function** | **Description** |
|--------------|-----------------|
| **Central Coordinator** | Acts as the central coordinator of an asynchronous program |
| **Execution Flow Control** | Manages program execution flow to ensure each task gets its chance to run |
| **Task Management** | Schedules tasks and determines which are ready to be executed, paused, or resumed |
| **I/O Event Handling** | Handles input/output events and resumes waiting tasks (e.g., API responses) as soon as possible |
| **Non-blocking Execution** | Ensures long-running I/O operations don't block the entire program |

### Performance Impact

> **Result**: The event loop enables **significant performance increases** by preventing I/O operations from blocking the entire application.

## Coroutines

**Coroutines** are special functions with different syntax and execution behavior from regular Python functions.

### Syntax Differences

| **Aspect** | **Regular Function** | **Coroutine** |
|------------|---------------------|---------------|
| **Definition** | `def function_name():` | `async def function_name():` |
| **Execution** | Direct call: `function_name()` | Must be awaited: `await function_name()` |
| **Keyword** | Standard `def` | `async def` indicates it's a coroutine |

### Execution Requirements

- **Cannot be called directly** like regular functions
- **Must be awaited** using the `await` keyword
- **Alternative execution**: Wrap in a task for flexibility and performance benefits

## Tasks

**Tasks** are wrappers for coroutines that provide enhanced capabilities for concurrent execution.

### Key Features

| **Feature** | **Description** | **Benefit** |
|-------------|-----------------|-------------|
| **Concurrent Execution** | Enable coroutines to run concurrently with event loop scheduling | Performance improvement |
| **State Management** | Can have states: `pending`, `running`, or `done` | Better control and monitoring |
| **Cancellation** | Can be canceled directly (unlike coroutines) | More flexible execution control |
| **Exception Handling** | Better exception propagation capabilities | Robust error handling |

### Advantages Over Direct Coroutines

- **Enhanced state tracking**
- **Direct cancellation support**
- **Improved exception propagation**
- **Better concurrent execution management**

## Basic Implementation Example

Here's a practical example illustrating the three building blocks working together:

```python
import asyncio

async def call_api():
    print("calling")

async def main():
    # Direct coroutine execution
    await call_api()
    
    # Task-wrapped coroutine execution
    task = asyncio.create_task(call_api())
    await task

# Event loop creation and execution
asyncio.run(main())
```

### Code Breakdown

| **Line** | **Building Block** | **Purpose** |
|----------|-------------------|-------------|
| `async def call_api():` | **Coroutine** | Defines a coroutine that simulates an API call |
| `async def main():` | **Coroutine** | Main coroutine serving as program starting point |
| `await call_api()` | **Coroutine Execution** | Direct coroutine execution - runs to completion before next line |
| `asyncio.create_task(call_api())` | **Task** | Wraps coroutine in task for concurrent execution scheduling |
| `await task` | **Task Execution** | Waits for task completion before proceeding |
| `asyncio.run(main())` | **Event Loop** | Creates new event loop and runs main coroutine |

### Execution Flow

1. **Event loop** created by `asyncio.run()`
2. **Main coroutine** starts execution
3. **First call**: `call_api()` runs directly via `await`
4. **Second call**: `call_api()` wrapped in task and scheduled
5. **Task execution** managed by event loop

## Key Questions This Example Raises

The basic example illustrates the building blocks but raises important questions:

### Performance Questions
- **Where are the performance benefits?** (Not visible in this simple example)
- **Can I just add `async` to functions for automatic speedup?** (No - requires I/O-bound operations)

### Execution Questions
- **How is execution order different from regular code?** (Event loop scheduling vs sequential execution)
- **When do we see real concurrency benefits?** (With actual I/O operations and multiple concurrent tasks)

## Summary

The **three building blocks** provide a solid foundation for asynchronous Python programming:

- **Event Loop**: Central coordinator ensuring non-blocking execution
- **Coroutines**: Special functions that can pause and resume
- **Tasks**: Enhanced wrappers enabling concurrent execution with better control

> **Foundation**: These building blocks work together to enable **high-performance asynchronous applications** that overcome traditional I/O bottlenecks.
