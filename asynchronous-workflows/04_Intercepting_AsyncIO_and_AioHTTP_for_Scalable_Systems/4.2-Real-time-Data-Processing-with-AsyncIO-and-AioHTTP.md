# 4.2 Real-time Data Processing with AsyncIO and AioHTTP

## Overview

Traditional HTTP follows a request-response pattern where the client makes a request, the server responds, and the connection closes. While this works well for many applications, it has limitations for scenarios requiring real-time updates. This lesson explores two powerful approaches for implementing real-time communication in AioHTTP applications.

## Understanding Server-sent Events

### Core Characteristics

Server-sent Events (SSE) provide a lightweight protocol that enables servers to push updates to clients over a single HTTP connection.

| Feature | Description | Benefit |
|---------|-------------|---------|
| **Persistent Connection** | Maintains open connection between client and server | Eliminates repeated connection overhead |
| **One-way Communication** | Data flows only from server to client | Simple, efficient for streaming updates |
| **Standard HTTP Protocol** | Works over regular HTTP connections | No special protocols or port configurations |
| **Native Browser Support** | Built-in support in most modern browsers | Easy client-side implementation |

### Technical Implementation

```python
async def sse_handler(request):
    """Server-sent Events handler for real-time data streaming"""
    # Step 1: Initialize streaming HTTP response
    response = web.StreamResponse()
    
    # Step 2: Set required headers for SSE
    response.headers['Content-Type'] = 'text/event-stream'
    response.headers['Cache-Control'] = 'no-cache'  # Ensure fresh data
    response.headers['Connection'] = 'keep-alive'   # Maintain connection
    
    # Step 3: Send headers to client
    await response.prepare(request)
    
    # Step 4: Stream data continuously
    while True:
        # Generate data (simulating temperature sensor)
        data = "Temperature: 70°F\n"
        
        # Step 5: Encode and write to stream
        await response.write(data.encode('utf-8'))
        
        # Step 6: Non-blocking sleep to simulate real-time intervals
        await asyncio.sleep(1)  # Server remains free to handle other requests
```

**Code Explanation**:

1. **StreamResponse vs JSON Response**: Unlike regular `web.json_response()`, we use `web.StreamResponse()` for continuous data streaming
2. **Critical Headers**: 
   - `text/event-stream`: Tells browser this is an SSE stream
   - `no-cache`: Prevents caching of stream data
   - `keep-alive`: Maintains persistent connection
3. **Non-blocking Sleep**: `await asyncio.sleep(1)` allows the server to handle other clients while streaming

## Use Cases for Server-sent Events

### Ideal Applications

| Use Case | Description | Why SSE is Perfect |
|----------|-------------|-------------------|
| **News Feeds** | Continuous news updates without page refresh | One-way data flow, periodic updates |
| **Live Stock Prices** | Real-time financial data on web pages | Frequent price updates, no user interaction needed |
| **Notifications & Alerts** | System alerts and user notifications | Push-based delivery, simple implementation |
| **Progress Updates** | Long-running operation status | Server reports progress, client displays status |
| **Live Monitoring Dashboards** | System metrics with minimal interactivity | Continuous data display, read-only interface |
| **Sensor Data Streaming** | IoT device data feeds | Periodic sensor readings, one-way data flow |

## Understanding WebSockets

### Core Characteristics

WebSockets provide full-duplex communication capabilities for applications requiring bidirectional real-time interaction.

| Feature | Description | Advantage |
|---------|-------------|-----------|
| **Persistent Connection** | Long-lived connection between client and server | Eliminates connection setup overhead |
| **Bidirectional Communication** | Both client and server can initiate messages | True interactive communication |
| **Low Overhead** | Minimal protocol overhead after initial handshake | Efficient for frequent message exchange |
| **Native Browser Support** | Built-in WebSocket API in modern browsers | Easy integration with web applications |

### Protocol Comparison

| Aspect | Server-sent Events | WebSockets |
|--------|-------------------|------------|
| **Communication Direction** | Server → Client only | Client ↔ Server (bidirectional) |
| **Protocol** | HTTP with special headers | WebSocket protocol (after HTTP upgrade) |
| **Connection Overhead** | Lower | Slightly higher initial handshake |
| **Use Case Complexity** | Simple streaming | Interactive applications |
| **Browser API** | EventSource API | WebSocket API |

## Use Cases for WebSockets

### Ideal Applications

| Use Case | Description | Why WebSockets Excel |
|----------|-------------|---------------------|
| **Chat Applications** | Real-time messaging between users | Bidirectional messaging, instant delivery |
| **Collaborative Editing Tools** | Multiple users editing same document | Real-time synchronization, conflict resolution |
| **Multiplayer Games** | Interactive gaming experiences | Low latency, frequent bidirectional updates |
| **Interactive Dashboards** | Dashboards with user controls affecting data | User interactions trigger server responses |
| **Real-time Collaboration** | Shared workspaces, whiteboards | Immediate sharing of user actions |

### WebSocket Implementation Pattern

```python
# Example: Basic WebSocket handler structure
async def websocket_handler(request):
    """WebSocket handler for bidirectional communication"""
    ws = web.WebSocketResponse()
    await ws.prepare(request)
    
    async for msg in ws:
        if msg.type == aiohttp.WSMsgType.TEXT:
            # Handle incoming message from client
            data = json.loads(msg.data)
            
            # Process message and send response
            response = await process_message(data)
            await ws.send_str(json.dumps(response))
            
        elif msg.type == aiohttp.WSMsgType.ERROR:
            print(f'WebSocket error: {ws.exception()}')
    
    return ws
```

## Protocol Selection Guide

### Decision Matrix

| Requirement | Recommended Protocol | Reason |
|-------------|---------------------|---------|
| **One-way data streaming** | Server-sent Events | Simpler implementation, lower overhead |
| **Bidirectional communication** | WebSockets | Full duplex capability |
| **Simple implementation** | Server-sent Events | Uses standard HTTP, easier debugging |
| **Complex interactions** | WebSockets | Rich message types, state management |
| **High frequency updates** | WebSockets | Lower per-message overhead |
| **Periodic updates** | Server-sent Events | Built for streaming scenarios |

### Architecture Considerations

| Factor | Server-sent Events | WebSockets |
|--------|-------------------|------------|
| **Scalability** | Higher (HTTP-based) | Moderate (connection state) |
| **Complexity** | Lower | Higher |
| **Debugging** | Easier (HTTP tools) | Requires WebSocket tools |
| **Firewall/Proxy** | Better compatibility | May require configuration |
| **Mobile Battery** | More efficient | Less efficient for simple streams |

## Implementation Best Practices

### Server-sent Events Best Practices

| Practice | Implementation | Benefit |
|----------|----------------|---------|
| **Error Handling** | Wrap streaming logic in try/catch | Graceful connection cleanup |
| **Connection Limits** | Track active connections | Prevent resource exhaustion |
| **Data Formatting** | Use proper SSE event format | Ensure client compatibility |
| **Heartbeat Messages** | Send periodic keep-alive | Detect connection drops |

### WebSocket Best Practices

| Practice | Implementation | Benefit |
|----------|----------------|---------|
| **Message Validation** | Validate all incoming messages | Security and stability |
| **Connection State** | Track connection lifecycle | Proper resource management |
| **Error Recovery** | Implement reconnection logic | Robust user experience |
| **Message Queuing** | Buffer messages during disconnection | Data integrity |

## Demo: Streaming Real-time Data

> **Demo File**: [`demo/aiohttp_server.py`](demo/aiohttp_server.py)

Let's implement a practical Server-sent Events demo to stream real-time temperature data and understand how SSE works in practice.

### SSE Handler Implementation

We've added a new `sse_handler` coroutine to our AioHTTP server that demonstrates streaming temperature data:

```python
async def sse_handler(request):
    # Initialize a streaming response
    r = web.StreamResponse()
    # Set headers
    r.headers["Content-Type"] = "text/event-stream"
    r.headers["Cache-Control"] = "no-cache"
    r.headers["Connection"] = "keep-alive"
    # Send headers to client
    await r.prepare(request)
    counter = 0
    # Stream data events up to 3 times
    while counter < 3:
        counter += 1
        data = "Temperature: 70 \n"
        # Send event data chunk
        await r.write(data.encode("utf-8"))
        # Non-blocking delay for 1 second
        await asyncio.sleep(1)

    # Finalize stream
    await r.write_eof()
    return r
```

**Key Implementation Details**:

1. **StreamResponse Creation**: Unlike regular JSON responses, we create a `web.StreamResponse()` for continuous data streaming
2. **SSE Headers Configuration**:
   - `text/event-stream`: Identifies this as a Server-sent Events stream
   - `no-cache`: Ensures clients receive fresh data without caching
   - `keep-alive`: Maintains the persistent connection
3. **Counter-Limited Loop**: Instead of an infinite loop, we stream exactly 3 temperature readings
4. **Data Encoding**: Each message is encoded as UTF-8 before writing to the stream
5. **Non-blocking Sleep**: `await asyncio.sleep(1)` allows the server to handle other clients during the delay
6. **Stream Finalization**: `await r.write_eof()` signals the end of the stream to clients
7. **Response Return**: The handler returns the response object as required by AioHTTP

### Route Configuration

The new endpoint is added to handle SSE requests:

```python
app.router.add_get("/events", sse_handler)
```

This creates a GET endpoint at `/events` that clients can connect to for receiving real-time temperature updates.

### Server Configuration for Gunicorn

Notice the server setup optimized for production deployment:

```python
# gunicorn aiohttp_server:app --bind localhost:8080 --worker-class aiohttp.GunicornWebWorker --workers 2
# web.run_app(app)  # ← Commented out for Gunicorn deployment
```

The commented line shows how to start the server with Gunicorn for scalable real-time applications.

### Testing the SSE Stream

Using `curl` to test the Server-sent Events endpoint:

```bash
❯ curl http://localhost:8080/events
Temperature: 70 
Temperature: 70 
Temperature: 70 
```

**Demo Results Analysis**:

| Aspect | Observation | Explanation |
|--------|-------------|-------------|
| **Streaming Behavior** | Three messages delivered sequentially | Counter-controlled loop sends exactly 3 events |
| **Timing** | Messages arrive with 1-second intervals | `asyncio.sleep(1)` creates realistic streaming delay |
| **Connection Persistence** | Single curl command receives all messages | SSE maintains connection throughout the stream |
| **Data Format** | Simple text format: "Temperature: 70" | Basic data format suitable for demonstration |

### Real-time Streaming Features Demonstrated

1. **Persistent Connection**: The client maintains a single connection to receive multiple messages
2. **Server-initiated Pushing**: The server actively sends data without client requests
3. **Asynchronous Processing**: The server can handle other requests while streaming
4. **Controlled Stream Termination**: The stream ends gracefully after 3 messages
5. **Standard HTTP Protocol**: Works with simple tools like `curl` without special client libraries

### Production Considerations

For real-world applications, you might enhance this pattern with:

- **Dynamic data**: Replace static "Temperature: 70" with actual sensor readings
- **Error handling**: Add try/catch blocks for robust connection management
- **Client tracking**: Monitor active connections to prevent resource exhaustion
- **Proper SSE formatting**: Use `data:` prefix and double newlines for browser compatibility

This demo successfully demonstrates how Server-sent Events enable real-time data streaming from AioHTTP servers to clients using standard HTTP connections.