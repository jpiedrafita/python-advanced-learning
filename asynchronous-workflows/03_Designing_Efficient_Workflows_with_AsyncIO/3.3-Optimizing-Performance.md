# 3.3 Optimizing Performance

## Overview

Performance optimization in asynchronous applications focuses on avoiding blocking operations, implementing effective timeout strategies, and using task cancellation to maintain responsiveness. This lesson provides concrete approaches to identify and resolve performance bottlenecks in AsyncIO applications.

## Learning Objectives

By the end of this lesson, you will be able to:

| Objective | Description |
|-----------|-------------|
| **Identify Blocking Operations** | Recognize synchronous code that blocks the event loop |
| **Use Async Libraries** | Replace blocking libraries with asynchronous alternatives |
| **Implement Timeouts** | Prevent applications from hanging indefinitely |
| **Handle Cancellation** | Gracefully terminate long-running tasks |
| **Profile Performance** | Identify bottlenecks and optimize critical paths |

## Avoiding Blocking Operations

### Four Concrete Approaches

| Approach | Description | When to Use |
|----------|-------------|-------------|
| **1. Specialized Async Libraries** | Use async-native libraries | First choice - simplest solution |
| **2. Thread/Process Pools** | Offload blocking operations | When async libraries unavailable |
| **3. Chunking Operations** | Break large operations into pieces | Intermediate approach with control yielding |
| **4. Application Profiling** | Identify problematic blocking code | When unsure what's causing blocks |

### Async Library Alternatives

Replace common blocking libraries with their asynchronous counterparts:

| Blocking Library | Async Alternative | Use Case |
|------------------|-------------------|----------|
| **`requests`** | **`aiohttp`** | HTTP requests and API calls |
| **Standard file I/O** | **`aiofiles`** | File read/write operations |
| **`psycopg2`** | **`asyncpg`** | PostgreSQL database operations |
| **`sqlite3`** | **`aiosqlite`** | SQLite database operations |

#### Example: HTTP Request Optimization

```python
# ❌ Blocking approach
import requests
response = requests.get("https://api.example.com/data")

# ✅ Async approach  
import aiohttp
async with aiohttp.ClientSession() as session:
    async with session.get("https://api.example.com/data") as response:
        data = await response.json()
```

### Chunking Large Operations

```python
async def process_large_dataset(data):
    """Process data in chunks to yield control to event loop"""
    chunk_size = 1000
    
    for i in range(0, len(data), chunk_size):
        chunk = data[i:i + chunk_size]
        
        # Process chunk synchronously
        process_chunk(chunk)
        
        # Yield control back to event loop
        await asyncio.sleep(0)
```

## Timeout Management

### Why Timeouts Matter

| Benefit | Description | Example Scenario |
|---------|-------------|------------------|
| **Prevent Hanging** | Applications don't freeze indefinitely | External API becomes unresponsive |
| **User Responsiveness** | Meet response time requirements | Web requests must complete within 5 seconds |
| **Resource Management** | Free critical resources like DB connections | Database query pool exhaustion |
| **Fallback Mechanisms** | Switch to alternative solutions | Primary API slow, use backup endpoint |
| **Prevent Cascading Failures** | Limit impact of slow dependencies | One slow service doesn't block entire app |

### Timeout Implementation Strategies

| Strategy | Implementation | Best Practice |
|----------|----------------|---------------|
| **Appropriate Values** | Different timeouts for different operations | Health checks: 1s, Critical ops: 30s |
| **Exception Handling** | Always catch `asyncio.TimeoutError` | Graceful degradation and user feedback |
| **Retry Logic** | Implement exponential backoff | 3 retries with increasing delays |
| **Event Logging** | Log timeout events for analysis | Track patterns and system issues |
| **Testing Scenarios** | Test timeout behavior | Simulate slow dependencies |

#### Example: Timeout with Retry Logic

```python
import asyncio

async def robust_api_call(url, max_retries=3):
    """API call with timeout and retry logic"""
    for attempt in range(max_retries):
        try:
            # Set timeout for each attempt
            async with asyncio.timeout(5.0):
                async with aiohttp.ClientSession() as session:
                    async with session.get(url) as response:
                        return await response.json()
                        
        except asyncio.TimeoutError:
            if attempt == max_retries - 1:
                raise
            
            # Exponential backoff
            wait_time = 2 ** attempt
            await asyncio.sleep(wait_time)
            
        except Exception as e:
            logging.error(f"API call failed: {e}")
            raise
```

## Task Cancellation

### Cancellation-Aware Coroutines

Task cancellation is a powerful AsyncIO feature that improves responsiveness and prevents resource waste.

```python
async def long_running_task():
    """Example of a cancellation-aware coroutine"""
    try:
        # Simulate actual work that might take time
        for i in range(100):
            await asyncio.sleep(0.1)  # Could be calling other coroutines
            print(f"Processing step {i}")
            
    except asyncio.CancelledError:
        print("Task was cancelled")
        # Best practice: re-raise to propagate cancellation
        raise
        
    finally:
        # Clean up resources regardless of completion or cancellation
        print("Cleaning up resources...")
        # Close files, database connections, etc.
```

### Cancellation Best Practices

| Practice | Implementation | Benefit |
|----------|----------------|---------|
| **Handle CancelledError** | Use try/except blocks | Graceful cancellation response |
| **Propagate Cancellation** | Re-raise CancelledError | Maintain cancellation chain |
| **Resource Cleanup** | Use finally blocks | Prevent resource leaks |
| **Check Cancellation** | Periodic cancellation checks | Responsive to cancellation requests |

## Practical Demo: Timeout Enforcement

> **Demo Reference**: See complete implementation in [`demo/optimiza_slow_code.py`](demo/optimiza_slow_code.py)

### Worker Task Implementation

```python
async def worker_task(name, duration):
    """Cancellation-aware worker that simulates long-running operations"""
    print(f"{name}: Starting (duration: {duration} seconds)")
    try:
        # Simulate work with periodic progress updates
        for i in range(duration):
            await asyncio.sleep(1)  # Simulate 1 second of work per iteration
            print(f"{name}: Progress {i+1}/{duration} seconds")
            
        print(f"{name}: Completed successfully")
        
    except asyncio.CancelledError:
        # Handle cancellation gracefully with logging
        print(f"{name}: Cancelled")
        raise  # Propagate cancellation to maintain cancellation chain
        
    finally:
        # Clean up resources regardless of completion or cancellation
        print(f"{name}: Cleaning up resources")
```

**Key Features from Transcription**:
- **Progress tracking**: Each task reports its progress every second
- **Cancellation handling**: `CancelledError` is caught, logged, and re-raised
- **Resource cleanup**: `finally` block ensures cleanup happens in all scenarios

### TaskGroup with Timeout Demo

```python
async def create_task_group():
    """Create multiple tasks with different durations using TaskGroup"""
    async with asyncio.TaskGroup() as tg:
        # Task 1: Quick API call (1 second)
        tg.create_task(worker_task(name="Call API", duration=1))
        # Task 2: Database operation (1 second) 
        tg.create_task(worker_task(name="Load from DB", duration=1))
        # Task 3: File processing - longest operation (3 seconds)
        tg.create_task(worker_task(name="Read very large file", duration=3))
	    print("All tasks are created")

async def timeout_with_taskgroup():
    """Demonstrate timeout cancellation with TaskGroup"""
    # Create and start task group immediately
    task = asyncio.create_task(create_task_group())
    # Let tasks run for 2 seconds, then enforce timeout
    await asyncio.sleep(2)
    print(f"Task group timeout reached after 2 seconds")
    
    # Cancel the entire task group
    task.cancel()
    
    try:
        # Wait for cancellation to complete
        await task
    except asyncio.CancelledError:
        print("Task group was cancelled due to timeout")

async def main():
    """Measure execution time of timeout demonstration"""
    start_time = time.perf_counter()
    
    await timeout_with_taskgroup()
    
    end_time = time.perf_counter()
    print(f"Duration: {round(end_time - start_time, 2)}")
```

**TaskGroup Cancellation Features**:
- **Automatic propagation**: TaskGroups propagate cancellation to all child tasks
- **No extra code needed**: Cancellation handling is built-in to TaskGroup
- **Immediate termination**: When parent task is cancelled, all tasks in group are cancelled

### Expected Execution Analysis

| Task | Duration | Status After 2s | Outcome |
|------|----------|-----------------|---------|
| **Call API** | 1 second | ✅ Completed | Finished successfully with cleanup |
| **Load from DB** | 1 second | ✅ Completed | Finished successfully with cleanup |
| **Read large file** | 3 seconds | ❌ Cancelled at 2s | Progress: 1/3, then cancelled and cleaned up |
| **Total Time** | **2.0 seconds** | Timeout enforced | TaskGroup cancellation propagated |

**Key Learning Points**:
1. **Concurrent execution**: All tasks start immediately and run in parallel
2. **Independent completion**: Fast tasks (1s) complete while slow task (3s) is still running
3. **Timeout enforcement**: After 2 seconds, cancellation is triggered
4. **Graceful cancellation**: Long-running task responds to cancellation and cleans up resources
5. **TaskGroup behavior**: Cancellation automatically propagates to all tasks in the group

#### Demo Output

> **Actual Output**: Run `python` [`demo/optimiza_slow_code.py`](demo/optimiza_slow_code.py) to see this execution

```bash
Call API: Starting (duration: 1 seconds)
Load from DB: Starting (duration: 1 seconds)
Read very large file: Starting (duration: 3 seconds)
Call API: Progress 1/1 seconds
Call API: Completed successfully
Call API: Cleaning up resources
Load from DB: Progress 1/1 seconds
Load from DB: Completed successfully
Load from DB: Cleaning up resources
Read very large file: Progress 1/3 seconds
Task group timeout reached after 2 seconds
Read very large file: Cancelled
Read very large file: Cleaning up resources
Task group was cancelled due to timeout
Duration: 2.0
```

**Execution Analysis**:
- **Lines 1-3**: All three tasks start simultaneously (concurrent execution begins)
- **Lines 4-6**: "Call API" completes after 1 second, including resource cleanup
- **Lines 7-9**: "Load from DB" also completes after 1 second with cleanup
- **Line 10**: "Read very large file" shows progress (1 of 3 seconds completed)
- **Line 11**: Timeout enforcement triggers after exactly 2 seconds
- **Lines 12-13**: File reading task receives cancellation and performs cleanup
- **Lines 14-15**: TaskGroup cancellation confirmation and total duration (2.0 seconds)

## Performance Optimization Checklist

| Category | Action Items | Impact |
|----------|-------------|---------|
| **Library Selection** | ✅ Use async libraries (aiohttp, aiofiles, asyncpg) | High |
| **Timeout Strategy** | ✅ Set appropriate timeouts for all external calls | High |
| **Error Handling** | ✅ Handle TimeoutError and CancelledError gracefully | Medium |
| **Resource Management** | ✅ Use finally blocks for cleanup | Medium |
| **Monitoring** | ✅ Log performance metrics and timeout events | Medium |
| **Testing** | ✅ Test timeout and cancellation scenarios | High |

## Common Anti-Patterns to Avoid

| Anti-Pattern | Problem | Solution |
|--------------|---------|----------|
| **Blocking I/O** | Using `requests` instead of `aiohttp` | Use async libraries |
| **No Timeouts** | Operations can hang forever | Implement timeout strategies |
| **Ignoring Cancellation** | Tasks don't respond to cancellation | Handle CancelledError properly |
| **Resource Leaks** | No cleanup on cancellation | Use finally blocks |
| **Cascading Failures** | One slow operation blocks everything | Isolate operations with timeouts |

