
# 3.1 Working With Event Loops

## Overview

The event loop is the core component of AsyncIO that enables high-performance, scalable applications. This lesson covers best practices for managing event loops effectively and explores how to customize event loop behavior for specialized use cases.

## Top 3 Best Practices for Managing Event Loops

### 1. Never Run Blocking Code in the Event Loop

**Problem**: Running blocking code directly in the event loop prevents it from processing other tasks, leading to poor performance.

#### ❌ Bad Practice

```python
async def bad_practice():
    time.sleep(1)  # Blocking call - blocks entire event loop
    print("This blocks everything!")
```

#### ✅ Good Practice

```python
async def good_practice():
    await asyncio.sleep(1)  # Non-blocking sleep
    print("This doesn't block the event loop!")
```

#### Workaround for Unavoidable Blocking Code

```python
import asyncio
import time

async def workaround():
    # Offload blocking code to a separate thread
    await asyncio.to_thread(time.sleep, 1)
    print("Blocking code handled safely!")
```

**Note**: Use `asyncio.to_thread()` cautiously to avoid creating too many threads.

### 2. Never Create Multiple Event Loops in the Same Thread

**Problem**: Multiple event loops in the same thread cause conflicts and unexpected behavior as they compete for task and resource management.

| Issue | Description |
|-------|-------------|
| **Resource Conflicts** | Multiple loops trying to manage the same resources |
| **Task Scheduling Conflicts** | Competing task schedulers causing unpredictable execution |
| **Memory Issues** | Increased memory usage and potential leaks |
| **Debugging Complexity** | Much harder to troubleshoot issues |

**Solution**: Use only one event loop per thread. Use `asyncio.run()` or `asyncio.get_event_loop()` properly.

### 3. Always Close Resources Properly

**Critical Resources to Manage**:
- File handles
- Network connections
- Database connections
- Client sessions

#### Benefits of Proper Resource Management

| Benefit | Description |
|---------|-------------|
| **Prevents Memory Leaks** | Ensures resources are freed when no longer needed |
| **Application Stability** | Reduces crashes and unresponsive behavior |
| **Clean Shutdown** | Ensures graceful application termination |
| **Easier Debugging** | Prevents resource-related errors |
| **Efficient Resource Usage** | Optimizes system resource utilization |

#### Using Async Context Managers

```python
import aiohttp
import asyncio

async def fetch(session, url):
    async with session.get(url) as response:  # Auto-closes response
        return await response.json()

async def fetch_all():
    async with aiohttp.ClientSession() as session:  # Auto-closes session
        tasks = [fetch(session, url) for url in API_URLS]
        results = await asyncio.gather(*tasks)
        return results
```

**Key Advantage**: Async context managers automatically handle resource cleanup, eliminating manual resource management code.

## Custom Event Loops

### When to Consider Custom Event Loops

| Scenario | Use Case | Description |
|----------|----------|-------------|
| **Complex Resource Cleanup** | Specialized applications | When standard context managers have limitations |
| **Advanced Exception Handling** | Sophisticated recovery | Custom exception recovery mechanisms beyond AsyncIO defaults |
| **Enhanced Debugging** | Complex troubleshooting | Additional logging and context tracking for root cause analysis |

### Example: Custom Timing Event Loop

#### Step 1: Create Custom Event Loop

```python
import asyncio
import time

# Extend an existing event loop
class TimingEventLoop(asyncio.SelectorEventLoop):
    
    # Override to measure execution time
    def run_until_complete(self, f):
        # Measure start time
        start_time = time.perf_counter()
        
        # Call parent implementation
        result = super().run_until_complete(f)
        
        # Measure end time and print duration
        end_time = time.perf_counter()
        print(f"{end_time - start_time}")
        
        return result

# Extend existing event loop policy
class TimingEventLoopPolicy(asyncio.DefaultEventLoopPolicy):
    
    # Returns instance of the custom event loop
    def new_event_loop(self):
        return TimingEventLoop()
```

#### Step 3: Use Custom Event Loop

**File: [`custom_client_aiohttp.py`](demo/custom_client_aiohttp.py)**
```python
import asyncio
import time
from aiohttp import ClientSession
from custom_event_loop import TimingEventLoopPolicy

API_URLS = [
    "http://localhost:8080/names/1",
    "http://localhost:8080/names/2",
] * 1000  # simula carga de 2000 peticiones

async def fetch(session, url):
    async with session.get(url) as response:
        return await response.json()

async def fetch_all():
    start_time = time.perf_counter()

    async with ClientSession() as session:
        tasks = [fetch(session, url) for url in API_URLS]
        results = await asyncio.gather(*tasks)
        # print(results)

    end_time = time.perf_counter()
    print(f"Duration: {round(end_time - start_time, 2)}")

# Set the custom event loop policy
asyncio.set_event_loop_policy(TimingEventLoopPolicy())
asyncio.run(fetch_all())
```

**Actual Output**:
```bash
❯ python custom_client_aiohttp.py
Duration: 0.15
Event loop execution time: 0.15 seconds
Event loop execution time: 0.0 seconds
Event loop execution time: 0.0 seconds
```

## Practical Demo Results

### Before Custom Event Loop
```python
# Manual timing code in client
start_time = time.perf_counter()
asyncio.run(fetch_all())
end_time = time.perf_counter()
print(f"Duration: {end_time - start_time:.2f} seconds")
```

### After Custom Event Loop
```python
# Clean code - timing handled by event loop
asyncio.run(fetch_all())
# Timing automatically printed by custom event loop
```

## Benefits of Custom Event Loops

| Benefit | Description |
|---------|-------------|
| **Fine-grained Control** | Complete control over event loop behavior |
| **Automatic Instrumentation** | Built-in logging, timing, and monitoring |
| **Cleaner Application Code** | Removes boilerplate measurement/logging code |
| **Consistent Behavior** | Applies custom behavior to all coroutines automatically |
| **Enhanced Debugging** | Custom exception handling and context tracking |

## Best Practices Summary

| Practice | Key Point | Implementation |
|----------|-----------|----------------|
| **Avoid Blocking Code** | Use `await asyncio.sleep()` instead of `time.sleep()` | Replace blocking calls with async alternatives |
| **Single Event Loop** | One loop per thread only | Use `asyncio.run()` or proper loop management |
| **Resource Cleanup** | Always use async context managers | Implement `async with` for all resources |
| **Custom Loops** | Use for specialized requirements only | Extend existing loops, don't build from scratch |

## Common Pitfalls to Avoid

| Pitfall | Problem | Solution |
|---------|---------|----------|
| **Blocking in Event Loop** | Poor performance, unresponsive app | Use async alternatives or `asyncio.to_thread()` |
| **Multiple Loops** | Conflicts and unpredictable behavior | Stick to one loop per thread |
| **Forgotten Resources** | Memory leaks and crashes | Always use `async with` context managers |
| **Overengineering** | Unnecessary complexity | Use custom loops only when standard features are insufficient |

Custom event loops are powerful tools that provide fine-grained control over AsyncIO behavior. Use them judiciously when standard AsyncIO features don't meet your specific requirements for logging, timing, exception handling, or resource management.