# 2.3 Building an Asynchronous HTTP Client

## Overview

In this lesson, we'll explore how to build HTTP clients using both the traditional synchronous `requests` library and the asynchronous `aiohttp` library. We'll compare their performance characteristics and understand when to use each approach.

## Synchronous HTTP Client with Requests

The `requests` library is the most popular choice for HTTP requests in Python due to its simplicity:

```python
# Installation
# pip install requests

import requests

URL = "http://localhost:8080/names/1"

response = requests.get(URL)
data = response.json()
print(data)
```

**Output:**
```bash
{'id': '1', 'name': 'Sophia'}
```

### Key Characteristics of Requests

| Aspect | Description |
|--------|-------------|
| **Execution Model** | Synchronous (blocking) |
| **Learning Curve** | Very intuitive and beginner-friendly |
| **Performance** | Lower performance for multiple requests |
| **Use Cases** | Scripts, basic applications, simple automation |

## Asynchronous HTTP Client with AioHTTP

AioHTTP provides a more sophisticated approach for HTTP clients:

```python
import aiohttp
import asyncio

URL = "http://localhost:8080/names/1"

async def fetch_url():
    async with aiohttp.ClientSession() as session:
        async with session.get(URL) as response:
            data = await response.json()
            print(data)

asyncio.run(fetch_url())
```

**Output:**
```bash
{'id': '1', 'name': 'Sophia'}
```

### Key Components Explained

| Component | Purpose |
|-----------|---------|
| `ClientSession()` | Manages connection pooling and session state |
| `async with` | Asynchronous context manager for automatic resource cleanup |
| `session.get()` | Sends HTTP GET request asynchronously |
| `response.json()` | Parses response body as JSON asynchronously |

## Performance Comparison Demo

Let's compare the performance of both approaches by making multiple HTTP requests:

### Synchronous Client Implementation

**File: [`client_requests.py`](demo/client_requests.py)**
```python
import requests
import time

API_URLS = [
    "http://localhost:8080/names/1",
    "http://localhost:8080/names/2",
] * 1000

start_time = time.perf_counter()

for url in API_URLS:
    response = requests.get(url)
    # print(response.json())

end_time = time.perf_counter()
print(f"Duration: {round(end_time - start_time, 2)} seconds")
```

```bash
❯ python client_requests.py
Duration: 4.55 seconds
```
### Asynchronous Client Implementation

**File: [`client_aiohttp.py`](demo/client_aiohttp.py)**
```python
from aiohttp import ClientSession
import asyncio
import time

API_URLS = [
    "http://localhost:8080/names/1",
    "http://localhost:8080/names/2",
] * 1000

async def fetch(session, url):
    async with session.get(url) as response:
        return await response.json()

async def fetch_all():
    async with ClientSession() as session:
        tasks = [fetch(session, url) for url in API_URLS]
        results = await asyncio.gather(*tasks)
        # print(results)

start_time = time.perf_counter()
asyncio.run(fetch_all())
end_time = time.perf_counter()
print(f"Duration: {round(end_time - start_time, 2)} seconds")
```

```bash
❯ python client_aiohttp.py
Duration: 0.15 seconds
```
## Performance Analysis

| Metric | Synchronous (Requests) | Asynchronous (AioHTTP) | Improvement |
|--------|------------------------|------------------------|-------------|
| **Execution Time** | 4.55 seconds | 0.15 seconds | **30x faster** |
| **Execution Model** | Sequential (one at a time) | Concurrent (all at once) | Massive parallelism |
| **Resource Usage** | Blocks thread per request | Single thread, event loop | Efficient resource usage |
| **Scalability** | Poor (linear growth) | Excellent (logarithmic growth) | High scalability |

## When to Use Each Approach

### Use Requests When:
- Building simple scripts or prototypes
- Making occasional HTTP requests
- Team lacks async/await experience
- Working with legacy codebases
- Simplicity is more important than performance

### Use AioHTTP When:
- Building high-performance APIs
- Making many concurrent requests
- Developing scalable web applications
- Performance is critical
- Working with other async libraries

## Summary

| **Characteristic** | **AioHTTP Client** | **Requests Client** |
|---|---|---|
| **Execution Model** | Asynchronous (non-blocking) | Synchronous (blocking) |
| **Async Knowledge Required** | Yes | No |
| **Ease of Use** | More complex | Very intuitive |
| **Performance** | High | Low |
| **Typical Use Cases** | Fast and scalable APIs | Scripts or basic applications |
| **Concurrency** | Built-in with `asyncio.gather()` | Requires threading/multiprocessing |
| **Resource Management** | Automatic with context managers | Manual or basic with statements |

The choice between synchronous and asynchronous HTTP clients depends on your specific requirements. For high-performance applications with many HTTP requests, AioHTTP provides significant advantages. For simple scripts and basic applications, the requests library offers simplicity and ease of use.