# 2.1 defaultdict

## 2.1.1 Understanding defaultdict

- **defaultdict**: `defaultdict` is a subclass of the built-in `dict` class. It is part of the `collections` module and provides all the methods provided by the dictionary but with one added capability: it takes a default factory function as its first argument. This default factory is called to provide a default value for the dictionary whenever a key is accessed but does not exist in the dictionary.

- **Creation**: To create a `defaultdict`, you must provide a default factory function that will be called to provide a default value for non-existent keys. This factory can be any callable object (function, lambda, etc.)

```python
from collections import defaultdict

print(issubclass(defaultdict, dict))

# Using list() as the default factory provides an empty list
dd = defaultdict(list)
```

Output:
```python
True
```

- **Adding items**: We can append values to the keys with the `append()` method. Accessing an element from a non-existing key, a default dictionary will create it and assign it the default value.

```python
from collections import defaultdict

dd = defaultdict(list)

dd["key1"].append(1)
dd["key2"].append(2)
print(dd["key3"])  # Creates 'key3' with an empty list as default
print(dd)
```

Output:
```python
[]
defaultdict(<class 'list'>, {'key1': [1], 'key2': [2], 'key3': []})
```

- **`defaultdict` versus the `setdefault` method**: We could use a regular dictionary with the `setdefault` method in any situation, but the point of these dictionary subclasses is not to replace the original dictionary. The purpose is to provide **readability, clarity, and ease of implementation** in specific scenarios.
	- `defaultdict` class can only use factory functions for defining default values.
	- We can bypass this restriction by returning any value from an anonymous lambda function.
	- `defaultdict` is slightly faster in handling missing keys than the `setdefault` method.
	- `defaultdict` calls its default _factory_ **only when a missing key is accessed** (lazy), while `dict.setdefault(key, default)` **evaluates the default expression immediately** (eager) before it even checks whether the key exists—so the “factory” runs even if the key is already present, which can hurt performance if that default is expensive.

```python
from collections import defaultdict

# Standard dict using setdefault
std_dict = {}
std_dict.setdefault("key", "Default")
print(std_dict["key"])  # "Default"

# defaultdict using a lambda as default factory
dd = defaultdict(lambda: "Default")
print(dd["key"])  # "Default"
```

```python
from timeit import timeit

# Setup for timing the appending operation for defaultdict
setup_defaultdict_append = """
from collections import defaultdict
dd = defaultdict(list)
"""

stmt_defaultdict_append = "[dd[f'key_{i // 2}'].append(1) for i in range(2000000)]"

time_defaultdict_append = timeit(stmt=stmt_defaultdict_append,
                                 setup=setup_defaultdict_append,
                                 number=10)

# Setup for timing the appending operation for dict using setdefault
setup_setdefault_append = """
std_dict = {}
"""

stmt_setdefault_append = "[std_dict.setdefault(f'key_{i // 2}', []).append(1) for i in range(2000000)]"

time_setdefault_append = timeit(stmt=stmt_setdefault_append,
                                setup=setup_setdefault_append,
                                number=10)

print("defaultdict:", time_defaultdict_append)
print("setdefault:", time_setdefault_append)
```

Output:
```python
defaultdict: 4.83372971600329
setdefault: 5.139772731003177
```

```python
# Demonstrating eager evaluation of dict.setdefault vs lazy default in defaultdict
from collections import defaultdict

def long_factory_function(trigger):
    # Pretend this is expensive (heavy computation / I/O)
    print(f"Factory function ran by {trigger}")
    return []

# defaultdict with a factory that would run only for missing keys
dd = defaultdict(lambda: long_factory_function("defaultdict"))

# A regular dict that *already* has the key
std_dict = {"existing_key": []}

# --- defaultdict path ---
# Accessing an existing key in dd does NOT trigger the factory.
# If "existing_key" were missing, the lambda would run and create [].
dd["existing_key"].append(1)

# --- setdefault path ---
# setdefault evaluates its second argument BEFORE checking the key.
# So long_factory_function("setdefault") runs even though "existing_key" exists.
std_dict.setdefault("existing_key", long_factory_function("setdefault")).append(1)
```

Output:
```python
Factory function ran by setdefault
```


| **Concept**            | **Description**                                                                                                                                             |
| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Purpose**            | `defaultdict` (from `collections`) is a subclass of `dict` that automatically assigns a default value to non-existent keys using a factory function.              |
| **Creation**           | Import from `collections` and pass a callable (e.g., `list`, `int`, `lambda: value`) as the factory. The callable is invoked when a missing key is accessed.        |
| **Behavior**           | Accessing a missing key creates it automatically with the factory’s return value. Useful for avoiding manual checks before inserting/appending.             |
| **Comparison to dict** | Similar behavior to `dict.setdefault(key, default)` or `dict.get(key, default)`, but more concise and slightly faster for missing keys.                         |
| **Performance**        | `defaultdict` is generally faster than `setdefault` for handling many missing keys.                                                                             |
| **Caveat**             | `setdefault` always calls the default value expression (or factory function) even if the key exists, which can hurt performance if the function is expensive. |
| **Use Case**           | Ideal when handling many keys that may not exist yet and need an initial default value (e.g., lists for grouping, counters, accumulators).                  |

## 2.1.2 Using defaultdict

### Grouping Elements

- **Grouping elements**: Use `defaultdict(list)` to categorize items without having to manually initialize the list for each key.

```python
from collections import defaultdict

# Sample list of items, each represented as (item, item_type)
items = [
    ("Apple", "Fruit"),
    ("Banana", "Fruit"),
    ("Hammer", "Tool"),
    ("Screwdriver", "Tool"),
    ("Laptop", "Electronics"),
    ("Smartphone", "Electronics")
]

# Using defaultdict(list) for grouping elements
dd = defaultdict(list)
for item, item_type in items:
    dd[item_type].append(item)
    # Regular dict would work like this:
    # std_dict.setdefault(item_type, []).append(item)

print(dd)
```

Output:
```python
defaultdict(<class 'list'>, {
    'Fruit': ['Apple', 'Banana'],
    'Tool': ['Hammer', 'Screwdriver'],
    'Electronics': ['Laptop', 'Smartphone']
})
```

### Grouping Unique Elements

- **Grouping without duplicates**: Switch to `defaultdict(set)` so each key stores unique elements and duplicates are automatically avoided.

```python
from collections import defaultdict

items = [
    ("Apple", "Fruit"),
    ("Banana", "Fruit"),
    ("Banana", "Fruit"),
    ("Banana", "Fruit"),
    ("Hammer", "Tool"),
    ("Hammer", "Tool"),
    ("Hammer", "Tool"),
    ("Screwdriver", "Tool"),
    ("Laptop", "Electronics"),
    ("Smartphone", "Electronics")
]

dd = defaultdict(set)
for item, item_type in items:
    dd[item_type].add(item)

print(dd)
```

Output:
```python
defaultdict(<class 'set'>, {
    'Fruit': {'Apple', 'Banana'},
    'Tool': {'Screwdriver', 'Hammer'},
    'Electronics': {'Laptop', 'Smartphone'}
})
```

### Counting Elements which Belong to the Same Category

- **Counting items by category**: Use `defaultdict(int)` to initialize counters at 0 and increment them directly without prior checks.

```python
from collections import defaultdict

items = [
    ("Apple", "Fruit"),
    ("Banana", "Fruit"),
    ("Hammer", "Tool"),
    ("Screwdriver", "Tool"),
    ("Laptop", "Electronics"),
    ("Smartphone", "Electronics")
]

dd = defaultdict(int)  # default value for int() is 0
for _, item_type in items:
    dd[item_type] += 1

print(dd)
```

Output:
```python
defaultdict(<class 'int'>, {
    'Fruit': 2,
    'Tool': 2,
    'Electronics': 2
})
```

### Calculating Total Sum for Each Category

- **Summing values by category**: Use `defaultdict(int)` to accumulate totals (e.g., prices) for each category in a straightforward way.

```python
from collections import defaultdict

# Sample list of items, each represented as (item, price, type)
items = [
    ("Apple", 5, "Fruit"),
    ("Banana", 3, "Fruit"),
    ("Hammer", 10, "Tool"),
    ("Screwdriver", 10, "Tool"),
    ("Laptop", 5000, "Electronics"),
    ("Smartphone", 4000, "Electronics")
]

dd = defaultdict(int)  # default value for int() is 0
for _, price, item_type in items:
    dd[item_type] += price

for item_type, price in dd.items():
    print(f'Total sum for {item_type} items is: {price}')
```

Output:
```python
Total sum for Fruit items is: 8
Total sum for Tool items is: 20
Total sum for Electronics items is: 9000
```
    