# 2.3 Counter

## 2.3.1 Understanding Counter

- **Counter**: The `Counter` class is a dictionary subclass designed to count hashable objects. It's a part of the collections module and is an incredibly useful tool for creating frequency counts of elements in an iterable (e.g. elements in a list or characters in a string).

### Creation

- A `Counter` can be instantiated from an iterable (such a `list` or a `string`) or a mapping (like a `dict`). Hashable objects are keys and their frequencies are values.
    - From a list → counts each element.        
    - From a string → counts characters.
    - From dict or keyword args → explicit frequencies (less common).
    - From a set → initialize all frequencies to 1.

```python
from collections import Counter

print(issubclass(Counter, dict))

# Initialize with a list
letters = ["a", "b", "c", "a", "c", "a", "b", "c"]
letter_counter = Counter(letters)
print("Counter from a list:\t", letter_counter)

# Initialize with a string
string_letter_counter = Counter("banana")
print("Counter from a string:\t", string_letter_counter)

# Provide initial counts of an existing group of objects
dict_letter_counter = Counter({"a": 4, "b": 2, "c": -1})
print("Initialized Counter:\t", dict_letter_counter)
```

Output:
```python
True
Counter from a list:	 Counter({'a': 3, 'c': 3, 'b': 2})
Counter from a string:	 Counter({'a': 3, 'n': 2, 'b': 1})
Initialized Counter:	 Counter({'a': 4, 'b': 2, 'c': -1})
```

### Accessing elements

- Access the elements like any other dictionary, however, if the key does not exists we will get 0.

```python
from collections import Counter

fruits = ["apple", "banana", "cherry", "apple", "cherry"]
fruit_counter = Counter(fruits)

print(fruit_counter["apple"])
print(fruit_counter["pear"])  # Output: 0
```

Output:
```python
2
0
```

### Updating

- `update()` adds the counts to the existing `Counter`, not replaces them.
- Use `subtract()` to remove counts (values can go negative).
- `update()` and `subtract()` modify the original Counter in place.
- We can update counter with:
	- A **string** → each character is counted.
	- A **list** → each element is counted.
	- Another **dictionary** → keys are objects, values are counts.
	- **Keyword arguments** → e.g., update(a=2, b=3).

```python
from collections import Counter

letters = ["a", "b", "c", "a", "c", "a", "b", "c"]
letter_counter = Counter(letters)
print("Original counter:\t\t\t", letter_counter)

# Update Counter with a string or a list
letter_counter.update("aa")
letter_counter.update(["c", "c"])
print("Updated counter with strings and lists:\t", letter_counter)

# Update counts with another dictionary
letter_counter.update({"b": 3})
# Or with keyword arguments
letter_counter.update(a=2, b=2, c=2)
print("Updated counter with dictionaries and kw args:\t", letter_counter)

# You can also subtract counts
letter_counter.subtract(a=7, b=6, c=8)
print("Subtracted counter:\t\t\t", letter_counter)

# You can use .clear() to empty the couner
letter_counter.clear()
print("Reset Counter:\t\t\t\t", letter_counter)
```

Output
```python
Original counter:			 Counter({'a': 3, 'c': 3, 'b': 2})
Updated counter with strings and lists:	 Counter({'a': 5, 'c': 5, 'b': 2})
Updated counter with dictionaries and kw args:	 Counter({'a': 7, 'b': 7, 'c': 7})
Subtracted counter:			 Counter({'b': 1, 'a': 0, 'c': -1})
Reset Counter:				 Counter()
```

### Using `Counter` Operations

- `+` and `-` operators are used to add or subtract counters.
	- It only works with `Counter` instances.
	- The result of the operation is a new `Counter`.
	- `+` operator: Only positive counts are kept (no zeros or negatives).
	- `-` operator: Also returns a new Counter with only positive counts.
- `&` operator: intersection — keeps **minimum** of matching counts from both `Counters`.
- `|` operator: union — keeps **maximum** of counts from either Counter.
- `+c` (unary plus): filters and returns only positive counts.
- `-c` (unary minus): filters and returns only **negative** counts.
- `c1 == c2` equality operator compares two Counters by value.

```python
from collections import Counter

c1 = Counter(a=3, b=1)
c2 = Counter(a=1, b=2)

# Add Counters (keeping only positive counts)
print("Addition:\t\t", c1 + c2)  # add counts
# Subtract Counters (keeping only positive counts)
print("Subtraction:\t\t", c1 - c2)

# Return min of counts
print("Intersection (min):\t", c1 & c2)  # intersection

# Return max of counts
print("Union (max):\t\t", c1 | c2)  # union

# Unary operations (zero is always excluded)
print("Positive counts:\t", +c1)  # Get only counts > 0
print("Negative counts:\t", -Counter(a=1, b=-2))  # Get only counts < 0

# Equality
print("c1 == c2", c1 == c2)
```

Output:
```python
Addition:               Counter({'a': 4, 'b': 3})
Subtraction:            Counter({'a': 2}) # No negative value for b
Intersection (min):     Counter({'a': 1, 'b': 1})
Union (max):            Counter({'a': 3, 'b': 2})
Positive counts:        Counter({'a': 3, 'b': 1})
Negative counts:        Counter({'b': 2})
c1 == c2 False
```

### Using `Counter` Methods

- `.elements ()` returns an iterator over elements repeating each as many times as it count (order is not preserved).
- `.most_common()` returns a list of (`element`,  `count`) pairs sorted from most to least frequent.
	- You can pass an argument `n` to get only the top n elements.
- `.total()` returns the total sum of all counts.

```python
from collections import Counter

c = Counter(a=2, b=3, c=4)

# Reconstructing the original dataset, but without the original order
print("c.elements():\t\t", list(c.elements()))

# Return a list of most common elements (from most to least common)
print("c.most_common():\t", c.most_common())
# Return only the first two most common elements
print("c.most_common(2):\t", c.most_common(2))

# Total of all counts from the Counter
print("c.total():\t\t", c.total())
```

Output:
```python
c.elements():           ['a', 'a', 'b', 'b', 'b', 'c', 'c', 'c', 'c']
c.most_common():        [('c', 4), ('b', 3), ('a', 2)]
c.most_common(2):       [('c', 4), ('b', 3)]
c.total():              9
```

## 2.3.2 Using Counter

### Word Frequency Count in Text

- **Word frequency analysis**: Split text into words and count each word’s occurrences — useful in NLP and data analysis.

```python
from collections import Counter

text = "a quick brown fox jumps over the lazy dog"
words = text.split()
word_counts = Counter(words)

print(word_counts)
```

Output:
```python
Counter({'a': 1, 'quick': 1, 'brown': 1, 'fox': 1, 'jumps': 1, 'over': 1, 'the': 1, 'lazy': 1, 'dog': 1})
```

### Finding Most Common Elements

- **Finding most/least common items**:
    - Use `.most_common()` to get top items.
    - Negative indexing (`c.most_common()[-1]`) to find least common.
        
```python
from collections import Counter

# Visits to web pages
visits = ["home", "about", "contact", "home", "about", "home", "profile", "home", "about", "contact"]
visit_counts = Counter(visits)

most_visited = visit_counts.most_common(2)
least_visited = visit_counts.most_common()[:-3:-1]

print("Most visited pages:", most_visited)
print("Least visited pages:", least_visited)
```

Output:
```python
Most visited pages: [('home', 4), ('about', 3)]
Least visited pages: [('profile', 1), ('contact', 2)]
```

### Counting Items in Inventories

- **Inventory management**:
    - Combine inventories using `+`.
    - Subtract sold items using `-`.

```python
from collections import Counter

# Managing an inventory
inventory_a = Counter(apples=3, oranges=2)
inventory_b = Counter(apples=1, bananas=2, oranges=1)

# Combine inventories
total_inventory = inventory_a + inventory_b
print("Total inventory:\t\t", total_inventory)

# Items sold
sold_items = Counter(apples=2, bananas=1)
remaining_inventory = total_inventory - sold_items
print("Inventory after the sale:\t", remaining_inventory)	
```

Output:
```python
Total inventory:          Counter({'apples': 4, 'oranges': 3, 'bananas': 2})
Inventory after the sale: Counter({'oranges': 3, 'apples': 2, 'bananas': 1})
```

### Analyzing Voting or Poll Results

- **Vote or poll counting**:
    - Collect all votes in a list and count with `Counter`.
    - Use `.most_common(1)` to get the winner.

```python
from collections import Counter

votes = ["CandidateA", "CandidateB", "CandidateB", "CandidateA", "CandidateB", "CandidateB", "CandidateC"]
vote_counts = Counter(votes)

print(vote_counts)
```

Output:
```python
Counter({'CandidateB': 4, 'CandidateA': 2, 'CandidateC': 1})
```

### Implementing Multisets

- **Multiset operations** (mathematics): Multiset, also known as a bag, is a modification of the set concept. Multiset allows multiple instances for each of its elements. The number of instances given for each element is known as multiplicity.
    - Counter behaves like a multiset: elements with multiplicities.
    - Useful for shopping carts, collections, combining/removing quantities.
    
- **Prime factorization**:
    - Store prime factors in a `Counter`, where keys are primes and values are exponents.
    - Reconstruct the original number by multiplying elements from `.elements()`.

```python
from collections import Counter
import math

def prime_factorization(n):
    factors = Counter()
    divisor = 2
    while divisor**2 <= n:
        while n % divisor == 0:
            factors[divisor] += 1
            n //= divisor
        divisor += 1
    if n > 1:
        factors[n] += 1
    return factors

n = 2376
prime_factors = prime_factorization(n)
factors_str = f"{n} = " + " x ".join([f"{factor}^{power}" for factor, power in prime_factors.items()])
print(prime_factors)
print("Prime factorization:", factors_str)

# Calculate the number from prime factors
number = math.prod(prime_factors.elements())
print("Number:", number)
```

Output:
```python
Counter({2: 3, 3: 3, 11: 1})
Prime factorization: 2376 = 2^3 x 3^3 x 11^1
Number: 2376
```