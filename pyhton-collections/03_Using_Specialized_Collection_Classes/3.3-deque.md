# 3.3 deque

## 3.3.1 Understanding deque

- **`deque`** (short for double-ended queue) is a collection type from the `collections` module that is implemented as a doubly linked list. Each element contains a reference to the next and previous element in the list, allowing efficient operations from both ends of the queue.

### Creating a deque

- **Initializing a deque**: A `deque` can be initialized with an iterable like a tuple, list, or even a dictionary view returned from the `items()` method.

```python
from collections import deque

# Create an empty deque
dq = deque()
print(dq)

# Initialize deque with an iterable
dq = deque((1, 2, 3))  # tuple
print(dq)
dq = deque([1, 2, 3])  # list
print(dq)
dict1 = {"a": 1, "b": 2, "c": 3}
dq = deque(dict1.items())  # dictionary view object
print(dq)
```

Output:
```python
deque([])
deque([1, 2, 3])
deque([1, 2, 3])
deque([('a', 1), ('b', 2), ('c', 3)])
```

### Appending and Popping Elements from Both sides

- **Double-ended operations**: Think of a `deque` as a list open from both sides. You can append and pop elements from both the front and back efficiently.

```python
from collections import deque

# Append elements from both sides
dq = deque([1])
dq.append(2)
dq.appendleft(0)
dq.append(3)
print(dq)

# Pop elements from both sides
dq.pop()
popped_el = dq.popleft()
print("Popped element from the left:", popped_el)
print(dq)
```

Output:
```python
deque([0, 1, 2, 3])
Popped element from the left: 0
deque([1, 2])
```

### Performance Advantages and Trade-offs

- **Efficient front operations**: Unlike lists, `deque` operations at the front are O(1) instead of O(n). With lists, removing the first element requires shifting all remaining elements.

```python
import timeit

# Timing for left appending elements in a list O(n)
list_time = timeit.timeit(
    'for i in range(10000): lst.insert(0, i)',
    setup='lst = []',
    number=10
)

# Timing for left appending elements in a deque O(1)
deque_time = timeit.timeit(
    'for i in range(10000): deq.appendleft(i)',
    setup='from collections import deque; deq = deque()',
    number=10
)

print(f"List left-append time: {list_time}")
print(f"Deque left-append time: {deque_time}")
```

Output:
```python
List left-append time: 1.6796967939990282
Deque left-append time: 0.002455080016461127
```

- **Random access trade-off**: `deque` elements are accessed by index in O(n) time, while lists provide O(1) random access since they're implemented as arrays.

```python
from collections import deque

d = deque([0, 1, 2, 3, 4, 5])
lst = [0, 1, 2, 3, 4, 5]

# Accessing by index (slower for deque)
print("Deque[3]:", d[3])  # O(n) - has to traverse
print("List[3]:", lst[3])  # O(1) - direct array access
```

Output:
```python
Deque[3]: 3
List[3]: 3
```

### Accessing, Removing and Inserting `deque` elements

- **Common operations**: `deque` supports most standard list methods like `insert()`, `remove()`, `copy()`, `clear()`, `count()`, `reverse()`, etc.

```python
from collections import deque

numbers = deque([1, 2, 3, 4, 5, 6])

# Accessing the element by index - O(n)
# (slicing is not supported)
print("numbers[5]:", numbers[5])

# Removing an element with del
del numbers[5]

# Inserting an element at the specific position
numbers.insert(1, 10)

# Removing an element with remove()
numbers.remove(5)

print(numbers)
```

Output:
```python
numbers[5]: 6
deque([1, 10, 2, 3, 4])
```

### Creating a Bounded `deque`

- **Maximum length constraint**: The `deque` constructor accepts a `maxlen` argument to create bounded deques with a fixed maximum number of elements.

```python
from collections import deque

numbers = deque([0, 1, 2, 3], maxlen=5)
print("Maxlen:", numbers.maxlen)
print(numbers)

# Allowed, because the original deque has just 4 elements
numbers.appendleft(-1)
print("After numbers.appendleft(-1):\t", numbers)

# This will discard the first number -1
numbers.append(4)
print("After numbers.append(4):\t", numbers)

# This will discard the first number 0
numbers.append(5)
print("After numbers.append(5):\t", numbers)

# This will discard the last number 5
numbers.appendleft(0)
print("After numbers.appendleft(0):\t", numbers)
```

Output:
```python
Maxlen: 5
deque([0, 1, 2, 3], maxlen=5)
After numbers.appendleft(-1):	 deque([-1, 0, 1, 2, 3], maxlen=5)
After numbers.append(4):	         deque([0, 1, 2, 3, 4], maxlen=5)
After numbers.append(5):	         deque([1, 2, 3, 4, 5], maxlen=5)
After numbers.appendleft(0):	 deque([0, 1, 2, 3, 4], maxlen=5)
```

### Using Special deque Methods

- **Rotation operations**: The `rotate()` method moves elements circularly within the deque. When called without arguments, it rotates one step to the right. Positive values rotate to the right, negative values rotate to the left.

- **Extended operations**: The `extend()` method adds multiple elements to the right end, while `extendleft()` adds multiple elements to the left end of the deque.

```python
from collections import deque

letters = deque(["a", "b", "c"])
print(letters)

# Rotate elements one step to the right
letters.rotate()
print("letters.rotate():\t", letters)

# Rotate elements two steps to the right
letters.rotate(2)
print("letters.rotate(2):\t", letters)

# Rotate elements one step to the left
letters.rotate(-1)
print("letters.rotate(-1):\t", letters)

# Add multiple elements to the right
letters.extend(["d", "e"])

# Add multiple elements to the left
letters.extendleft(["x", "y"])

print(letters)
```

Output:
```python
deque(['a', 'b', 'c'])
letters.rotate():	 deque(['c', 'a', 'b'])
letters.rotate(2):	 deque(['a', 'b', 'c'])
letters.rotate(-1):	 deque(['b', 'c', 'a'])
deque(['y', 'x', 'b', 'c', 'a', 'd', 'e'])
```

**Summary**: `deque` works like a list but provides additional methods for efficiently managing elements from both ends of the sequence, making it ideal for queue and stack operations.

## 3.3.2 Using deque

`deque` is really versatile and can be used in various situations. Here are practical use cases that demonstrate the power and flexibility of deques in real-world applications:

### Maintaining a List of Recent Items

- **Automatic data management**: Bounded deques allow you to manage a sequence of most recent inputs because they automatically discard old data. This eliminates the need for manual removal logic that would be required with lists.

```python
from collections import deque

recent_items = deque(maxlen=3)
for i in range(5):
    recent_items.append(i)
    print(f"Item {i} added, recent items: {list(recent_items)}")
```

Output:
```python
Item 0 added, recent items: [0]
Item 1 added, recent items: [0, 1]
Item 2 added, recent items: [0, 1, 2]
Item 3 added, recent items: [1, 2, 3]
Item 4 added, recent items: [2, 3, 4]
```

### Implementing Queues

- **Thread-safe FIFO operations**: Deques are useful for implementing queues and are thread-safe, making them suitable for multi-threaded applications. Queues follow first in, first out (FIFO) order, processing tasks from the left side.

```python
from collections import deque
import time

def process_task(task):
    print("Processing task:", task)
    time.sleep(0.5)  # Simulate time-consuming task processing

task_queue = deque()

# Simulate adding tasks to the queue
for i in range(1, 5):
    task_queue.append(f"task_{i}")

# Process tasks in the queue
while task_queue:
    current_task = task_queue.popleft()
    process_task(current_task)
```

Output:
```python
Processing task: task_1
Processing task: task_2
Processing task: task_3
Processing task: task_4
```

### Implementing Stacks

- **Efficient LIFO operations**: Deques can implement stacks (last in, first out) more efficiently than lists on large datasets, with better memory consumption and thread-safety. They can also set maximum length constraints.

```python
from collections import deque

class BrowserHistory:
    def __init__(self):
        self.pages = deque(maxlen=5)

    def visit_page(self, page_url):
        """Visit a new page and add it to the history."""
        self.pages.append(page_url)
        print("Visiting:", page_url)

    def go_back(self):
        """Go back to the previous page."""
        if self.pages:
            current_page = self.pages.pop()
            print("Going back from:", current_page)
            if self.pages:
                print("Current page is now:", self.pages[-1])
            else:
                print("No more pages in history.")
        else:
            print("No pages in history.")

browser_history = BrowserHistory()
browser_history.visit_page("home.html")
browser_history.visit_page("about.html")
browser_history.visit_page("contact.html")

browser_history.go_back()
browser_history.go_back()
browser_history.go_back()
```

Output:
```python
Visiting: home.html
Visiting: about.html
Visiting: contact.html
Going back from: contact.html
Current page is now: about.html
Going back from: about.html
Current page is now: home.html
Going back from: home.html
No more pages in history.
```

### Rotating Shift Schedule for Employees

- **Circular scheduling**: The `rotate()` method can implement rotating schedules where each employee works different shifts over time.

```python
from collections import deque

# Initial weekly schedule for 3 employees
schedule = deque(["Alice", "Bob", "Charlie"])

# Simulate rotation for 4 weeks
for week in range(1, 5):
    print(f"Week {week} schedule: {list(schedule)}")
    schedule.rotate(1)  # Rotate the schedule
```

Output:
```python
Week 1 schedule: ['Alice', 'Bob', 'Charlie']
Week 2 schedule: ['Charlie', 'Alice', 'Bob']
Week 3 schedule: ['Bob', 'Charlie', 'Alice']
Week 4 schedule: ['Alice', 'Bob', 'Charlie']
```

### Processing Elements from Both Ends

- **Priority handling**: Unlike lists, deques can efficiently process elements from both ends. This is useful for scenarios like restaurant waitlists where VIP customers get priority placement at the front.

```python
from collections import deque

class RestaurantWaitlist:
    def __init__(self):
        self.waitlist = deque()

    def arrive(self, name, vip=False):
        if vip:
            self.waitlist.appendleft(name)
            print(f"VIP customer {name} added to the front of the waitlist.")
        else:
            self.waitlist.append(name)
            print(f"Customer {name} added to the end of the waitlist.")

    def seat_customer(self):
        if self.waitlist:
            name = self.waitlist.popleft()
            print(f"Customer {name} is now being seated.")
        else:
            print("The waitlist is currently empty.")

# Example usage
waitlist = RestaurantWaitlist()
waitlist.arrive("A")
waitlist.arrive("B")
waitlist.arrive("C", vip=True)  # VIP customer
waitlist.arrive("D")

waitlist.seat_customer()  # Seats C first (VIP)
waitlist.seat_customer()  # Then A (FIFO for non-VIPs)
```

Output:
```python
Customer A added to the end of the waitlist.
Customer B added to the end of the waitlist.
VIP customer C added to the front of the waitlist.
Customer D added to the end of the waitlist.
Customer C is now being seated.
Customer A is now being seated.
```

### Implementing a Sliding Window

- **Moving averages and data analysis**: Bounded deques are perfect for implementing sliding windows, such as calculating moving averages over time-series data. The window automatically discards the oldest reading when a new one is appended.

```python
from collections import deque

def moving_average(temperatures, n=5):
    it = iter(temperatures)
    window = deque(maxlen=n)
    for temperature in it:
        window.append(temperature)
        if len(window) == n:
            yield sum(window) / n

# Example temperature data (e.g., hourly readings)
temperatures = [22, 21, 23, 26, 24, 25, 27, 28, 22, 19, 20, 18]
print("5-hour Moving Average:", list(moving_average(temperatures)))
```

Output:
```python
5-hour Moving Average: [23.2, 23.8, 25.0, 26.0, 25.2, 24.4, 23.4, 21.4]
```

**Summary**: Deques excel in scenarios requiring efficient operations at both ends, automatic size management, thread-safe operations, and circular data processing. They provide elegant solutions for queues, stacks, recent item tracking, scheduling systems, priority-based processing, and sliding window algorithms.


