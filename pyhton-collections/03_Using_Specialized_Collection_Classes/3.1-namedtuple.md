# 3.1 namedtuple

## 3.1.1 Understanding namedtuple

- A `namedtuple` is a specialized collection type from Python's **`collections`** module. It's a **factory function**, meaning it's a function that returns a new class. This new class is a subclass of Python's built-in `tuple`, but with added features that allow you to access elements by name, not just by index.

### Creating and Using a `namedtuple`

- To create a `namedtuple`, you first import it: `from collections import namedtuple`. Then, you call the function with two main arguments:
	1. A **string for the new class name** (e.g., `'Pixel'`).
	2. The **field names** for the elements.

```python
from collections import namedtuple

# Create the namedtuple class
Pixel = namedtuple('Pixel', 'red green blue')

print(Pixel.__name__)
print(issubclass(Pixel, tuple))
```

Output
```python
Pixel
True
```

- **Class vs Alias**:
    - The variable you assign the class to is just an **alias**.
    - The actual class name remains what was passed as the first argument.

```python
# This is just an alias for the same class object
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

Point2 = Point # Point2 is just an alias for the Point class
print(Point2.__name__)
```

Output:
```python
Point
```

- The key advantage of a `namedtuple` is accessing data. While you can still use numeric indices like a regular tuple (`p1[0]`)
- You can also use **dot notation** with the field names (`p1.red`), which makes the code much more readable and less error-prone.

> [!INFO] It's best practice to assign the returned class to a variable with the **same name** as the class name you provided to avoid confusion.

- The field names can be provided in several ways:
	- A single string with spaces or commas separating the names (e.g., `'red green blue'`)
	- A list of strings (`['red', 'green', 'blue']`)
	- Or even a generator expression for dynamic creation.

```python
from collections import namedtuple

# Creating a new tuple subclass (namedtuple class)
Pixel = namedtuple("Pixel", "red green blue")
# Pixel = namedtuple("Pixel", "red, green, blue")
# Pixel = namedtuple("Pixel", ["red", "green", "blue"])
# Pixel = namedtuple("Pixel", (field for field in ["red", "green", "blue"]))

# Using a namedtuple class to instantiate a new namedtuple object
# pixel = Pixel(255, 0, 0)
pixel = Pixel(red=255, green=50, blue=0)
print(pixel)

# Get a tuple of field names
print(Pixel._fields)
```

Output:
```python
Pixel(red=255, green=50, blue=0)
('red', 'green', 'blue')
```

      
- Access values:
	- By index (like a tuple)
	- Or by field name (more readable).

```python
from collections import namedtuple

Pixel = namedtuple("Pixel", "red green blue")
pixel = Pixel(red=255, green=50, blue=0)

print("Accessing values by indices:")
print(pixel[0])
print(pixel[1])
print(pixel[2])

print("Accessing values by field names with the dot syntax:")
print(pixel.red)
print(pixel.green)
print(pixel.blue)
```

Output:
```python
Accessing values by indices:
255
50
0
Accessing values by field names with the dot syntax:
255
50
0
```

### Optional Arguments and Methods

- The `namedtuple` function has several helpful optional arguments:
	- **`rename=True`**: Automatically renames any invalid field names (e.g., duplicates, Python keywords, names with underscores) to valid ones.  
	- **`defaults`**: An iterable of default values for the **rightmost** fields, making them optional when creating an instance.
	- **`module`**: Sets the `__module__` attribute of the class, which can be useful for debugging and serialization.

```python
from collections import namedtuple

# The 'rename' argument
# username is duplicated, _ is not allowed, as is a keyword
user_fields = ["username", "_password", "username", "as"]
User = namedtuple("User", user_fields, rename=True)
print("The 'rename' argument")
print("User._fields:", User._fields)

# The 'defaults' argument
Dog = namedtuple("Dog", ["name", "age", "location"], defaults=[0, "Home"])
dog = Dog("Balto")
print("\nThe 'defaults' argument")
print("dog:", dog)
print("dog._field_defaults:", dog._field_defaults)

# The 'module' argument
Item = namedtuple("Item", ["name"], module="my_module")
print("\nThe 'module' argument")
print("Item.__module__:", Item.__module__)  # without the 'module' argument, this would return '__main__'
```

Output:
```python
The 'rename' argument
User._fields: ('username', '_1', '_2', '_3')

The 'defaults' argument
dog: Dog(name='Balto', age=0, location='Home')
dog._field_defaults: {'age': 0, 'location': 'Home'}

The 'module' argument
Item.__module__: my_module
```

- `namedtuple` also comes with useful methods:
	- **`_make(iterable)`**: A class method to create a new instance from an iterable (like a list or tuple). This is useful for bulk conversions.

	```python
	from collections import namedtuple
	
	Pixel = namedtuple("Pixel", "red green blue")
	
	image_pixel_data = [
	    [255, 43, 22],
	    [230, 44, 23],
	    [230, 44, 23]
	]
	
	sprite = [Pixel._make(pixel) for pixel in image_pixel_data]
	print(sprite)
	```
	
	Output:
	```Python
	[Pixel(red=255, green=43, blue=22), Pixel(red=230, green=44, blue=23), Pixel(red=230, green=44, blue=23)]
	```

	- **`_asdict()`**: An instance method that converts the `namedtuple` into a dictionary, mapping field names to their values.

	```python
	from collections import namedtuple
	
	Pixel = namedtuple("Pixel", "red green blue")
	
	# Use dictionary unpacking to unpack key-value pairs to keyword arguments
	pixel = Pixel(**{"red": 255, "green": 50, "blue": 0})
	print(pixel)
	
	# Turn the namedtuple instance to a dictionary
	print(pixel._asdict())
	```
	
	Output:
	```python
	Pixel(red=255, green=50, blue=0)
	{'red': 255, 'green': 50, 'blue': 0}
	```

    - **`_replace(**kwargs)`**: Since tuples are **immutable**, you can't change their values. The `_replace()` method returns a **new** `namedtuple` instance with specified fields updated to new values, leaving the original instance untouched.
	    - The key thing in the example is that we are assigning the new tuple to the same `dog` variable.

	```python
	from collections import namedtuple
	
	Dog = namedtuple("Dog", ["name", "age", "location"])
	dog = Dog("Hachiko", 11, "Shibuya Station")
	
	# Create a new Dog instance with the updated value
	dog = dog._replace(name="Scooby-Don't")
	print(dog)
	```
	
	Output:
	```Python
	Dog(name="Scooby-Don't", age=11, location='Shibuya Station')
	```

## 3.1.2 Using namedtuple

### Immutable Container with Named Fields

- **Substituting regular tuples for better readability**
    - Namedtuples allow dot notation instead of index access.
    - This makes the code more readable and self-explanatory.
    
- **More memory-efficient alternative to dictionaries and data classes**
    - Namedtuples are immutable and lightweight.
    - They donâ€™t use dictionaries internally, unlike dict or dataclasses.
    - Data classes offer more flexibility (methods, docstrings) but consume more memory.
    
- **Representing structured records clearly**
    - Useful for collections of similar structured data, such as a list of cities.
    - Improves readability by avoiding numeric indices or key-based access.

```python
from collections import namedtuple

City = namedtuple("City", ["name", "latitude", "longitude"])

cities = [
    City("New York", 40.7128, -74.0060),
    City("Los Angeles", 34.0522, -118.2437),
    City("Chicago", 41.8781, -87.6298),
]

def find_city_by_name(city_name):
    for city in cities:
        if city.name == city_name:
            return city
    return None

found_city = find_city_by_name("Chicago")
if found_city:
    print(f"The coordinates of {found_city.name} are ({found_city.latitude}, {found_city.longitude})")
else:
    print("City not found")
```

Output:
```python
The coordinates of Chicago are (41.8781, -87.6298)
```

- **Subclassing NamedTuple from the typing module**
    - Enables class-style syntax with fields, type hints, docstrings, and methods.
    - Provides the benefits of namedtuple while allowing more customization.

```python
from typing import NamedTuple

class City(NamedTuple):
    """
    Represents a city with a name and its geographic coordinates.

    Attributes:
        name (str): The name of the city.
        latitude (float): The latitude of the city.
        longitude (float): The longitude of the city.
    """
    name: str
    latitude: float
    longitude: float

    def __str__(self):
        return f"The city of {self.name} can be found at ({self.latitude}, {self.longitude}) coordinates."

city = City("New York", 40.7128, -74.0060)
print(city)
```

Output:
```python
The city of New York can be found at (40.7128, -74.006) coordinates.
```

### Working with Functions

- **Passing grouped data to functions**
    - Replaces multiple separate parameters with a single grouped namedtuple.
    - Improves maintainability and clarity of function signatures.

```python
from collections import namedtuple

# Define the CustomerInfo namedtuple
CustomerInfo = namedtuple("CustomerInfo", [
    "id", "first_name", "last_name", "email", "address",
    "city", "state", "zip_code"
])

# Use the CustomerInfo namedtuple instead of many separate parameters
def process_customer_info(customer_info):
    print(f"Processing {customer_info.first_name} {customer_info.last_name} living in {customer_info.city}, {customer_info.state}.")

# Create a namedtuple instance
customer = CustomerInfo(
    1, "X", "Y", "x.y@example.com", "123 Elm St", "Anytown", "Anystate", "12345"
)

# Call the function with a single grouped argument
process_customer_info(customer)
```

Output:
```Python
Processing X Y living in Anytown, Anystate.
```
    
- **Returning multiple values from functions**
    - Offers named access to returned values instead of unpacking a plain tuple.
    - Improves code clarity when handling function results.

```Python
from collections import namedtuple

# Define the FinancialStats namedtuple
FinancialStats = namedtuple("FinancialStats", ["average_expense", "total_expense", "highest_expense"])

def calculate_financial_stats(expenses):
    total_expense = sum(expenses)
    average_expense = total_expense / len(expenses)
    highest_expense = max(expenses)
    return FinancialStats(average_expense, total_expense, highest_expense)

# Usage
expenses = [250, 320, 150, 400, 500]
stats = calculate_financial_stats(expenses)

print(f"Average Expense: ${stats.average_expense:.2f}")
print(f"Total Expense: ${stats.total_expense}")
print(f"Highest Expense: ${stats.highest_expense}")
```

Output:
```Python
Average Expense: $324.00
Total Expense: $1620
Highest Expense: $500
```
