# 3.2 ChainMap

## 3.2.1 Understanding ChainMap

- **`ChainMap`** is a class from the `collections` module in Python. It is a dictionary-like class for creating a single view of multiple mappings. It essentially combines several dictionaries into one view, allowing you to access and manipulate them as a single unit.

### Creating and Using a `ChainMap`

- **Creating a ChainMap**: To create a `ChainMap`, import it from the `collections` module and pass multiple dictionaries as arguments. `ChainMap` stores references to these dictionaries in an internal list rather than merging them.

```python
from collections import ChainMap

# Create two dictionaries
dict1 = {'a': 1, 'b': 2}
dict2 = {'b': 3, 'c': 4, 'd': 5}

# Chain them together
chain = ChainMap(dict1, dict2)
print(chain)
```

Output:
```python
ChainMap({'a': 1, 'b': 2}, {'b': 3, 'c': 4, 'd': 5})
```

- **Accessing elements**: Use the same square bracket syntax as dictionaries or the `get()` method. `ChainMap` searches for keys starting from the first dictionary, giving precedence to earlier mappings.

```python
from collections import ChainMap

dict1 = {'a': 1, 'b': 2}
dict2 = {'b': 3, 'c': 4, 'd': 5}
chain = ChainMap(dict1, dict2)

print(chain['a'])  # From dict1: 1
print(chain['b'])  # From dict1 (precedence): 2
print(chain['c'])  # From dict2: 4
print(chain.get('x', 'Not found'))  # Default value: Not found
```

Output:
```python
1
2
4
Not found
```

- **Modifying elements**: All modifications (assignment, deletion) only affect the first dictionary in the chain, even if the key exists in other dictionaries.

```python
from collections import ChainMap

dict1 = {'a': 1, 'b': 2}
dict2 = {'b': 3, 'c': 4, 'd': 5}
chain = ChainMap(dict1, dict2)

# Update existing keys in first dict
chain['a'] = 10
chain['b'] = 20

# Add new key (goes to first dict even if it exists elsewhere)
chain['c'] = 30

print("dict1:", dict1)
print("dict2:", dict2)
print("chain:", chain)
```

Output:
```python
dict1: {'a': 10, 'b': 20, 'c': 30}
dict2: {'b': 3, 'c': 4, 'd': 5}
chain: ChainMap({'a': 10, 'b': 20, 'c': 30}, {'b': 3, 'c': 4, 'd': 5})
```


### Optional Methods

- **Managing the chain**: Use `new_child()` to add a new mapping at the front, or `parents` to get a `ChainMap` without the first mapping.

```python
from collections import ChainMap

dict1 = {'a': 1, 'b': 2}
dict2 = {'c': 3, 'd': 4}
chain = ChainMap(dict1, dict2)

# Add new mapping at the front
new_dict = {'x': 100}
new_chain = chain.new_child(new_dict)
print("New chain:", new_chain)

# Get chain without first mapping
parents_chain = new_chain.parents
print("Parents:", parents_chain)
```

Output:
```python
New chain: ChainMap({'x': 100}, {'a': 1, 'b': 2}, {'c': 3, 'd': 4})
Parents: ChainMap({'a': 1, 'b': 2}, {'c': 3, 'd': 4})
```

- **Accessing internal mappings**: Use the `maps` attribute to access the internal list of dictionaries. This list can be modified directly.

```python
from collections import ChainMap

dict1 = {'a': 1, 'b': 2}
dict2 = {'c': 3, 'd': 4}
chain = ChainMap(dict1, dict2)

print("Internal maps:", chain.maps)

# Reverse the order
chain.maps.reverse()
print("After reverse:", chain.maps)
print("Chain after reverse:", chain)

# Remove last mapping
chain.maps.pop()
print("After pop:", chain)
```

Output:
```python
Internal maps: [{'a': 1, 'b': 2}, {'c': 3, 'd': 4}]
After reverse: [{'c': 3, 'd': 4}, {'a': 1, 'b': 2}]
Chain after reverse: ChainMap({'c': 3, 'd': 4}, {'a': 1, 'b': 2})
After pop: ChainMap({'c': 3, 'd': 4})
```

- **Iteration**: Use standard dictionary methods (`items()`, `keys()`, `values()`). Iteration follows a specific order: it scans mappings from last to first, giving precedence to keys from the first mapping.

```python
from collections import ChainMap

dict1 = {"a": 1, "b": 2}
dict2 = {"b": 3, "c": 4, "d": 5}
chain_map = ChainMap(dict1, dict2)

# The iteration is determined by scanning the mappings last to first
for key, value in chain_map.items():
    print(key, value)

# The same order applies to .keys() and .values()
```

Output:
```python
b 2
c 4
d 5
a 1
```

## 3.2.2 Understanding ChainMap

`ChainMap` can generally be used as a fallback mechanism. The `ConfigParser` class from Python actually utilizes `ChainMap` to manage configuration scopes. Here are practical use cases that demonstrate the main features of `ChainMap`:

### Application Configuration

- **Managing configuration settings**: When building software, you need to manage configuration settings with a clear hierarchy where user configurations have the highest priority, followed by environment variables, and finally default settings as fallback.

```python
from collections import ChainMap
import os

# Default configuration
default_config = {"theme": "Default", "language": "English", "show_ads": True}

# Environment variables can override default settings
env_config = os.environ

# Chain them
app_config = ChainMap(env_config, default_config)

# Access the theme setting
print("Theme:", app_config["theme"])

# User input has the highest priority, followed by environment variables, then defaults
user_config = {"theme": "Dark Mode", "show_ads": False}
app_config = app_config.new_child(user_config)

print("\nAfter adding the user config")
print("Theme:", app_config["theme"])
print("Language:", app_config["language"])
print("Show Ads:", app_config["show_ads"])
```

Output:
```python
Theme: Default

After adding the user config
Theme: Dark Mode
Language: English
Show Ads: False
```

- **Scope resolution**: The theme and show_ads settings are read from the user config, while language falls back to default because the user didn't define it. This kind of scope resolution is one of the main features of `ChainMap`.

### Context in Command Line Applications

- **Working with command-line arguments**: `ChainMap` provides elegant fallback from command-line arguments to default values, allowing you to handle optional arguments gracefully.

```python
import argparse
from collections import ChainMap

def main():
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="CLI tool example with ChainMap")
    parser.add_argument("--output", type=str, help="Output file name")
    parser.add_argument("--verbose", action="store_true", help="Enable verbose mode")
    parser.add_argument("--mode", type=str, help="Set the mode of operation")

    # Simulate command-line arguments for demonstration
    args = parser.parse_args(["--output", "output_from_cli.log", "--verbose"])

    # Default settings for my CLI tool
    default_settings = {
        "output": "default.log",
        "verbose": False,
        "mode": "normal"
    }

    # Convert args namespace to a dictionary and remove keys with None values
    cli_arguments = {k: v for k, v in vars(args).items() if v is not None}

    # Using ChainMap to prioritize CLI arguments over default settings
    settings = ChainMap(cli_arguments, default_settings)

    # Print settings to demonstrate which ones are applied
    print("Output file:", settings["output"])
    print("Verbose mode:", "enabled" if settings["verbose"] else "disabled")
    print("Mode:", settings["mode"])

main()
```

Output:
```python
Output file: output_from_cli.log  
Verbose mode: enabled  
Mode: normal
```

- **Argument precedence**: The output and verbose were configured by the command-line arguments because they have precedence in the `ChainMap`. Since the mode argument wasn't provided, this setting falls back to the default configuration.

### Scope Resolution in Interpreters

- **Implementing variable scopes**: When building a programming language, you need to manage scopes where local scope has precedence over global scope inside functions. `ChainMap` naturally handles this scope resolution.

```python
from collections import ChainMap

global_scope = {"x": 2, "y": 3}
local_scope = {"y": 5}

# The current environment, where local scope has precedence
current_env = ChainMap(local_scope, global_scope)

# Resolving variables
print("x:", current_env["x"])  # Uses global_scope
print("y:", current_env["y"])  # Local scope overrides global

# Adding new variable to the global scope
current_env.parents["z"] = 100
print("z:", current_env["z"])  # Uses global_scope

print(current_env)
```

Output:
```python
x: 2
y: 5
z: 100
ChainMap({'y': 5}, {'x': 2, 'y': 3, 'z': 100})
```

- **Adding to specific scopes**: `ChainMap` only allows you to add new keys to the first mapping. To add variables to the global scope when local scope is first in the chain, use the `parents` attribute as an easier workaround.

**Summary**: `ChainMap` is ideal for managing multiple scopes where each scope has its own values for the same set of settings, providing automatic fallback mechanisms and priority-based resolution.
