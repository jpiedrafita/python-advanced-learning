
# 4.1 UserStrings

## 4.1.1 Understanding and Using UserStrings

- **`UserString`** is a wrapper around the built-in `str` class from the `collections` module. It was originally designed to allow developers to subclass Python's built-in string type before Python 2.2, when direct subclassing of built-in types wasn't possible.

### Purpose and Limitations

- **Historical context**: Since Python 2.2, it's possible to directly subclass built-in types (which are mostly implemented in C), making `UserString` largely obsolete for most use cases.

- **Performance considerations**: `UserString` instances are usually slower than real strings because the `UserString` class is implemented in Python, while built-in strings are implemented in C.

- **Data storage**: `UserString` stores all its contents inside the `data` attribute, which is an actual string instance, simulating all string functionality.

### Extending Standard String Features

- **Adding new methods**: Both `UserString` and `str` can be extended with additional methods. The main difference is accessing the string content via `self.data` for `UserString` vs direct access for `str`.

```python
from collections import UserString

class PalindromeString(UserString):
    def is_palindrome(self):
        cleaned = ''.join(filter(str.isalnum, self.data.lower()))
        return cleaned == cleaned[::-1]

class StrPalindromeString(str):
    def is_palindrome(self):
        cleaned = ''.join(filter(str.isalnum, self.lower()))
        return cleaned == cleaned[::-1]

str1 = PalindromeString("A man, a plan, a canal, Panama")
str2 = StrPalindromeString("A man, a plan, a canal, Panama")

print(str1.is_palindrome())
print(str2.is_palindrome())
```

Output:
```python
True
True
```

### Modifying Standard String Features

- **Overriding built-in methods**: You can modify core functionality like comparison operators. Both `UserString` and `str` can implement the same modifications with nearly identical code.

```python
from collections import UserString

# Make the comparison operators case-insensitive
class CIString(UserString):
    def __eq__(self, other):
        return self.data.lower() == other.lower()

    def __lt__(self, other):
        return self.data.lower() < other.lower()

    def __gt__(self, other):
        return self.data.lower() > other.lower()

# Same functionality can be achieved with str class
# by replacing self.data.lower() with self.lower()

str1 = CIString("ABCD")
str2 = "abCD"
str3 = "Abcd"

print(str1 == str2)  # Case-insensitive comparison
print(str1 > str3)   # Case-insensitive comparison
```

Output:
```python
True
False
```

### Key Difference: Initialization Behavior

- **Mutable-like initialization**: The main advantage of `UserString` is in scenarios where you need to modify the string content during initialization, which isn't possible with immutable built-in strings.

```python
from collections import UserString
from urllib.parse import quote_plus

class URLEncodedString(UserString):
    def __init__(self, string):
        encoded = quote_plus(string)
        super().__init__(encoded)

# User's search query
book_title = "Moby-Dick; or, The Whale"

# Creating an instance of URLEncodedString with the book title
encoded_title = URLEncodedString(book_title)

# Example of how the encoded string can be used in a URL
search_url = f"https://example.com/search?q={encoded_title}"
print(search_url)
```

Output:
```python
https://example.com/search?q=Moby-Dick%3B+or%2C+The+Whale
```

- **Built-in string limitation**: The same implementation fails with the built-in `str` class because strings are immutable and cannot be modified during `__init__()`.

```python
from urllib.parse import quote_plus

class URLEncodedString(str):
    def __init__(self, string):
        encoded = quote_plus(string)
        super().__init__(encoded)  # This will fail

# This raises: TypeError: object.__init__() takes exactly one argument
```

- **Why it fails**: Built-in strings are immutable. The `__init__()` method cannot change the string content after memory allocation. To achieve the same functionality with `str`, you would need to override the `__new__()` method instead.

### When to Use UserString

- **Limited use cases**: The usage of `UserString` is very limited in modern Python development.

- **Consider UserString when**:
  - You need to modify string content during initialization
  - You're implementing something like mutable strings
  - You're working with legacy code that requires `UserString`

- **Prefer built-in str when**:
  - You only need to extend functionality (add new methods)
  - You only need to modify existing methods without initialization changes
  - Performance is a concern

**Summary**: `UserString` provides a Python-implemented wrapper around strings that allows for easier subclassing in specific scenarios, particularly when initialization-time modifications are needed. However, for most use cases, directly subclassing the built-in `str` class is preferred due to better performance.