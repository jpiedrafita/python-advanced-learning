# 1.3 Dictionaries

## 1.3.1 Understanding Dictionary Basics

- Used for storing data in key-value pairs.
- Dynamic.
- Mutable.
- Random access by keys (associative array, key-value pairs)
- Ordered.
- Can be passed to the `len()` function.
- Keys are unique.

| **Feature / Operation** | **Description**                                            | **Example**                                 |
| ----------------------- | ---------------------------------------------------------- | ------------------------------------------- |
| Access value            | Returns value by key, raises `KeyError` if not found      | `dict["name"]`                              |
| Safe access             | Returns value if key exists, else default                 | `dict.get("name", "Not found")`             |
| Add / Update single     | Adds new key or updates existing key                      | `dict["lang"] = "Python"`                   |
| Add / Update multiple   | Adds multiple key–value pairs                             | `dict.update({"lang": "Python", "ver": 3})` |
| Merge dictionaries      | Combines dictionaries; right-hand values take precedence  | `d1 \| d2` _(Python ≥ 3.9)_                 |
| Remove by key           | Deletes element, raises if missing                        | `del dict["lang"]`                          |
| Remove & return         | Deletes element and returns its value                     | `dict.pop("lang", "Default")`               |
| Remove last pair        | Removes and returns last inserted key–value pair          | `dict.popitem()`                            |
| Clear dictionary        | Removes all elements                                      | `dict.clear()`                              |
| Iterate keys & values   | Loops over key–value pairs                                | `for k, v in dict.items(): ...`             |
| Iterate keys only       | Loops over keys                                           | `for k in dict.keys(): ...`                 |
| Iterate values only     | Loops over values                                         | `for v in dict.values(): ...`               |
| Check existence         | Returns `True` if key exists                              | `"version" in dict`                         |     |
> [!NOTE] **Accessing Elements in a Dictionary**
> 
> Accessing elements in a dictionary is done using keys. This is a fundamental operation because it allows you to retrieve the value associated with a specific key. It’s efficient and fast, making dictionaries an optimal choice for datasets where quick lookup of information is important. Python will throw an exception if you try to use the key that is not in the dictionary.
## 1.3.2 More on Dictionaries

| **Feature / Operation**  | **Description**                                           | **Example**                                   |
| ------------------------ | --------------------------------------------------------- | --------------------------------------------- |
| Dictionary comprehension | Create/transform dictionaries with `{}` syntax            | `{x: x**2 for x in range(6)}`                 |
| Shallow copy (`copy()`)  | Copies immutables, references mutables                    | `d2 = d1.copy()`                              |
| Deep copy (`deepcopy()`) | Fully copies nested mutable objects                       | `d2 = deepcopy(d1)`                           |
| `setdefault()`           | Returns value if key exists; else creates it with default | `d.setdefault('c', 99)`                       |
| Sort by keys             | Uses `sorted(dict.items())`                               | `dict(sorted(d.items()))`                     |
| Sort by values           | Use lambda or `itemgetter(1)` with key parameter          | `dict(sorted(d.items(), key=lambda x: x[1]))` |
| Dictionary view          | Reference to keys/values/items without copying            | `dict_items([...])`                           |

## 1.3.3 Using Dictionaries

### Configuration Settings

- **Configuration storage**: Dictionaries can be used in an application that needs to load and access configuration settings, where these settings are not complex enough to require a database. In that case, dictionaries provide simplicity of implementation, immediate fast in-memory access to configuration values and portability.

```python
# Loading and accessing configuration settings using a dictionary
config = {
    "debug_mode": True,
    "api_endpoint": "https://api.example.com",
    "retry_attempts": 3,
    "themes": ["light", "dark"]
}

# Accessing a configuration setting
debug_mode = config["debug_mode"]
print(f"Debug Mode: {debug_mode}")

# Modifying a configuration setting
config["retry_attempts"] = 5
print(f"Retry Attempts: {config['retry_attempts']}")
```

### Function Dispatch Tables

- **Function dispatch tables**: Mapping strings or identifiers to functions within a codebase to dynamically call different functions based on input, commonly used in command parsers, APIs, or state machines. Dictionaries here provide flexibility and readability.

```python
import os
import platform

def list_files(directory='.'):
    """Lists files in the given directory."""
    files = [f for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f))]
    for file in files:
        print(file)

def count_files(directory='.'):
    """Counts the number of files in the given directory."""
    files = [f for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f))]
    print(f"Number of files: {len(files)}")

def sys_info():
    """Displays basic system information."""
    print(f"System: {platform.system()}")
    print(f"Version: {platform.version()}")

# Dispatch Table
commands = {
    "list_files": list_files,
    "count_files": count_files,
    "sys_info": sys_info,
}

user_command = input("Enter command (list_files, count_files, sys_info): ").strip()
directory = '.'  # Assume current directory

# Dispatching the command
if user_command in commands:
    if user_command in ["list_files", "count_files"]:
        commands[user_command](directory)
    else:
        commands[user_command]()
else:
    print("Unknown command.")
```

### Memoization

- **Memoization**: Optimizing expensive, repetitive function calls by caching the results of those calls based on their input parameters. While there are caching libraries and tools available, for lightweight or specific functions within a larger application, a simple dictionary-based memoization is often the most efficient approach.

```python
# Using a dictionary to memoize a simple Fibonacci function
def fibonacci(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 2:
        return 1
    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)
    return memo[n]

print(fibonacci(10))
```

### Plugin or Module Registry

- **Plugin/module tracking**: An application that supports plugins or modules might use a dictionary to keep track of available plugins and their metadata. Dictionaries provide dynamic registration, direct mapping, and decentralization.

```python
# Registering and invoking plugins through a dictionary-based registry
plugins = {}

def register_plugin(name, func):
    plugins[name] = func

def call_plugin(name):
    if name in plugins:
        plugins[name]()

# Example plugin functions
def plugin_greet():
    print("Hello from the plugin!")

# Registering the plugin
register_plugin("greeting_plugin", plugin_greet)

# Calling the registered plugin
call_plugin("greeting_plugin")
```

### Counting and Grouping Items (aka Frequency Tables)

- **Counting and grouping (frequency tables)**: Counting occurrences of items or grouping items by a certain attribute. Dictionaries facilitate this pattern efficiently through keys representing the items or attributes and values representing counts or groups.

```python
# Simulating log data as a list of dictionaries
log_data = [
    {"ip": "192.168.1.1", "url": "/index.html", "status": "200"},
    {"ip": "192.168.1.2", "url": "/about.html", "status": "200"},
    {"ip": "192.168.1.1", "url": "/contact.html", "status": "200"},
    {"ip": "192.168.1.3", "url": "/index.html", "status": "200"},
    {"ip": "192.168.1.2", "url": "/products.html", "status": "200"},
    {"ip": "192.168.1.1", "url": "/products.html", "status": "404"},
]

# Dictionary to hold request counts per IP address
request_counts = {}

# Process log entries to count requests per IP address
for log_entry in log_data:
    ip_address = log_entry["ip"]
    request_counts[ip_address] = request_counts.get(ip_address, 0) + 1

# Display counts
for ip, count in request_counts.items():
    print(f"IP Address {ip} made {count} requests")
```

### Using Dictionaries with Functions

- **Keyword arguments (**kwargs)**: A function can have a parameter preceded by `**`. The `**kwargs` is known as a keyword parameter.

```python
def html_tag(tag, content, **kwargs):
    """
    Returns a string representation of an HTML tag.
    
    :param tag: The HTML tag name.
    :param content: The content inside the tag.
    :param kwargs: Optional HTML attributes for the tag.
    """
    print("kwargs:", kwargs)  # Debug: show received attributes
    attributes = ' '.join([f'{key}="{value}"' for key, value in kwargs.items()])
    return f'<{tag} {attributes}>{content}</{tag}>'

# Example usage
print(html_tag('a', 'Click Here', href="https://example.com", style="color: red;"))
```