# 1.5 Sets

## 1.5.1 Understanding Sets

- Used for storing a collection of unique elements.
- Dynamic.
- Elements cannot be mutable.
- Unordered.
- Elements are unique.
- Can be passed to `len()`.

| **Concept**              | **Description**                                                                                                                                                                | **Example code**                                            |
| ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------- |
| **Definition**           | Stores unique elements only, automatically removing duplicates. Dynamic in size.                                                                                               | `my_set = {1, 2, 3}`                                        |
| **Order**                | No guaranteed order; cannot index or slice.                                                                                                                                    | —                                                           |
| **Immutable elements**   | Can only store immutable objects (e.g., no lists or dicts).                                                                                                                    | `my_set = {(1, 2), 3}`                                      |
| **Creation**             | Use `{}` for initialization or `set()` constructor. Can convert from iterables.                                                                                                | `set([1, 2, 2, 3])` → `{1, 2, 3}`                           |
| **Access**               | Only via looping; no direct index access.                                                                                                                                      | `for item in my_set: print(item)`                           |
| **Membership testing**   | Fast O(1) lookup with `in`.                                                                                                                                                    | `3 in my_set`                                               |
| **Add / Remove**         | `.add()` to insert, `.remove()` to delete (error if not found), `.discard()` to delete without error.                                                                          | `my_set.add(4)`                                             |
| **Set operations**       | Union (`\|`), intersection (`&`), difference (`-`), symmetric difference (`^`). Methods available too: `union()`, `intersection()`, `difference()`, `symetric_difference()`. . | `setA \| setB`, `setA & setB`, `setA - setB`, `setA ^ setB` |
| **Augmented assignment** | Operators with `=` modify the original set instead of returning a new one.                                                                                                     | `setA \|= setB`                                             |
| **Subset / Superset**    | `.issubset()` or `<=`, `.issuperset()` or `>=`.                                                                                                                                | `A <= B`                                                    |
| **Disjoint**             | `.isdisjoint()` returns `True` if no common elements.                                                                                                                          | `A.isdisjoint(C)`                                           |
| **Frozen sets**          | Immutable sets created with `frozenset()`. Can be added to other sets.                                                                                                         | `fs = frozenset([1, 2])`                                    |

## 1.5.2 Using Sets

### Removing Duplicates from a Sequence

- **Removing duplicates**: Use sets to quickly eliminate duplicate elements from a sequence, ensuring uniqueness for further processing.

```python
# Simulated raw data: a list of hashtags from various posts, including duplicates
raw_hashtags = ['#python', '#dev', '#python', '#coding', '#tech', '#dev', '#coding', '#tech', '#pluralsight']

# Removing duplicates by converting the list to a set
unique_hashtags = set(raw_hashtags)
print(unique_hashtags)
```

### Performing Set Operations

- **Fast membership testing**: Sets allow much faster membership checks compared to lists, making them ideal for large datasets.

```python
import timeit

# Simulating 1 million users
user_ids = list(range(1, 1000001))
# User ID to test for membership
test_id = 999999

user_ids_set = set(user_ids)

# Membership testing function for the list
def check_list():
    return test_id in user_ids

# Membership testing function for the set
def check_set():
    return test_id in user_ids_set

list_time = timeit.timeit(check_list, number=100)
set_time = timeit.timeit(check_set, number=100)

print(f"List membership test time: {list_time:.5f} seconds")
print(f"Set membership test time: {set_time:.5f} seconds")
```

```bash
List membership test time: 0.69642 seconds
Set membership test time: 0.00001 seconds
```

- **Set operations for analysis**: Use built-in set operations like intersection and difference to efficiently compare groups and find common or unique elements.

```python
# Analyzing results of a survey

# Interests from two different age groups
interests_group1 = {"reading", "traveling", "cooking", "gardening"}
interests_group2 = {"traveling", "music", "video games", "cooking"}

# Finding common interests
common_interests = interests_group1.intersection(interests_group2)
print(f"Common interests: {common_interests}")

# Unique interests in group1
unique_group1 = interests_group1.difference(interests_group2)
print(f"Unique to Group 1: {unique_group1}")

# Unique interests in group2
unique_group2 = interests_group2.difference(interests_group1)
print(f"Unique to Group 2: {unique_group2}")
```