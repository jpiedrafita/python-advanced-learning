# 1.4 Tuples

## 1.4.1 Understanding Tuples

- Used for storing objects in a sequence.
- Fixed number of elements.
- Immutable.
- Random access by an index.
- Ordered.
- Memory efficient.
- Also supports slicing like lists.
- Can be passed to `len()`.

| **Feature / Operation** | **Description**                                | **Example**                       |
| ----------------------- | ---------------------------------------------- | --------------------------------- |
| Creating empty tuple    | Use `()`                                       | `()`                              |
| Tuple with elements     | Separate values by commas, can mix types       | `(1, "a", 3.14)`                  |
| Single element tuple    | Needs a trailing comma to be tuple             | `("one",)`                        |
| Without parentheses     | Parentheses optional in some cases             | `1, 2, 3`                         |
| Access elements         | Use indices, supports negatives                | `my_tuple[0]`, `my_tuple[-1]`     |
| Immutable               | Cannot change, add, or remove elements         | `my_tuple[0] = 5` → `TypeError`   |
| Methods                 | `count()` and `index()` work like in lists    | `t.count(1)`                      |
| Packing                 | Put multiple values into a tuple               | `t = 1, 2, 3`                     |
| Unpacking               | Assign tuple values to variables               | `a, b, c = t`                     |

## 1.4.2 Using Tuples

### Immutable Collection of Related Objects

- **Related immutable data**: Store values that always belong together and shouldn’t change.

```python
def calculate_distance(coord1, coord2):
    # A simple Euclidean distance calculation for demonstration
    return ((coord1[0] - coord2[0]) ** 2 + (coord1[1] - coord2[1]) ** 2) ** 0.5

# Coordinates as tuples
point_a = (40.7128, -74.0060)   # New York
point_b = (34.0522, -118.2437)  # Los Angeles

distance = calculate_distance(point_a, point_b)
print(f"Distance: {distance} units")
```

### Using Tuples in Functions

- **Returning multiple values**: Use tuple packing to return more than one logical value from a function.

```python
def min_max(numbers):
    return min(numbers), max(numbers)

min_result, max_result = min_max([1, 20, 33, 401, 5])
print(f"Min is {min_result} and max is {max_result}")
```
    
- ***args in functions**: Pack variable number of positional arguments into a tuple.

```python
def sum_numbers(*args):
    print(args)
    return sum(args)

print(sum_numbers(1, 2, 3))
print(sum_numbers(1, 2, 3, 4, 5))
```

- **Performance**: Faster and more memory-efficient than lists; immutable semantics prevent modification.
	- [Tuples Performance Analysis](../../performance-in-python-structures/1-measuring-performance.md#12-sets-and-tuples)

### Storing Configuration Constraints

- **Constants**: Store read-only constant values.

```python
# Defining constants for environment variable names
ENV_VARIABLES = ('DB_HOST', 'DB_USER', 'DB_PASS', 'API_KEY')

# Using these constants ensures that the variable names are not misspelled or modified
import os

db_host = os.getenv(ENV_VARIABLES[0])
```

### Working with Database Records

- **Read-only DB records**: Retrieve database results that should not be modified.

```python
def get_employee_record(employee_id):
    # Simulated database record retrieval
    return (123, "John Doe", "Software Engineer", 75000)

employee_record = get_employee_record(123)
print(f"Employee Record: ID={employee_record[0]}, Name={employee_record[1]}, Role={employee_record[2]}, Salary={employee_record[3]}")
```