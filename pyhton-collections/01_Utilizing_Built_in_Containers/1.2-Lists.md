# 1.2 Lists
## 1.2.1 Understanding List Basics

- Used for storing objects in a sequence.
- Dynamic.
- Mutable.
- Random access by an index.
- Ordered
- Performance: [Lists and Arrays Performance](1-measuring-performance.md#11-lists-and-arrays)

| **Feature / Operation** | **Description**                                    | **Example**                       |
| ----------------------- | -------------------------------------------------- | --------------------------------- |
| **Type**                | Ordered, mutable, dynamic sequence                 | `my_list = [1, 2, 3]`             |
| **Access by index**     | Positive (0 first) / Negative (-1 last)            | `my_list[0]`, `my_list[-1]`       |
| **Length**              | Number of elements                                 | `len(my_list)`                    |
| **Append**              | Add element at end                                 | `my_list.append("x")`             |
| **Insert**              | Add element at specific index                      | `my_list.insert(2, "x")`          |
| **Pop**                 | Remove by index (default: last) and return element | `my_list.pop()`, `my_list.pop(1)` |
| **del**                 | Remove by index, no return                         | `del my_list[1]`                  |
| **Remove (by value)**   | Remove first match of value                        | `my_list.remove("x")`             |
| **Clear**               | Remove all elements                                | `my_list.clear()`                 |
| **Extend**              | Append elements from another list                  | `my_list.extend(other_list)`      |
| **Update element**      | Change value at index                              | `my_list[0] = "new"`              |
| **Count**               | Count occurrences of a value                       | `my_list.count("x")`              |
| **Index**               | Get position of first match                        | `my_list.index("x")`              |
## 1.2.2 More on Lists

| **Concept**            | **Notes & Examples**                                                             | **Syntax / Method**                                             |
| ---------------------- | -------------------------------------------------------------------------------- | --------------------------------------------------------------- |
| **Slicing**            | Stop excluded; start/stop optional; step optional; negatives count from the end. | `list[start:stop:step]`                                         |
| **Copy list**          | Don't use direct assignment (creates reference).                                 | `list.copy()`, `list[:]`                                        |
| **List comprehension** | Faster than loops; allows filtering and transformation in one line.              | `[x**2 for x in range(1,11) if x%2==0]`                         |
| **Membership test**    | Returns True/False.                                                              | `x in list`                                                     |
| **Sort (in place)**    | Modifies the current list; reverse=True for descending order.                    | `list.sort(reverse=True)`                                       |
| **Sort (copy)**        | Returns new sorted list.                                                         | `sorted(list, reverse=True)`                                    |
| **Reverse order**      | Reverses order without sorting.                                                  | `list.reverse()`                                                |
| **Iteration**          | Iterates through elements.                                                       | `for e in list:`                                                |
| **Concatenate**        | Joins lists and returns new one.                                                 | `list1 + list2`                                                 |
| **Repeat**             | Repeats elements n times.                                                        | `list * n`                                                      |
| **Nested lists**       | Lists within lists.                                                              | `[ [1,2], [3,4] ]`                                              |
| **Join to string**     | Joins elements with separator.                                                   | `' '.join(list)`                                                |
| **Built-in funcs**     | Max, min, sum, all true, any true.                                               | `max(list)`, `min(list)`, `sum(list)`, `all(list)`, `any(list)` |
| **Unpacking**          | * captures the rest of elements.                                                 | `a, b = list`, `a, b, *rest = list`                             |
**Unpacking**

```python
In [1]: coordinates = [0.715254, -74.055484]

# Order is relevant
In [2]: latitude, longitude = coordinates

In [3]: print(f"Latitude: {latitude}, Longitude: {longitude}")
Latitude: 0.715254, Longitude: -74.055484

# We always have id, timestamp and type, but we don't knwo how mmany details
# use *details to capture the remaining packed elements
In [4]: event_data = [
   ...:     [101, "2023-08-01 12:00", "LOGIN", "user123", "192.168.1.1"],
   ...:     [102, "2023-08-01 12:05", "LOGOUT", "user456"],
   ...:     [103, "2023-08-01 12:10", "FILE_UPLOAD", "user123", "report.pdf", 1024],
   ...: ]

In [5]: for event_id, timestamp, event_type, *details in event_data:
   ...:     print(f"Event ID: {event_id}, Timestamp: {timestamp}, Type: {event_type}")
   ...:     if details:
   ...:         print(f"Details: {details}")
   ...:     print("---")
   ...:
Event ID: 101, Timestamp: 2023-08-01 12:00, Type: LOGIN
Details: ['user123', '192.168.1.1']
---
Event ID: 102, Timestamp: 2023-08-01 12:05, Type: LOGOUT
Details: ['user456']
---
Event ID: 103, Timestamp: 2023-08-01 12:10, Type: FILE_UPLOAD
Details: ['user123', 'report.pdf', 1024]
```

## 1.2.3 Using Lists

### Prototyping and Education

- **Inventory management**: Products stored as dictionaries; add with append(), remove with list comprehension.

```python
# Inventory Management Example

# Initial inventory list containing dictionaries for each product
inventory = [
    {"id": 1, "name": "T-shirt", "quantity": 25, "price": 15.99},
    {"id": 2, "name": "Jeans", "quantity": 30, "price": 39.99},
    {"id": 3, "name": "Socks", "quantity": 50, "price": 4.99}
]

# append() adds the new product at the end of the list
def add_product(inventory, product):
    inventory.append(product)  

# inventory[:] updates the existing list *in place* instead of creating a new one scoped only in the function.
# This is important when 'inventory' is a global variable or shared reference.
# The list comprehension filters out any product whose "id" matches 'product_id'.
def remove_product(inventory, product_id):
    inventory[:] = [product for product in inventory if product["id"] != product_id]

add_product(inventory, {"id": 4, "name": "Jacket", "quantity": 15, "price": 59.99})

remove_product(inventory, 2)

print("Current Inventory:")
for product in inventory:
    print(product)
```

> [!NOTE] **Medium-sized Ordered Collections**
> 
> The term “medium size” is somewhat subjective and depends on the context of the application and available system resources. Generally, a medium-sized collection in Python could range from a few hundred to a few thousand elements.

### Medium-sized Ordered Collections

- **Playlist management**: Use `enumerate()` to get indexes, `pop()` and `insert()` to reorder songs.

```python
# Playlist Management in a Music Streaming App

playlist = []

# Adds the song dictionary to the end of the playlist
def add_song(playlist, song):
    playlist.append(song)  

# Function to remove a song from the playlist by its title
def remove_song(playlist, song_title):
    # The slicing [:] ensures we modify the existing list in place
    playlist[:] = [song for song in playlist if song["title"] != song_title]

# Function to move a song to a new position in the playlist
def move_song(playlist, song_title, new_position):
    # enumerate() gives both index and value while looping
    for i, song in enumerate(playlist):
        if song["title"] == song_title:
            # pop(i) removes and returns the song at index i
            # insert(new_position, song) places it in the desired position
            playlist.insert(new_position, playlist.pop(i))
            break  # Exit after moving the song

add_song(playlist, {"title": "The Entertainer", "artist": "Scott Joplin"})
add_song(playlist, {"title": "St. Louis Blues", "artist": "W.C. Handy"})
add_song(playlist, {"title": "Clair de Lune", "artist": "Claude Debussy"})

move_song(playlist, "Clair de Lune", 0)

remove_song(playlist, "St. Louis Blues")

print("Current Playlist:")
for song in playlist:
    print(f"{song['title']} by {song['artist']}")
```

### Data Collection Prior to Processing

- **Sensor data collection**: Keep only the last _n_ readings using slicing.

```python
sensor_data = []

# Simulate receiving new data from a sensor
def receive_sensor_data():
    # This function would interface with actual sensor hardware in a real scenario
    import random
    return random.uniform(20, 30)  # Random temperature value between 20 and 30

# Collect data
for _ in range(1000):  # Simulate 1000 data points
    new_data = receive_sensor_data()
    sensor_data.append(new_data)

recent_data = sensor_data[-100:]  # Get the last 100 data points for processing

# Remove old data if necessary
if len(sensor_data) > 1000:
    sensor_data = sensor_data[-1000:]  # Keep only the most recent 1000 data points

# Some processing
average_recent = sum(recent_data) / len(recent_data)
print(f"Average of recent data: {average_recent}")
```

> [!NOTE] **Data Collection Prior to Processing**
> 
Lists are often used as a starting point for data collection because of their simplicity and flexibility. Imagine a scenario where you’re collecting real-time sensor data for initial processing and analysis. In this case, the data is collected in a sequence (e.g. time-series data from sensors), and you need to perform operations like appending new data points, accessing recent values for quick analysis, and occasionally removing outdated data.

### Frequent Read and Append Operations

- **Event logging**:- **Related immutable data**: Store values that always belong together and shouldn’t change.
    
- **Returning multiple values**: Use tuple packing to return more than one logical value from a function.
    
- **Tuple unpacking**: Extract multiple values from a returned tuple.
    
- ***args in functions**: Pack variable number of positional arguments into a tuple.
    
- **Performance**: Faster and more memory-efficient than lists; immutable semantics prevent modification.
    
- **Constants**: Store read-only constant values.
    
- **Read-only DB records**: Retrieve database results that should not be modified.  Store recent events, focusing on frequent read and append operations.

```python
# Real-time event logging example for a software application

event_log = []

def receive_event(event):
    event_log.append(event)

# Simulate receiving events
for i in range(100):
    event = f"Event {i}"
    receive_event(event)

recent_events = event_log[-10:]  # Get the last 10 events
print("Recent Events:")
for event in recent_events:
    print(event)
```

> [!NOTE] **Frequent Read And Append Operations**
>
 Lists are ideal for frequent read operations because they provide O(1) time complexity for accessing elements by index. This means that the time taken to access an element is constant and does not increase with the size of the list. However, if your primary operations involve modifying the list (like inserting or deleting elements, especially in the middle of the list), the performance can degrade since these operations have O(n) time complexity in lists. Other structures like or deque (from collections) can offer more efficient insertions and deletions.
>
Appending to a list (adding to the end) is efficient because it generally has O(1) time complexity, making it fast. In contrast, removing items, especially from the beginning or the middle of a list, is less efficient (O(n)) because it requires shifting all the subsequent elements.
### Performance Insights

- **O(1)**: Access by index, append to end (fast, independent of size).
- **O(n)**: Remove and insert (slower for large lists).
- Lists pre-allocate extra memory for faster future appends.

Reference: [Measuring Lists performance](../../performance-in-python-structures/1-measuring-performance.md#11-lists-and-arrays)
### Web Frameworks
    
- Framework configs (e.g., Flask route HTTP methods as lists).

```python
from flask import request

@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        return do_the_login()
    else:
        return show_the_login_form()
```

### Pandas

- Passing structured data (e.g., Pandas DataFrames from lists).

```python
import pandas as pd

# Define data as a list of lists
data = [
    ["Alice", 30],
    ["Bob", 35],
    ["Charlie", 25]
]

# Create a DataFrame using the data
df = pd.DataFrame(data, columns=["Name", "Age"])
```

- Suitable when the modification frequency is low, but reads/appends are frequent.
