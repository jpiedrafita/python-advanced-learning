

# Embedding Documets

- In MongoDB we can create relationships by embedding documnets.
- In a JSON object, the key of a value can be another object.

```json
{
	"key_1": "value_1",
	"key_2": {
		"embedded_key_1": "embedded_value_1",
		"embedded_key_2": "embedded_value_2",
		"embedded_key_2": "embedded_value_3"
	},
	"key_3": "value_3"
}
```

- Use case: 
	- Sometimes users will want to categorize coins that they want to monitor into watch lists, with associated metadata.
	- A watch list, such as a name, description, currency, and the date it was created. 
	- Some of these fields could be embedded into the watch list document or you could take them and put them into a separate metadata embedded document.
	- In Pymongo we represent the embedded metadata document as a ```dict```.

```python
metadata = {
	"description": "This is a watchlist",
	"Currency": "USD",
	"date_created": datetime.datetime.now()
}
```

- Then, the watchlist is another Python ```dict```.

```python
watchlist = {
	"name": "My watchlist"
}
```

- Simply create a new key for the metadata and set it to the metadata dictionary.

```python
watchlist["metadata"] = metadata
```

- Call ```insert_one()```.

```python
watchlist.insert_one(watchlist)
```

- Notice that the watchlist document was assigned an ID, however the embedded document was not
	- The metadata document belongs to and exists in the context of the watch list document, so there was no collection created for the metadata documents, and they weren't assigned object IDs.

```json
{
  "_id": {
    "$oid": "644d6bcb23a2367e59da32b4"
  },
  "name": "My Watchlist",
  "metadata": {
    "description": "This is a watchlist",
    "currency": "USD",
    "date_created": {
      "$date": "2023-04-29T14:11:07.535Z"
    }
  }
}
```

# Filtering Embedded Documents

- To filter use dots to specified the embedded document.
- When we start embedding documents we can simplify giving the ```find``` method a projection document.
	- In the projection document, set the names of the fields you want to include in the results to one.
- Notice that the currency still must be prefixed with metadata. 
- Regardless of what fields you put in the projection document, the ObjectId will always be included in the results, and that's how we can model something similar to a one‑to‑one

```python
# Find watchlists with USD
usd_watchlists = watchlists.find({
	"metadata.currency": "USD"
}, {
	"name": 1, "metadata.currency": 1
})
```

```json
[
    {
        '_id': ObjectId('644d6bcb23a2367e59da32b4'),
        'name': 'My Watchlist',
        'metadata': {
            'currency': 'USD'
        }
    }
]
```

# One-to-many Relationship

- We can set the multiple relationship setting a list to put documents in.
- Each dictionary in the list will be embedded into the array as a doument.

- Each coin the watchlist will be a simple document

```python
bitcoin = {
	"coin": "bitcoin",
	"note": "Bitcoin is numenr one!",
	"date_added": datetime.datetime.now()
}
```

- Then we can add a coins key to the watchlist dictionary, not the metadata

```python
watchlist = {
	"name": "My Watchlist",
	"coins": [bitcoin]
}
```

- Since ```"coins"``` is a Python list we can append dictionaries later.

```python
watchlist["coins"].append({
	"coin": "ethereum",
	"note": "Ethereum is numer two!",
	"date_added": datetime.datetime.now()
})
```

- The document that will be stored.
	- Each of the documents in the list are embedded and not assigned an ID.

```json
{
  "_id": {
    "$oid": "644d6bcb23a2367e59da32b4"
  },
  "name": "My Watchlist",
  "coins": [
    {
      "coin": "bitcoin",
      "note": "Bitcoin is number one!",
      "date_added": {
        "$date": "2023-04-29T14:11:07.535Z"
      }
    },
    {
      "coin": "ethereum",
      "note": "Ethereum is number two!",
      "date_added": {
        "$date": "2023-04-29T14:11:07.535Z"
      }
    }
  ],
  "metadata": {
    "description": "This is a watchlist",
    "currency": "USD",
    "date_created": {
      "$date": "2023-04-29T14:11:07.535Z"
    }
  }
}
```

# Filtering Embedded Arrays

- We cannot try to find a watchlist with bitcoin in it, because it will look in the ```"coins"``` array for a document that **exactly matches**. 

```python
# Find a wathclist with bitcoin in it
bitcoin_watchlist = find_one({"coins": {"coins": "bitcoins"}})
```

- Instead we must use dot for the embedded documents.
- This will return the entire document, so we might want to use projection.

```python
bitcoin_watchlist = find_one({"coins.coin": "bitcoin"}, {"name": 1})
```

- We can even combine this with the ```$and``` operator.

```python
bitcoin_usd_watchlist = find_one ({
	"$and": [
		{"metadata.currency": "USD"},
		{"metadata.coins": "bitcoin"}
	]
}, {"name": 1})
```

- We can also add and remove embedded documents using MongoDB update operators.
	- ```$push``` will add a new document to the array.
	- Use the ```ObjectId``` type to get a document by its object, found in the ```bson``` module.

```python
import datetime
from bson import ObjectId

watchlists.update_one(
    {"_id": ObjectId("644d6bcb23a2367e59da32b4")},
    {
        "$push": {
            "coins": {
                "coin": "dogecoin",
                "note": "It's a joke!",
                "date_added": datetime.datetime.now()
            }
        }
    }
)
```

- Use the ```$pull``` operator to delete an object.

```python
watchlists.update_one(
    {"_id": ObjectId("644d6bcb23a2367e59da32b4")},
    {"$pull": {"coins": {"coin": "dogecoin"}}}
)
```

- We could do this by manipulating Python lists, but it will introduce performance issues.
- Mongita supports the ```$push``` operator but the ```$pull``` operator, which will rise an error unlike the ```$and``` operator.

