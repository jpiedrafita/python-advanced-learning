# Fetchig rows

- To retrieve data, we continue to follow the pattern of sending SQL to the server and executing it, but we'll need to parse the data that was sent back.

```python
# SQL query to select all investments in Bitcoin
select_bitcoin_investment = "SELECT * FROM investment WHERE coin='bitcoin';"

# Execute the SQL query to retrieve all Bitcoin investments
cursor.execute(select_bitcoin_investment)
data = cursor.fetchone()
print(data)
```

- We receive a tuple similar to how sqlite3 module returns data

```bash
❯ python demo.py
(1, 'bitcoin', 'USD', 1.0)
```

- Retrieving with ```fetchall()``` we get a list of tuples

```python
# SQL query to select all investment
select_all_investments = "SELECT * FROM investment;"

# Execute the SQL query to retrieve all investments
cursor.execute(select_all_investments)
data = cursor.fetchall()
print(data)
```

```python
❯ python demo.py
[(1, 'bitcoin', 'USD', 1.0), (2, 'bitcoin', 'GBP', 10.0), (3, 'dogecoin', 'EUR', 100.0)]
```

# Cursor factories

 - ```Pyscopg2``` doesn't have row factories, but can use ```cursor_factory=psycopg2.extras.RealDictCursor``` in the cursor to get a structure similar to dictionaries instead tuples


```python
cursor = connection.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
```

```bash
❯ python demo.py
[RealDictRow({'id': 1, 'coin': 'bitcoin', 'currency': 'USD', 'amount': 1.0}), RealDictRow({'id': 2, 'coin': 'bitcoin', 'currency': 'GBP', 'amount': 10.0}), RealDictRow({'id': 3, 'coin': 'dogecoin', 'currency': 'EUR', 'amount': 100.0})]
```

- The result is a list of ```RealDictRow```.
	- Each one is a list of tuples
	- Each tuple is a pair column name and value.
- A list of tuples can be used to init a dictionary

```python
cursor.execute(select_all_investments)
data = [dict(row) for row in cursor.fetchall()]
print(data)
```

```bash
❯ python demo.py
[{'id': 1, 'coin': 'bitcoin', 'currency': 'USD', 'amount': 1.0}, {'id': 2, 'coin': 'bitcoin', 'currency': 'GBP', 'amount': 10.0}, {'id': 3, 'coin': 'dogecoin', 'currency': 'EUR', 'amount': 100.0}]
```

# Improving from cursor factory to dataclass

- We define a dataclass to model the investment

```python
from dataclasses import dataclass

@dataclass
class Investment:
	id: int
	coin: str
	currency: str
	amount: float
```

- We create an Investment instance from the dictionary by passing it as a keyword argument to the initializer.
- Now the data is a list of Investment instances

```python
data = [Investment(**dict(row)) for row in cursor.fetchall()]
```

```bash
❯ python demo.py
[Investment(id=1, coin='bitcoin', currency='USD', amount=1.0), Investment(id=2, coin='bitcoin', currency='GBP', amount=10.0), Investment(id=3, coin='dogecoin', currency='EUR', amount=100.0)]
```

- We can iterate through them and access values by name

```python
data = [Investment(**dict(row)) for row in cursor.fetchall()]
for investment in data:
	print(
		f"Investment ID: {investment.id}, Coin: {investment.coin}, "
		f"Currency: {investment.currency}, Amount: {investment.amount}"
	)
```

```bash
❯ python demo.py
Investment ID: 1, Coin: bitcoin, Currency: USD, Amount: 1.0
Investment ID: 2, Coin: bitcoin, Currency: GBP, Amount: 10.0
Investment ID: 3, Coin: dogecoin, Currency: EUR, Amount: 100.0
```
