# Command

- [Before Command](#before-command)
- [Understanding the Command Pattern](#understanding-the-command-pattern)
- [Implementing the Command Pattern](#implementing-the-command-pattern)
- [Undo](#undo)

---

- **Command is a behavioral pattern**: it controls how operations are executed on objects.    
- It **encapsulates a request as an object**, aligning with the principle _encapsulate what varies_.
- This **decouples the sender of a request from the object that executes it**.
- Unlike Strategy, **commands can have different method signatures**.
- It enables:
    - **Parameterizing objects** with different actions.
    - **Queuing and logging** requests (useful for audits or persistence).
    - **Undo/redo functionality**, by storing and replaying sequences of commands.
- Used commonly in:
    - **GUI toolkits**
    - **CLI programs**
    - **Menus or button callbacks**
- Also known as: **Action Pattern** or **Transaction Pattern**.
- Follows **SOLID principles**, especially **Single Responsibility** and **Open/Closed**.

## Before Command

- Command line order processing program with three operations:
	- CreateOrder
	- UpdateQuantity
	- ShipOrder
- The system must_
	- Parse the command-line arguments.
	-  Identify and execute the command.
    - Notify the user and log the result.
- Other operations might be required later, e.g. DeleteOrder.

*BeforeCommand/\_\_main__.py*
```Python
import sys
from .command_executor import CommandExecutor

# Simple command-line interface with hardcoded dispatching logic
if len(sys.argv) < 2:
    print('Usage: python -m BeforeCommand <command>')
    print('Commands:')
    print('  CreateOrder')
    print('  UpdateQuantity number')
    print('  ShipOrder')
    exit()

executor = CommandExecutor()
executor.execute_command(sys.argv[1:])  # Pass all args except script name
```

*BeforeCommand/command_executor.py*
```python
class CommandExecutor(object):
    def execute_command(self, args):
        cmd, *parms = args

        # Uses hardcoded conditional logic to dispatch commands
        # This is the classic if/elif/else antipattern the Command Pattern aims to replace
        if cmd == "CreateOrder":
            self.create_order()
        elif cmd == "UpdateQuantity":
            self.update_quantity(parms[0])
        elif cmd == "ShipOrder":
            self.ship_order()
        else:
            print(f'Unrecognized command: "{cmd}".')

    # Each of these methods implements actual business logic AND is tied to the command string above
    # This tightly couples command execution to parsing logic (violates SRP and OCP)
    def create_order(self):
        raise NotImplementedError

    def update_quantity(self, val):
        old_val = 5
        print('Database updated')
        print(f'Logging updated quantity from "{old_val}" to "{val}".')

    def ship_order(self):
        raise NotImplementedError
```

- CommandExecutor has **too many responsibilities**:
    - Parses the command string.
    - Dispatches the appropriate action.
    - Implements the actual logic.    
- The if/elif/else chain:
    - Is **not extensible** without modifying existing code (violates **Open/Closed Principle**).
    - **Couples logic to strings**, making it error-prone.
    - Prevents reusability or testability of individual command units.
- There’s **no abstraction for commands**, so you can’t queue, undo, or reuse them in other contexts.

```bash
> python -m BeforeCommand
Usage: python -m BeforeCommand <command>
Commands:
    CreateOrder
    UpdateQuantity number
    ShipOrder

> python -m BeforeCommand UpdateQuantity 3.14159
Database updated
Logging updated quantity from "5" to "3.14159".
```

## Understanding the Command Pattern

- **SRP Violation (Single Responsibility Principle):**
    - CommandExecutor handles both command parsing and execution logic.
    - These concerns should be decoupled.
- **OCP Violation (Open/Closed Principle):**
    - New commands require modifying the CommandExecutor class (if/elif/else structure).
- **DIP Violation (Dependency Inversion Principle):**
    - The main program is tightly coupled to the concrete implementation of execute_command.
- **Code Smell:**
    - The long if/elif/else chain is fragile and hard to maintain.

![command pattern.png](command-pattern.png)

- **Client**:
    - The initiator of a request (e.g. the user or the app itself.
    - Needs to get something done.
- **Invoker**:
    - Calls the command’s `execute()` method (e.g., main program).
    - Asks the command to perform a request.
- **ConcreteCommand**:
    - Encapsulates the action and delegates execution to a **Receiver**, or performs it directly.
    - It knows how to perform the action requested.
    - There should be one ConcreteCommand for each command.
    - Fully encapsulates the command so the client is no longer concerned to particulars.
    - `Undo()` is optional.      
- **Receiver** (optional):
    - The actual component that knows how to perform the operation.

## Implementing the Command Pattern

*command/command_abc.py*
```python
import abc

class AbsCommand(abc.ABC):
    # It declares the common method `execute()` that all concrete commands must implement.
    @abc.abstractmethod
    def execute(self):
        pass
```

- This is the `Command` interface in the Command Pattern.
- It declares the common method `execute()` that all  `ConcreteCommand` must implement.
- `Undo()` is not implemented.

*command/order_command_abc.py*
```python
import abc

class AbsOrderCommand(abc.ABC):

    @abc.abstractproperty
    def name(self):
        # Name of the command. Used for registration and display.
        pass

    @abc.abstractproperty
    def description(self):
        # Description of the command. Used in help or usage messages.
        pass
```

- This class is **not strictly required** by the Command Pattern, but it enhances it by adding metadata.
	- It is used to enforce a common interface for command metadata.
	- It complements `AbsCommand` by adding required attributes like `name` and `description`.
- It supports the dynamic discovery and display of commands (like in help menus).
- It keeps the **Invoker** and **Client** decoupled from knowing command details.

*command/create_order.py*
```python
from .command_abc import AbsCommand
from .order_command_abc import AbsOrderCommand

class CreateOrder(AbsCommand, AbsOrderCommand):
    # Each command defines its own name and description (used by the Invoker)
    name = description = 'CreateOrder'

    # This is the method that will be called by the Invoker
    def execute(self):
        raise NotImplementedError 
```

*command/update_order.py*
```python
from .command_abc import AbsCommand
from .order_command_abc import AbsOrderCommand

class UpdateOrder(AbsCommand, AbsOrderCommand):
    name = 'UpdateQuantity'
    description = 'UpdateQuantity number'

    def __init__(self, args):
        # Store input from CLI so that execute() can remain parameterless
        self.newqty = args[1]

    def execute(self):
	    # Simulates quantity, database update, and logging
        oldqty = 5  
        print('Updated Database')
        print(f'Logging: Updated quantity from "{oldqty}" to "{self.newqty}"')
```

*command/create_order.py*
```python
from .command_abc import AbsCommand
from .order_command_abc import AbsOrderCommand

class ShipOrder(AbsCommand, AbsOrderCommand):
    name = description = 'ShipOrder'

    def execute(self):
        raise NotImplementedError 
```

- Modules for each command.
- Each command class (e.g., CreateOrder, UpdateOrder) encapsulates a specific action and implements a shared `execute()` method.
- All commands inherit from `AbsCommand` (defining the interface) and `AbsOrderCommand` (providing name/description metadata).
- The constructor in `UpdateOrder` accepts arguments and stores them internally. This allows `execute()` to be called without parameters.
- This design eliminates the need for long if/elif blocks in the main program.
- New commands can be added without modifying existing logic (Open/Closed Principle).
- The commands are self-contained and decoupled from the invoker, improving testability and maintainability.

*\_\_main__.py*
```python
from .command import CreateOrder
from .command import UpdateOrder
from .command import ShipOrder
from .command import NoCommand

import sys
import inspect

def main():
    commands = get_commands()
    # If no arguments are passed, print usage and exit
    if len(sys.argv) < 2:
        print_usage(commands)
        exit()

    # Find and execute the appropriate command object
    command = parse_command(commands, sys.argv[1:])
    command.execute()  # Command pattern in action

def get_commands():
    # Map command names to their respective classes in a dict
    commands = (CreateOrder, UpdateOrder, ShipOrder)
    return dict((cls.name, cls) for cls in commands)

def print_usage(commands):
    print('Usage: python -m Command CommandName [arguments]')
    print('Commands:')
    for command in commands.values():
        # Uses the .description property from each command
        print(f'  {command.description}')

def parse_command(commands, args):
    # Tries to fetch the command class by name; fallback to NoCommand (Null Object Pattern)
    command = commands.setdefault(args[0], NoCommand)

    # Introspect the __init__ method to check if it accepts arguments
    s = inspect.signature(command)
    return command(args) if len(s.parameters) else command()

if __name__ == '__main__':
    main()
```

- `main()` plays the role of the **Invoker**, asking the command to execute.
- Commands are decoupled from the invoker: the invoker doesn’t know how a command works internally.
- `get_commands()` dynamically builds a registry of commands using their name attribute.
- `print_usage()` is used when no commands are supplied.
	- It uses the dynamic dict holding all the command names.
- `parse_command()` selects and instantiates the appropriate command class using a **dictionary lookup**, and uses the **Null Object Pattern** (`NoCommand`) for unknown commands.
- `inspect.signature()` allows flexible command design: only those needing arguments receive them.
- This architecture fully encapsulates commands as objects, adhering to the Command Pattern.

*command/no_command.py*
```python
from .command_abc import AbsCommand

# NoCommand is a Null Object implementation of the Command interface.
# It prevents the need to check for None when looking up invalid commands.
class NoCommand(AbsCommand):
    def __init__(self, args):
        self._command = args[0]

    def execute(self):
        print('No command named %s' % self._command)
```

- `NoCommand` acts as a **Null Object**: it implements the same interface as the valid commands (`AbsCommand`), but performs a fallback behavior.
- This avoids None checks in the invoker and simplifies the logic — the command is always executed, valid or not.
- Combined with `setdefault()` in the command lookup, it ensures graceful degradation without throwing errors.
- This is a common complement to the **Command Pattern** to handle unknown or unsupported actions cleanly.

## Undo

- The scenario involves a menu of actions (like locking doors or arming alarms) that must be **executed and undone**, in **reverse order**.
- A MenuAction class is responsible for triggering and undoing commands, **without knowing implementation details** of the actions themselves.

*command_abc.py*
```python
import abc

# Abstract base class defining the Command interface
# All concrete commands must implement these two methods.
class AbsCommand(abc.ABC):

    @abc.abstractmethod
    def execute(self):
        """Perform the action."""
        pass

    @abc.abstractmethod
    def undo(self):
        """Revert the action."""
        pass
```

- This class represents the **Command** abstraction in the Command Pattern.
- It enforces a common interface with `execute()` and `undo()` methods.    
- Including `undo()` allows the **Invoker** to implement multi-level undo functionality using a LIFO stack.

*actions/appliance.py*
```python
class Appliance(object):
    def __init__(self, name):
        self._name = name

    def on(self):
        print(f'{self.name} has been turned on.')

    def off(self):
        print(f'{self.name} has been turned off.')
```

*actions/door.py*
```python
class Door(object):
    def __init__(self, name):
        self.name = name

    def lock(self):
        print(f'{self.name} is locked.')

    def unlock(self):
        print(f'{self.name} is unlocked.')
```

*actions/security.py*
```python
class Security(object):
    def arm(self):
        print('Security system armed')

    def disarm(self):
        print('Security disarmed')
```

- Each class (Appliance, Door, Security) acts as a **Receiver** in the Command pattern
- The **Receiver’s methods** are domain-specific and encapsulate the business logic (e.g., turning on an appliance, locking a door).

*door_commands.py*
```python
from actions.door import Door
from command_abc import AbsCommand

# ConcreteCommand for locking a door
class DoorLockCommand(AbsCommand):
    def __init__(self, door):
        # Ensure the receiver is of the correct type
        if not isinstance(door, Door):
            raise TypeError(f'Expected a Door object, got {door.__class__.__name__} instead.')
        self.door = door

    def execute(self):
        # Delegates the action to the receiver
        self.door.lock()

    def undo(self):
        # Reverses the action by calling the receiver's counterpart method
        self.door.unlock()

# ConcreteCommand for unlocking a door
class DoorUnlockCommand(AbsCommand):
    def __init__(self, door):
        if not isinstance(door, Door):
            raise TypeError(f'Expected a Door object, got {door.__class__.__name__} instead.')
        self.door = door

    def execute(self):
        self.door.unlock()

    def undo(self):
        self.door.lock()
```

- Each command class (`DoorLockCommand`, `DoorUnlockCommand`) encapsulates an action and its undo.
- They delegate behavior to a **receiver** (Door) via `execute()` and `undo()`.
- This structure decouples the caller from the action logic, making commands interchangeable and undoable.

*security_commands.py*
```python
from actions.security import Security
from command_abc import AbsCommand

# Command to arm the security system
class SecurityArmCommand(AbsCommand):
    def __init__(self, security):
        if not isinstance(security, Security):
            raise TypeError(f'Expected a Security object, got {security.__class__.__name__} instead.')
        self.security = security

    def execute(self):
        self.security.arm()   # Execute action

    def undo(self):
        self.security.disarm()  # Undo action


# Command to disarm the security system
class SecurityDisarmCommand(AbsCommand):
    def __init__(self, security):
        if not isinstance(security, Security):
            raise TypeError(f'Expected a Security object, got {security.__class__.__name__} instead.')
        self.security = security

    def execute(self):
        self.security.disarm()   # Execute action

    def undo(self):
        self.security.arm()      # Undo action
```

- Same approach as before.

*menu_action.py*
```python
from queue import  # Queue for tracking commands order
from collections import defaultdict

# Small container for paired commands (activate/deactivate)
class Actions(object):
    def __init__(self, activate, deactivate):
        self.activate = activate     
        self.deactivate = deactivate 

class MenuAction(object):
    def __init__(self):
        self.undo_commands = LifoQueue()                  # Stack to support multi-level undo
        self.commands = defaultdict(Actions)              # Command registry: {item -> Actions}

    def set_command(self, item, activate, deactivate):
        # dict of supported commands with refs to the obhects to executo and undo
        self.commands[item] = Actions(activate, deactivate)

	# Whenever a command is executed is put on top of the queue
    def activate(self, item):
        # Run the item's activate command and push to undo stack
        action = self.commands[item].activate
        action.execute()
        self.undo_commands.put(action)

    def deactivate(self, item):
        # Run the item's deactivate command and push to undo stack
        action = self.commands[item].deactivate
        action.execute()
        self.undo_commands.put(action)

    def undo(self):
        # Pop and undo last command
        if not self.undo_commands.empty():
            self.undo_commands.get().undo()
```

- Brings all commands together.
- MenuAction is the **invoker**: it triggers and undoes commands without knowing their details.
- Each command implements `execute()` and `undo()`, complying with the AbsCommand interface.
- Actions groups each command with its inverse (e.g., on/off, lock/unlock).
- LifoQueue supports multi-level undo (last-in-first-out).
- The **receiver logic** (e.g., Door, Security, Appliance) is fully decoupled from the invoker.

*\_\_main__.py*
```python
from actions.appliance import Appliance
from actions.door import Door
from actions.security import Security

from appliance_commands import ApplianceOnCommand, ApplianceOffCommand
from door_commands import DoorLockCommand, DoorUnlockCommand
from security_commands import SecurityArmCommand, SecurityDisarmCommand
from menu_action import MenuAction

# Instantiate the invoker
menu_action = MenuAction()
# Create the receiver
frontdoor = Door('Front Door')
# Create the concrete commands
frontdoor_lock = DoorLockCommand(frontdoor)
frontdoor_unlock = DoorUnlockCommand(frontdoor)

# Register the command pair in the invoker
menu_action.set_command(frontdoor, frontdoor_lock, frontdoor_unlock)

# Execute a command and record it for undo
menu_action.activate(frontdoor)     # Locks the door
menu_action.deactivate(frontdoor)   # Unlocks the door

# Undo the last 3 commands (LIFO)
menu_action.undo()  # Undoes deactivate → re-lock
menu_action.undo()  # Undoes activate   → unlock
menu_action.undo()  # Nothing more to undo, but still safe

# Try one more undo on an empty stack (safe no-op)
menu_action.undo()
```

```bash
> python .\__main__.py
Front Door is locked.
Front Door is unlocked.
Front Door is unlocked.
Front Door is locked.
Front Door is locked.
Front Door is unlocked.
```
