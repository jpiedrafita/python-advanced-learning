# Singleton

- [The Classic Singleton](#the-classic-singleton)
- [Reviewing the Problems Discovered](#reviewing-the-problems-discovered)
- [Using a Base Class](#using-a-base-class)
- [Using a Metaclass](#using-a-metaclass)
- [Implementing Mono State](#implementing-mono-state)
- [Summary (Singleton)](#summary-singleton)

---

- **Type**: Creational pattern.
- **Purpose**: Ensures a class has **only one instance**, with **global access** to it.
- **Common use cases**:
    - Access to **shared or limited resources** (e.g. hardware, connection pools).
    - Centralized **configuration or logging**.
- **Features**:
    - Controlled **instantiation** logic.
    - Optionally supports **lazy instantiation** (only created when needed).
- ⚠️ **Caution**:
    - Can lead to **global state** and tight coupling.
    - May introduce issues in **unit testing** or **concurrency** if not handled properly.

## The Classic Singleton

- **Motivation**
	- Logging subsystem — only one component should handle writing to a file.
	- Need to control access.

*singleton_classic.py*
```python
class Singleton(object):
    ans = None  # shared attribute across instances

    @staticmethod
    def instance():
        # Check if '_instance' already exists in the class dictionary
        if '_instance' not in Singleton.__dict__:
            Singleton._instance = Singleton()  # create and store the instance
        return Singleton._instance  # return the singleton instance


# Access singleton instance via class method
s1 = Singleton.instance()
s2 = Singleton.instance()

# Verify both variables point to the same object
assert s1 is s2

# Changing state in one reflects in the other
s1.ans = 42
assert s2.ans == s1.ans

print('Assertions passed.')
```

- `@staticmethod`: Allows calling `instance()` without creating an object.
- `Singleton.__dict__`: Used to check if _instance is already defined.
- `Singleton._instance`: Created only once and reused on subsequent calls.  

*logger_classic.py*
```python
import datetime

class Logger(object):
    log_file = None  # Shared attribute to hold the log file handle

    @staticmethod
    def instance():
        # Classic Singleton implementation using class dictionary
        if '_instance' not in Logger.__dict__:
            Logger._instance = Logger()
        return Logger._instance

    def open_log(self, path):
        # Opens the file in write mode
        self.log_file = open(path, mode='w')

    def write_log(self, log_record):
        # Adds a timestamp and writes the log entry
        now = str(datetime.datetime.now())
        record = f'{now}: {log_record}\n'
        self.log_file.write(record)

    def close_log(self):
        # Closes the file
        self.log_file.close()


# Example usage
logger = Logger.instance()
logger.open_log('my.log')
logger.write_log('Logging with classic Singleton pattern')
logger.close_log()

# Verifies content was written
with open('my.log', 'r') as f:
    for line in f:
        print(line, end='')
```

- **Singleton behavior** is ensured by storing the instance in the class __dict__.
- `log_file` is a **shared attribute** used by the single instance.
- `Logger.instance()` provides **global access** to the only instance.
- Includes basic logging logic: **open**, **write**, and **close** methods.
- Ensures that all writes go through the **same object**, avoiding conflicts. 

## Reviewing the Problems Discovered

- **Violates the Single Responsibility Principle**: The class manages both instantiation _and_ business logic (e.g. file I/O in the logger).
- **Non-standard access**: You must call a specific `instance()` method instead of using a normal constructor.
- **Hard to test**: Tight coupling and global state make it difficult to inject mocks or isolate behavior.
- **Global state issues**: The singleton shares state across the system, which is risky and error-prone (e.g. file handles).
- **Poor extensibility (Hard to sub-class)**: Carrying internal state makes subclassing or reuse in different contexts difficult.
- **Considered an anti-pattern by some**: Because of the above concerns, many developers advise caution or avoid using it altogether.

## Using a Base Class

- Fix the Single Responsibility problem
	- Building a base class for all singletons
	- Inherit from the base class for each one
	- Fix non-standard instance access
	- Other problems still remain

*singleton_base.py*
```python
class Singleton(object):
    # Dictionary to store class -> instance mapping
    _instances = {} # dict([cls, instance])

    def __new__(cls, *args, **kwargs):
        # Check if an instance already exists for this class
        if cls not in cls._instances:
            # If not, create and store it
            instance = super().__new__(cls)
            cls._instances[cls] = instance
        # Return the stored instance (existing or new)
        return cls._instances[cls]
```

- Keeps track of all singleton instances in a dict `_instances` where the keys are class references and the values are instance references.
	- This allow us to reuse the class for as many singletons as we need.
	-  `_instances` is a class-level dictionary that ensures each class using this base has only one instance.
- `__new__()` is used instead of `__init__()` to intercept instantiation before object construction.
	- `__new__()` is called before `__init__()`
- Reusable for any subclass that needs singleton behavior.
- Keeps instantiation logic decoupled from the actual subclass functionality.

*logger_base.py*
```python
import datetime
from singleton_base import Singleton

class Logger(Singleton):
    # Shared log file attribute across all instances
    log_file = None

    def __init__(self, path):
        # Open log only once
        if self.log_file is None:
            self.log_file = open(path, mode='w')

    def write_log(self, log_record):
        # Add timestamp to log record
        now = str(datetime.datetime.now())
        record = f'{now}: {log_record}\n'
        self.log_file.write(record)

    def close_log(self):
        self.log_file.close()
        self.log_file = None
```

- Inherits from `Singleton`, which ensures only one instance of Logger exists.
- `__init__()` opens the log only if it’s not already open (lazy initialization). We don't need a separate method anymore.
- `write_log()` and `close_log()` works as before.
- Responsibility is clearly separated: `Logger` handles logging, `Singleton` handles instance control.

*\_\_main\_\_.py*
```python
from logger_base import Logger

# First Logger instance opens the log
logger = Logger('my.log')
logger.write_log('Logging with classic Singleton pattern')

# Second instantiation is ignored — returns the same instance
logger2 = Logger('***ignored***')
assert logger is logger2
print('Assertion passed')

# Write and close using logger2 (same object)
logger2.write_log('Another log record')
logger.close_log()

# This would raise an exception: log already closed
# logger2.close_log()

# Read the log to confirm records were written
with open('my.log', 'r') as f:
    for line in f:
        print(line, end='')
```

- Demonstrates singleton behavior: `logger` and `logger2` are the same instance.
- Only the first call to `Logger(...)` opens the file.
- Any subsequent calls ignore the new path and reuse the same object.
- Attempting to reuse the instance after `close_log()` causes runtime errors.
- Confirms singleton via assert `logger` is `logger2`.

## Using a Metaclass

- Solves the single responsibility violation by **completely separating** instance control logic from the business class.
- Singleton is defined as a **metaclass** (inherits from type, not object).
	- An instance of a metaclass is a class.
- The metaclass overrides `__call__()` to control instantiation and maintain a single instance per class.
- Logger declares `metaclass=Singleton` instead of inheriting from it.
- This approach provides **clean separation of concerns**:
    - Singleton: manages instancing.
    - Logger: handles logging only.
- Results in a more **elegant and reusable** implementation.
- Behavior and output match previous implementations.

*singleton_meta.py*
```python
import datetime

# Metaclass Singleton: Inherits from 'type', not 'object'
class Singleton(type):
    _instances = {}  # Stores unique instance per class using this metaclass

    def __call__(cls, *args, **kwargs):
        # If no instance exists for the class, create it
        if cls not in cls._instances:
            instance = super().__call__(*args, **kwargs)
            cls._instances[cls] = instance
        # Return the existing instance
        return cls._instances[cls]
```

- `class Singleton(type)`: defines a metaclass, not a regular class.
- `__call__`: overrides how instances are created (like intercepting MyClass()).
- `super().__call__(*args, **kwargs)`: standard instantiation call.
- `_instances`: ensures only one instance per class using this metaclass.    
- Clean separation of concerns: Singleton logic lives entirely in the metaclass.
- Reusable: multiple classes can use this same metaclass for singleton behavior.

*logger_meta.py*
```python
import datetime
from singleton_meta import Singleton

# Logger is a Singleton using metaclass-based implementation
class Logger(metaclass=Singleton):
    log_file = None

    def __init__(self, path):
        # Open the log file only if it's not already open
        if self.log_file is None:
            self.log_file = open(path, mode='w')

    def write_log(self, log_record):
        now = str(datetime.datetime.now())
        record = f'{now}: {log_record}\n'
        self.log_file.write(record)

    def close_log(self):
        self.log_file.close()
        self.log_file = None
```

- `metaclass=Singleton`: Logger doesn’t inherit from a base Singleton class, it uses the metaclass instead.
- Fully separates responsibilities:
    - The **metaclass** manages instance creation.
    - The **Logger class** focuses only on logging behavior.
- `log_file` is initialized only once.
- Clean and elegant alternative when multiple inheritance is not desired.
- More flexible and avoids modifying the class signature (no need for `static instance()` method).

## Implementing Mono State

```python
class MonoState(object):
    _state = {}  # Shared state dictionary

    def __new__(cls, *args, **kwargs):
        self = super().__new__(cls)
        self.__dict__ = cls._state  # Redirect instance state to shared dict
        return self
```

- `_state = {}`: Class-level dictionary that stores **shared state** for all instances.
- `__new__`: Intercepts instance creation before `__init__`.
- `self.__dict__ = cls._state`: **Redirects** the instance’s attribute storage to the class’s shared state.
- All instances will have different identities (is will return False), but **shared attributes and values**.

*logger_mono.py*
```python
import datetime
from monostate import MonoState

class Logger(MonoState):
    log_file = None  # Shared via MonoState

    def __init__(self, path):
        if self.log_file is None:
            self.log_file = open(path, mode='w')

    def write_log(self, log_record):
        now = str(datetime.datetime.now())
        record = f'{now}: {log_record}\n'
        self.log_file.write(record)

    def close_log(self):
        self.log_file.close()
        self.log_file = None
```

- `Logger(MonoState)`: Inherits MonoState behavior — **all instances share state**.
- `log_file`: Shared attribute across all instances due to `self.__dict__ = cls._state`.
- `__init__`: Opens the file only once, regardless of how many Logger instances are created.

## Summary (Singleton)

| Feature                    | Classic Singleton            | Metaclass Singleton        | MonoState Pattern              |
| -------------------------- | ---------------------------- | -------------------------- | ------------------------------ |
| Instance count             | One real instance            | One real instance          | Multiple instances             |
| Shared state mechanism     | Class variable (`_instance`) | Metaclass `__call__` logic | Shared `__dict__` reference    |
| `a is b`                   | ✅ Yes                        | ✅ Yes                      | ❌ No                           |
| Separation of concerns     | ❌ No                         | ✅ Yes                      | ✅ Yes                          |
| Flexibility for subclasses | Limited                      | Moderate                   | High                           |
| Testability                | Difficult                    | Still hard                 | Easier (can isolate objects)   |
| Global state               | Yes                          | Yes                        | Yes (via shared dict)          |
| Implementation complexity  | Low                          | Moderate                   | Low                            |
| Best used when             | Simplicity is enough         | Identity must be enforced  | Shared state, multiple objects |
