# 8.11 Combining Method Decorators

## Key Ideas

- **@abstractmethod Must Be Innermost**: When combining decorators, `@abstractmethod` must be the innermost (closest to the function definition)
- **Independent Getter/Setter Abstraction**: Property getters and setters can be independently marked as abstract
- **__isabstractmethod__ Attribute**: Descriptors must expose this attribute to propagate abstractness correctly
- **Runtime Determination**: `__isabstractmethod__` can be implemented as a property for dynamic abstractness evaluation

---

## Combining @abstractmethod with Other Decorators

### Decorator Order Rule

```python
# @abstractmethod must be the innermost
class AbstractBaseClass(ABC):

    @staticmethod
    @abstractmethod
    def an_abstract_static_method():
        raise NotImplementedError

    @classmethod
    @abstractmethod
    def an_abstract_class_method(cls):
        raise NotImplementedError

    @property
    @abstractmethod
    def an_abstract_property(self):
        raise NotImplementedError

    # @property setters and getters can be indepentdenly abstract
    @an_abstract_property.setter
    @abstractmethod
    def an_abstract_property(self, value):
        raise NotImplementedError
```

**Critical Rule:**

`@abstractmethod` must always be the **innermost decorator** (closest to the function definition).

**Decorator Order Pattern:**

```python
@outermost_decorator    # e.g., @staticmethod, @classmethod, @property
@abstractmethod         # Always innermost
def method():
    pass
```

---

## Abstract Static Methods

### Syntax

```python
@staticmethod
@abstractmethod
def an_abstract_static_method():
    raise NotImplementedError
```

**Characteristics:**

- Does not receive `self` or `cls` parameter
- Must be overridden in concrete subclasses
- Override must also be a static method (or regular method)
- Useful for utility functions that subclasses must provide

---

## Abstract Class Methods

### Syntax

```python
@classmethod
@abstractmethod
def an_abstract_class_method(cls):
    raise NotImplementedError
```

**Characteristics:**

- Receives `cls` parameter (the class itself)
- Must be overridden in concrete subclasses
- Override must also be a class method (or regular method)
- Useful for factory methods or class-level operations

---

## Abstract Properties

### Basic Abstract Property

```python
@property
@abstractmethod
def an_abstract_property(self):
    raise NotImplementedError
```

### Independent Getter/Setter Abstraction

```python
# @property setters and getters can be indepentdenly abstract
@an_abstract_property.setter
@abstractmethod
def an_abstract_property(self, value):
    raise NotImplementedError
```

**Flexibility:**

- **Getter can be abstract** while setter is concrete
- **Setter can be abstract** while getter is concrete
- **Both can be abstract** independently
- Each accessor method is decorated separately

**Use Cases:**

- Read-only abstract properties (only getter abstract)
- Write-only abstract properties (only setter abstract)
- Full read-write abstract properties (both abstract)

---

## Abstractness in Custom Descriptors

### The __isabstractmethod__ Attribute

The abstractmethod decorator can be combined with the static method, class method, and property decorators, although care must be taken that the abstract method is the innermost decorator. For properties you can independently mark the getters and setters as abstract. Recall that properties are implemented using descriptors. When implementing your own descriptors you'll need to do a little extra work to ensure your descriptor plays nicely with abstractmethod.

```python
# __get__(), __set__(), and __delete__() can be independently abstract
class MyDataDescriptor(ABC):

    @abstractmethod
    def __get__(self, instance, owner):
        # ...
        pass

    @abstractmethod
    def __set__(self, instance, value):
        # ...
        pass

    @abstractmethod
    def __delete__(self, instance):
        # ...
        pass

    # __isabstractmethod__ attribute (e.g. property)
    # must evaluate to True if any are abstract
    @property
    def __isabstractmethod__(self):
        return True  # or False if not abstract
```

### Requirements for Custom Descriptors

**Descriptor Protocol Methods:**

Any of the descriptor protocol methods can be marked abstract:
- `__get__(self, instance, owner)` - Getter behavior
- `__set__(self, instance, value)` - Setter behavior
- `__delete__(self, instance)` - Deleter behavior

**Abstractness Propagation:**

Descriptors implemented with abstract methods must expose `__isabstractmethod__` attribute that evaluates to `True`.

### Two Implementation Approaches

**1. Class Attribute:**

```python
class MyDescriptor:
    __isabstractmethod__ = True
```

**2. Property (Dynamic Determination):**

```python
class MyDescriptor:
    @property
    def __isabstractmethod__(self):
        return True  # or False based on runtime conditions
```

**When to Use Property Approach:**

- Abstractness depends on runtime state
- Some instances are abstract, others are not
- Conditional abstractness based on configuration
- Dynamic determination needed during class creation

---

## How ABCMeta Inspects Abstractness

### Verification Example

```python
>>> from abc import ABC, abstractmethod
>>> 
>>> class AbstractBaseClass(ABC):
...     @property
...     @abstractmethod
...     def abstract_property(self):
...         raise NotImplementedError
... 
...     @property
...     def concrete_property(self):
...         return "sand, cement, water"
... 
>>> AbstractBaseClass.abstract_property.__isabstractmethod__
True
>>> AbstractBaseClass.concrete_property.__isabstractmethod__
False
```

### Analysis

**Abstract Property:**

- Decorated with both `@property` and `@abstractmethod`
- `__isabstractmethod__` attribute is `True`
- Property descriptor marks itself as abstract
- Prevents instantiation until overridden

**Concrete Property:**

- Decorated only with `@property`
- `__isabstractmethod__` attribute is `False`
- Not considered abstract
- Does not prevent instantiation

### ABCMeta's Role

**Inspection Process:**

1. **Class creation time**: `ABCMeta.__new__()` is invoked
2. **Descriptor inspection**: Each descriptor's `__isabstractmethod__` is checked
3. **Abstract method collection**: All methods/descriptors with `__isabstractmethod__ == True` are recorded
4. **Enforcement**: Class with unimplemented abstract methods cannot be instantiated

**Why This Matters:**

The `__isabstractmethod__` flag is inspected by the ABCMeta implementation when the metaclass creates the actual class object, which hosts the property descriptor.

**Implication for Custom Descriptors:**

If you create custom descriptors that wrap or compose abstract methods, you must:
1. Correctly implement `__isabstractmethod__` attribute
2. Return `True` if any wrapped method is abstract
3. Ensure `ABCMeta` can detect abstractness through your descriptor

---

## Practical Example Pattern

### Abstract Property with Default Implementation

```python
class Shape(ABC):
    @property
    @abstractmethod
    def area(self):
        """Subclasses must implement area calculation"""
        return 0.0  # Default that must be overridden

class Rectangle(Shape):
    def __init__(self, width, height):
        self._width = width
        self._height = height
    
    @property
    def area(self):
        return self._width * self._height
```

### Abstract Class Method for Factory Pattern

```python
class Document(ABC):
    @classmethod
    @abstractmethod
    def from_file(cls, filepath):
        """Factory method to create document from file"""
        raise NotImplementedError

class PDFDocument(Document):
    @classmethod
    def from_file(cls, filepath):
        # Load PDF and return instance
        return cls(data)
```

---

## Common Pitfalls

### Incorrect Decorator Order

```python
# WRONG - @abstractmethod must be innermost
@abstractmethod
@property
def wrong_property(self):
    pass

# CORRECT - @abstractmethod is innermost
@property
@abstractmethod
def correct_property(self):
    pass
```

### Forgetting __isabstractmethod__ in Custom Descriptors

```python
# WRONG - Abstractness not propagated
class BadDescriptor:
    @abstractmethod
    def __get__(self, instance, owner):
        pass
    # Missing __isabstractmethod__ attribute!

# CORRECT - Abstractness properly exposed
class GoodDescriptor(ABC):
    @abstractmethod
    def __get__(self, instance, owner):
        pass
    
    @property
    def __isabstractmethod__(self):
        return True
```

---

## Summary

The `@abstractmethod` decorator can be combined with `@staticmethod`, `@classmethod`, and `@property` decorators, but must always be the innermost decorator. Property getters and setters can be independently marked as abstract, allowing fine-grained control over required implementations. Custom descriptors that wrap abstract methods must expose an `__isabstractmethod__` attribute evaluating to `True` to propagate abstractness correctly. This attribute can be implemented as either a class attribute or a property for runtime determination. `ABCMeta` inspects `__isabstractmethod__` during class creation to determine which methods prevent instantiation, as demonstrated by comparing abstract and concrete properties where the attribute correctly reflects `True` and `False` respectively.
