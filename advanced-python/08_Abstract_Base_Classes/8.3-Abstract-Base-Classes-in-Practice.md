# 8.3 Abstract Base Classes in Practice

## Key Ideas

- **Custom Virtual Base Classes**: Implement `__subclasscheck__` in metaclasses to create virtual base classes
- **Duck Typing Integration**: Check for method existence and callability rather than inheritance
- **Instance Consistency**: Implement `__instancecheck__` to align `isinstance()` with `issubclass()`
- **Protocol Checking**: Define protocols through method signatures, not inheritance
- **Naive Implementation Risks**: Simple implementations may miss regular inheritance checks
- **Standard Library Examples**: `collections.abc.Sized` demonstrates practical virtual base class usage

## Creating Custom Virtual Base Classes

### Example: Sword Protocol

```python
class SwordMeta(type):
    def __subclasscheck__(cls, sub):
        return (hasattr(sub, 'swipe') and callable(sub.swipe)
                and
                hasattr(sub, 'sharpen') and callable(sub.sharpen))

class Sword(metaclass=SwordMeta):
    pass

class BroadSword:

    def swipe(self):
        print("Swoosh!")

    def sharpen(self):
        print("Shink!")

class SamuraiSword:

    def swipe(self):
        print("Slice!")

    def sharpen(self):
        print("Shink!")

class Rifle:

    def fire(self):
        print("Bang!")
```

**Implementation Structure**:

**Metaclass (`SwordMeta`)**:
- **Protocol Definition**: Checks for `swipe` and `sharpen` methods
- **Method Validation**: Verifies both existence (`hasattr`) and callability (`callable`)
- **Return Value**: Boolean indicating protocol compliance

**Virtual Base Class (`Sword`)**:
- **Empty Body**: No implementation required
- **Metaclass Assignment**: Uses `SwordMeta` to enable virtual base class behavior

**Protocol Implementations**:
- **`BroadSword`**: Implements required `swipe` and `sharpen` methods
- **`SamuraiSword`**: Also implements required protocol methods
- **`Rifle`**: Different interface (`fire` method), not a sword

## Testing Virtual Base Class Behavior

### Class-Level Testing with `issubclass()`

```python
>>> from weapons import *
>>> issubclass(BroadSword, Sword)
True
>>> issubclass(SamuraiSword, Sword)
True
>>> issubclass(Rifle, Sword)
False
```

**Results**:
- **`BroadSword`**: Recognized as `Sword` subclass (has required methods)
- **`SamuraiSword`**: Recognized as `Sword` subclass (has required methods)
- **`Rifle`**: Not recognized as `Sword` subclass (missing required methods)

**Key Point**: Subclass relationship established without explicit inheritance

## The `isinstance()` Inconsistency Problem

### Initial Instance Testing Failure

```python
>>> samurai_sword = SamuraiSword()
>>> isinstance(samurai_sword, Sword)
False
```

**Problem**: `isinstance()` returns `False` despite `issubclass()` returning `True`

**Root Cause**: 
- **Different Mechanism**: `isinstance()` checks for `__instancecheck__` method
- **Missing Implementation**: `SwordMeta` doesn't implement `__instancecheck__`
- **Inconsistent Behavior**: Class recognized but instances are not

## Implementing `__instancecheck__` for Consistency

```python
class SwordMeta(type):

    def __instancecheck__(cls, instance):
        return cls.__subclasscheck__(type(instance))

    def __subclasscheck__(cls, sub):
        return (hasattr(sub, 'swipe') and callable(sub.swipe)
                and
                hasattr(sub, 'sharpen') and callable(sub.sharpen))
```

**Implementation Strategy**:
- **Delegation Pattern**: `__instancecheck__` delegates to `__subclasscheck__`
- **Type Extraction**: `type(instance)` gets the class of the instance
- **Method Call**: Calls `__subclasscheck__` as a metamethod on `cls`
- **Consistency**: Ensures `isinstance()` and `issubclass()` align

### Verified Consistent Behavior

```python
>>> samurai_sword = SamuraiSword()
>>> isinstance(samurai_sword, Sword)
True
```

**Success**: `isinstance()` now returns `True`, consistent with `issubclass()` results

## Real-World Example: `collections.abc.Sized`

Python's standard library uses this technique for collection abstract base classes:

### `Sized` Protocol Example

```python
>>> from collections.abc import Sized
>>> 
>>> class SizedCollection:
...     def __init__(self, size):
...         self._size = size
...     def __len__(self):
...         return self._size
... 
>>> issubclass(SizedCollection, Sized)
True
```

**Protocol Compliance**:
- **Single Method**: Implementing `__len__` is sufficient
- **Automatic Recognition**: Virtual base class mechanism recognizes protocol compliance
- **Built-in Integration**: Works with `len()` built-in function

## Limitations and Warnings

### Naive Implementation Issues

**Current Implementation Shortcomings**:
- **Incomplete Checking**: `SwordMeta` doesn't verify regular (non-virtual) base classes
- **Potential Surprises**: May lead to unexpected behavior in complex inheritance scenarios
- **Missing Logic**: Doesn't account for traditional inheritance relationships

### Implementation Complexity

**Correct Implementation Challenges**:
- **Difficult to Get Right**: Properly overriding `__subclasscheck__` and `__instancecheck__` is complex
- **Edge Cases**: Must handle both virtual and traditional inheritance
- **Error-Prone**: Easy to introduce subtle bugs

### Alternative Approaches

**Better Solutions Available**: More digestible alternatives for creating abstract base classes will be presented in subsequent lessons

## Summary

Custom virtual base classes demonstrate:

**Key Techniques**:
- **`__subclasscheck__`**: Define custom subclass determination logic
- **`__instancecheck__`**: Ensure consistency between class and instance checks
- **Protocol-Based**: Check for method existence rather than inheritance

**Practical Applications**:
- **Duck Typing Formalization**: Convert duck typing into explicit protocols
- **Standard Library Pattern**: Used by `collections.abc` and similar modules
- **Flexible Relationships**: Enable protocol compliance without inheritance

**Important Caveats**:
- **Implementation Difficulty**: Manual metaclass approaches are error-prone
- **Incomplete Examples**: Simple implementations may miss edge cases
- **Better Alternatives**: Higher-level tools provide safer implementations

**Key Takeaway**: While custom metaclass implementations demonstrate the mechanism, production code should prefer established patterns and tools from the `abc` module for safer, more maintainable abstract base classes.
