# 8.12 Improving @invariant with ABCs

## Key Ideas

- **Problem with Chained Decorators**: Original `@invariant` implementation only enforced innermost invariant for properties
- **Detection Issue**: `isinstance(attr, property)` check failed to detect wrapped properties
- **ABC Solution**: Create `PropertyDataDescriptor` ABC to generalize property detection
- **Virtual and Real Subclasses**: Register built-in `property` as virtual subclass, make proxy a real subclass
- **__isabstractmethod__ Propagation**: Proxy must delegate `__isabstractmethod__` to wrapped property

---

## Review: The Temperature Class with @invariant

### Temperature Implementation

```python
@invariant(below_absolute_hot)
@invariant(not_below_absolute_zero)
class Temperature:

    def __init__(self, kelvin):
        self._kelvin = kelvin

    def get_kelvin(self):
        return self._kelvin

    def set_kelvin(self, value):
        self._kelvin = value

    @property
    def celsius(self):
        return self._kelvin - 273.15

    @celsius.setter
    def celsius(self, value):
        self._kelvin = value + 273.15

    @property
    def fahrenheit(self):
        return self._kelvin * 9/5 - 459.67

    @fahrenheit.setter
    def fahrenheit(self, value):
        self._kelvin = (value + 459.67) * 5/9
```

### Context from Class Decorators Module

We rounded off the previous module of this course on class decorators by building a class decorator for checking class invariants after every method call and property access. This worked fine for both methods and properties with a single application of the decorator, but with chained invariant decorators the checking didn't work as planned for properties, with only the innermost invariant taking effect.

**Design Goals:**

- Check class invariants after method calls
- Check class invariants after property access
- Support multiple chained `@invariant` decorators
- Enforce all invariants, not just the innermost

---

## The Problem: Incomplete Invariant Enforcement

### Demonstrating the Issue

```python
>>> from class_decorators import Temperature
>>> t = Temperature(42)
>>> t.celsius = -300
Traceback (most recent call last):
  File "<input>", line 1, in <module>
  File "/Users/rjs/training/tmp/class_decorators/class_decorators.py", line 76, in __set__
    self._predicate.__doc__, instance))
RuntimeError: Class invariant 'Temperature not below absolute zero' violated for <class_decorators.Temperature object at 0x...>
>>> t.celsius = 1e34
# Expected exception not raised
```

### Analysis

**Working Case (Lower Bound):**

- Assigning `-300` Celsius violates `not_below_absolute_zero` invariant
- Exception correctly raised by innermost decorator
- Lower bound check works as designed

**Failing Case (Upper Bound):**

- Assigning `1e34` Celsius should violate `below_absolute_hot` invariant
- Exception **not raised** (unexpected behavior)
- Upper bound check from outermost decorator is ignored

**Root Cause:**

Only the innermost `@invariant` decorator's predicate is enforced on properties. Chained decorators don't wrap properties multiple times as intended.

---

## Root Cause Analysis

### Original Property Detection Logic

```python
def invariant(predicate):
    """Create a class decorator which checks a class invariant.

    Args:
        predicate: A callable to which, after every method invocation,
                   the object on which the method was called will be passed.
                   The predicate should evaluate to True if the class invariant
                   has been maintained, or False if it has been violated.

    Returns:
        A class decorator for checking the class invariant tested by
        the supplied predicate function.
    """
    def invariant_checking_class_decorator(cls):
        """A class decorator for checking invariants."""
        method_names = [name for name, attr in vars(cls).items() if callable(attr)]
        for name in method_names:
            _wrap_method_with_invariant_checking_proxy(cls, name, predicate)

        property_names = [name for name, attr in vars(cls).items() if isinstance(attr, property)]
        for name in property_names:
            _wrap_property_with_invariant_checking_proxy(cls, name, predicate)

        return cls

    return invariant_checking_class_decorator
```

### The isinstance(attr, property) Problem

The problem here is that our class decorator is detecting specifically property instances with this fragment where we inspect each attribute of the class being decorated and check whether it is an instance of property.

**Detection Logic:**

```python
property_names = [name for name, attr in vars(cls).items() if isinstance(attr, property)]
```

**Issue:**

1. **First decorator application**: Detects `property` instances correctly
2. **Second decorator application**: Properties already wrapped in `InvariantCheckingPropertyProxy`
3. **Type check fails**: `InvariantCheckingPropertyProxy` is not an instance of `property`
4. **No second wrapping**: Outermost decorator doesn't wrap already-wrapped properties
5. **Result**: Only innermost invariant is enforced

Because our property wrappers of type InvariantCheckingPropertyProxy are not detected as instances of property, they are not wrapped a second time, and the invariant specified in the outermost decorator is not enforced.

---

## The Solution: PropertyDataDescriptor ABC

### Defining the Abstract Base Class

```python
class PropertyDataDescriptor(ABC):

    @abstractmethod
    def __get__(self, instance, owner):
        raise NotImplementedError

    @abstractmethod
    def __set__(self, instance, value):
        raise NotImplementedError

    @abstractmethod
    def __delete__(self, instance):
        raise NotImplementedError

    # Decorators are applied from bottom to top
    @property
    @abstractmethod
    def __isabstractmethod__(self):
        raise NotImplementedError
```

### Design Rationale

We'll introduce a new abstract base class called PropertyDataDescriptor, which inherits from the ABC convenience class, and which contains three abstract methods, which define the data descriptor protocol, dunder get, dunder set, and dunder delete.

**Key Components:**

1. **Inherits from `ABC`**: Uses `ABCMeta` as metaclass
2. **Descriptor protocol methods**: All marked as `@abstractmethod`
   - `__get__(self, instance, owner)` - Getter behavior
   - `__set__(self, instance, value)` - Setter behavior
   - `__delete__(self, instance)` - Deleter behavior
3. **`__isabstractmethod__` property**: For correct propagation of abstractness

### Decorator Order Note

PropertyDataDescriptor also includes the abstract property, dunder isabstractmethod for correct propagation of abstractness. Note that because dunder isabstractmethod needs to look like an abstract attribute we have implemented it by applying the abstract method and property decorators in that order.

**Decorator Application:**

```python
@property           # Outer: makes it look like an attribute
@abstractmethod     # Inner: marks as abstract
def __isabstractmethod__(self):
    raise NotImplementedError
```

This creates an abstract property that subclasses must implement.

---

## Registering property as Virtual Subclass

### Virtual Subclass Registration

Having defined an abstract base class, we now need some subclasses.

```python
PropertyDataDescriptor.register(property)
```

**Purpose:**

- Register built-in `property` class as virtual subclass
- Allows `isinstance(some_property, PropertyDataDescriptor)` to return `True`
- No modification to built-in `property` class required
- Enables polymorphic detection of both `property` and custom proxies

**Result:**

The first will be a virtual subclass, the built-in property class, which will register with the base class by calling PropertyDataDescriptor. register(property).

---

## Making InvariantCheckingPropertyProxy a Real Subclass

### Updated Proxy Implementation

```python
class InvariantCheckingPropertyProxy(PropertyDataDescriptor):
    def __init__(self, referent, predicate):
        self._referent = referent
        self._predicate = predicate

    def __get__(self, instance, owner):
        if instance is None:
            return self
        result = self._referent.__get__(instance, owner)
        if not self._predicate(instance):
            raise RuntimeError("Class invariant {!r} violated for {!r}".format(self._predicate.__doc__, instance))
        return result

    def __set__(self, instance, value):
        result = self._referent.__set__(instance, value)
        if not self._predicate(instance):
            raise RuntimeError("Class invariant {!r} violated for {!r}".format(self._predicate.__doc__, instance))
        return result

    def __delete__(self, instance):
        result = self._referent.__delete__(instance)
        if not self._predicate(instance):
            raise RuntimeError("Class invariant {!r} violated for {!r}".format(self._predicate.__doc__, instance))
        return result

    def __isabstractmethod__(self):
        return self._referent.__isabstractmethod__
```

### Key Changes

The second subclass will be a real subclass. We'll modify our existing property proxy, InvariantCheckingPropertyProxy, to inherit from PropertyDataDescriptor, which will also require that we override the dunder isabstractmethod property.

**Modifications:**

1. **Inheritance**: `class InvariantCheckingPropertyProxy(PropertyDataDescriptor):`
2. **Implements descriptor protocol**: `__get__`, `__set__`, `__delete__` already present
3. **Overrides `__isabstractmethod__`**: Required by abstract base class

### __isabstractmethod__ Delegation

```python
def __isabstractmethod__(self):
    return self._referent.__isabstractmethod__
```

In the implementation of dunder isabstractmethod we delegate the attribute of the same name on the referent property, which we are wrapping.

**Behavior:**

- If wrapped property is abstract, proxy reports as abstract
- If wrapped property is concrete, proxy reports as concrete
- Preserves abstractness through wrapping layers
- Allows proper ABC enforcement through multiple decorator applications

---

## Updating the Detection Logic

### Modified invariant Decorator

```python
def invariant(predicate):
    """Create a class decorator which checks a class invariant.

    Args:
        predicate: A callable to which, after every method invocation,
                   the object on which the method was called will be passed.
                   The predicate should evaluate to True if the class invariant
                   has been maintained, or False if it has been violated.

    Returns:
        A class decorator for checking the class invariant tested by
        the supplied predicate function.
    """
    def invariant_checking_class_decorator(cls):
        """A class decorator for checking invariants."""
        method_names = [name for name, attr in vars(cls).items() if callable(attr)]
        for name in method_names:
            _wrap_method_with_invariant_checking_proxy(cls, name, predicate)

        #property_names = [name for name, attr in vars(cls).items() if isinstance(attr, property)]
        property_names = [name for name, attr in vars(cls).items() if isinstance(attr, PropertyDataDescriptor)]
        for name in property_names:
            _wrap_property_with_invariant_checking_proxy(cls, name, predicate)

        return cls

    return invariant_checking_class_decorator
```

### Critical Change

Finally, we need to update the search and wrap logic in invariant checking class decorator to use the more general test for instances of PropertyDataDescriptor, rather than the more specific test for just property.

**Before:**

```python
property_names = [name for name, attr in vars(cls).items() if isinstance(attr, property)]
```

**After:**

```python
property_names = [name for name, attr in vars(cls).items() if isinstance(attr, PropertyDataDescriptor)]
```

### Why This Works

**First Decorator Application:**

1. Detects `celsius` and `fahrenheit` as `property` instances
2. `isinstance(property_obj, PropertyDataDescriptor)` returns `True` (virtual subclass)
3. Wraps with `InvariantCheckingPropertyProxy`

**Second Decorator Application:**

1. Detects already-wrapped properties as `InvariantCheckingPropertyProxy` instances
2. `isinstance(proxy_obj, PropertyDataDescriptor)` returns `True` (real subclass)
3. Wraps again with another layer of `InvariantCheckingPropertyProxy`
4. Both invariants now enforced through nested proxies

---

## Testing the Fixed Implementation

### Verification

With these changes in place, both invariants are enforced on property writes.

```python
>>> from class_decorators import Temperature
>>> t = Temperature(42)

>>> t.celsius = -300
Traceback (most recent call last):
  ...
  File "/Users/rjs/training/tmp/class_decorators/class_decorators.py", line 89, in __set__
    raise RuntimeError("Class invariant {!r} violated for {!r}".format(self._predicate.__doc__, instance))
RuntimeError: Class invariant 'Temperature not below absolute zero' violated for <class_decorators.Temperature object at ...>

>>> t.celsius = 1e34
Traceback (most recent call last):
  ...
  File "/Users/rjs/training/tmp/class_decorators/class_decorators.py", line 89, in __set__
    raise RuntimeError("Class invariant {!r} violated for {!r}".format(self._predicate.__doc__, instance))
RuntimeError: Class invariant 'Temperature below absolute hot' violated for <class_decorators.Temperature object at ...>
```

### Test Cases

**Lower Bound Test:**

We'll create a temperature of 42 Kelvin, then attempt to modify the temperature through the Celsius setter with a temperature of -300 Celsius, which is below absolute zero. This now fails as designed, signaling a violation of the temperature not below absolute zero invariant.

- Creates `Temperature(42)` instance
- Assigns `-300` to `celsius` property
- Triggers innermost invariant check
- Raises `RuntimeError` with clear message
- ✅ Lower bound invariant enforced

**Upper Bound Test:**

Then we test the other invariant by assigning a temperature of 1*10 to the 34 through the Celsius setter. This also fails as designed, signaling a violation of the temperature below absolute hot classing variant.

- Assigns `1e34` to `celsius` property
- Triggers outermost invariant check
- Raises `RuntimeError` with clear message
- ✅ Upper bound invariant enforced (previously broken)

---

## Architectural Reflection

### Complexity and Encapsulation

There's a lot going on in this code with decorators, metaclasses, abstract base classes, and descriptors, and it may seem somewhat complicated. All this complexity is well encapsulated in the invariant class decorator, so take a step back, and enjoy the simplicity of the client code in the temperature class.

**Advanced Techniques Used:**

1. **Class Decorators**: Multiple chained decorators on `Temperature`
2. **Abstract Base Classes**: `PropertyDataDescriptor` with virtual and real subclasses
3. **Descriptors**: Property protocol with `__get__`, `__set__`, `__delete__`
4. **Metaclasses**: `ABCMeta` (via `ABC`) for abstract method enforcement
5. **Decorator Stacking**: `@property` and `@abstractmethod` on `__isabstractmethod__`

### Client Code Simplicity

```python
@invariant(below_absolute_hot)
@invariant(not_below_absolute_zero)
class Temperature:
    # Simple, clean class definition
    # Complexity hidden in decorator implementation
```

**Benefits:**

- Declarative invariant specification
- No boilerplate in `Temperature` class
- Automatic enforcement on all properties
- Easy to add/remove invariants
- Clear separation of concerns

---

## Summary

The original `@invariant` decorator failed to enforce multiple chained invariants on properties because `isinstance(attr, property)` checks didn't detect already-wrapped `InvariantCheckingPropertyProxy` instances. The solution introduces `PropertyDataDescriptor` ABC defining the data descriptor protocol, registers the built-in `property` class as a virtual subclass, and makes `InvariantCheckingPropertyProxy` a real subclass that delegates `__isabstractmethod__` to its wrapped property. Updating detection logic to `isinstance(attr, PropertyDataDescriptor)` allows recognition of both original properties and wrapped proxies, enabling multiple decorator layers to wrap properties successively. The fixed implementation successfully enforces both upper and lower bound invariants, demonstrating how ABCs enable polymorphic detection across type hierarchies while encapsulating significant complexity behind a simple, declarative interface.
