# 8.8 Combining Subclass Detection and Registration

## Key Ideas

- **Precedence Rules**: `__subclasshook__()` results take precedence over the subclass registry
- **False vs NotImplemented**: Returning `False` from `__subclasshook__()` bypasses registry checks; return `NotImplemented` instead
- **Short-circuit Evaluation**: Use `or NotImplemented` to fall back to registry when protocol check fails
- **Design Trade-offs**: Combining both approaches can weaken protocol guarantees

---

## Interaction Between Detection and Registration

### Precedence Hierarchy

When combining `__subclasshook__()` with `register()`, the order of evaluation is critical:

1. **`__subclasshook__()` is checked first**
2. **If it returns `True` or `False`**: Result is definitive, registry is ignored
3. **If it returns `NotImplemented`**: Fall back to checking the subclass registry

**Key Principle:**

`__subclasshook__()` results take precedence over explicit registration. Returning definitive boolean values (`True`/`False`) prevents the subclass registry from being consulted.

---

## The LightSaber Example

### Registering a Non-compliant Class

```python
@Sword.register
class LightSaber:

    def swipe(self):
        print("Ffffkrrrrrshhzzzwooooom..woom..woooom..")
```

**Characteristics:**

- `LightSaber` implements `swipe()` method
- Does **not** implement `sharpen()` method
- Fails the protocol check in `Sword.__subclasshook__()`
- Explicitly registered using `@Sword.register` decorator

### The Problem: Registry Ignored

```python
>>> from weapons import *
>>> issubclass(LightSaber, Sword)
False
```

Despite explicit registration, `issubclass(LightSaber, Sword)` returns `False`.

**Root Cause:**

The original `__subclasshook__()` implementation returns `False` for non-compliant classes, which prevents `ABCMeta` from checking the registry.

---

## The Solution: Return NotImplemented

### Incorrect Implementation

```python
@classmethod
def __subclasshook__(cls, sub):
    # Returns False for non-compliant classes
    return (hasattr(sub, 'swipe') and callable(sub.swipe)
            and hasattr(sub, 'sharpen') and callable(sub.sharpen))
```

**Problem:**

- Returns `False` when protocol check fails
- `ABCMeta.__subclasscheck__()` treats `False` as definitive
- Subclass registry is never consulted
- Registered classes incorrectly fail `issubclass()` check

### Correct Implementation

```python
class Sword(metaclass=ABCMeta):

    @classmethod
    def __subclasshook__(cls, sub):
        return ((hasattr(sub, 'swipe') and callable(sub.swipe)
                 and hasattr(sub, 'sharpen') and callable(sub.sharpen))
                or NotImplemented)
```

**Key Changes:**

- Uses `or NotImplemented` instead of just the boolean expression
- When protocol check fails (evaluates to `False`), returns `NotImplemented`
- `NotImplemented` signals "not sure" to `ABCMeta`
- `ABCMeta` then checks the subclass registry

### How It Works

**Short-circuit Evaluation:**

```python
(protocol_check) or NotImplemented
```

| Protocol Check Result | Expression Returns | ABCMeta Behavior |
|----------------------|-------------------|------------------|
| `True` | `True` | Accepts as subclass |
| `False` | `NotImplemented` | Checks registry |

**Python's `or` operator:**
- If left operand is truthy, return it (short-circuit)
- If left operand is falsy, return right operand

---

## Testing the Fixed Implementation

### Comprehensive Verification

```python
>>> from weapons import *
>>> issubclass(BroadSword, Sword)
True
>>> issubclass(LightSaber, Sword)
True
>>> issubclass(Rifle, Sword)
False
```

### Analysis of Results

**BroadSword: Protocol-compliant**
- Implements both `swipe()` and `sharpen()`
- `__subclasshook__()` returns `True`
- Recognized as subclass via protocol detection

**LightSaber: Registered but non-compliant**
- Implements `swipe()` but not `sharpen()`
- `__subclasshook__()` returns `NotImplemented`
- `ABCMeta` checks registry, finds registration
- Recognized as subclass via explicit registration

**Rifle: Neither compliant nor registered**
- Does not implement sword protocol
- Not explicitly registered
- Correctly returns `False`

---

## Design Trade-offs and Weaknesses

### Protocol Guarantee Dilution

**Original Intent:**

The `Sword` ABC was designed to guarantee that all subclasses implement both `swipe()` and `sharpen()` methods.

**After Combining Approaches:**

- Some `Sword` subclasses (like `LightSaber`) may lack `sharpen()`
- Code checking `isinstance(obj, Sword)` cannot assume `sharpen()` exists
- The ABC's protocol guarantee is weakened

### Reduced Utility

**Implications:**

```python
def maintain_weapon(weapon):
    if isinstance(weapon, Sword):
        weapon.sharpen()  # May raise AttributeError for LightSaber!
```

**Quote from Lesson:**

> "How useful is our virtual base class, Sword, now? The answer is not very because being an instance of Sword is no longer a useful predicate for the object in question, as we can't guarantee the presence of the sharpen method."

### When to Combine Approaches

**Appropriate Scenarios:**

- Base protocol with optional extensions
- Transitional periods during refactoring
- Mixed legacy and new implementations
- Marker interfaces with weak guarantees

**Inappropriate Scenarios:**

- Strict protocol enforcement required
- Type-based method dispatch depends on protocol guarantees
- Clear interface contracts are essential

---

## Best Practices

### Clear Documentation

When combining detection and registration:

1. **Document which methods are guaranteed** vs optional
2. **Explain why some subclasses are registered** despite non-compliance
3. **Warn consumers** that protocol checks may be incomplete

### Alternative: Separate ABCs

Consider creating separate abstract base classes:

```python
class StrictSword(metaclass=ABCMeta):
    """Requires both swipe() and sharpen()"""
    @classmethod
    def __subclasshook__(cls, sub):
        return ((hasattr(sub, 'swipe') and callable(sub.swipe)
                 and hasattr(sub, 'sharpen') and callable(sub.sharpen))
                or NotImplemented)

class Weapon(metaclass=ABCMeta):
    """Requires only swipe()"""
    @classmethod
    def __subclasshook__(cls, sub):
        return (hasattr(sub, 'swipe') and callable(sub.swipe)
                or NotImplemented)

# Register with appropriate base
Weapon.register(LightSaber)
```

---

## Summary

Combining `__subclasshook__()` protocol detection with explicit `register()` requires careful handling of return values. Returning `False` from `__subclasshook__()` prevents registry checks, causing registered classes to incorrectly fail `issubclass()` tests. The solution is to return `NotImplemented` instead of `False` using the pattern `(protocol_check) or NotImplemented`, which leverages short-circuit evaluation. However, this approach weakens protocol guarantees, as demonstrated by `LightSaber` being accepted as a `Sword` despite lacking the `sharpen()` method. When combining both mechanisms, carefully consider whether the trade-off between flexibility and strict protocol enforcement serves your design goals.
