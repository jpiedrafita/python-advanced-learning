# 8.6 Library Support for Abstract Base Classes

## Key Ideas

- **ABCMeta Metaclass**: Python's `abc` module provides `ABCMeta`, which implements reliable `__subclasscheck__` and `__instancecheck__` methods
- **__subclasshook__ Protocol**: ABCs use `__subclasshook__()` class method to define custom subclass validation logic
- **NotImplemented Fallback**: Returning `NotImplemented` from `__subclasshook__` delegates to standard inheritance checking
- **Standard Library Infrastructure**: The `abc` module includes `ABCMeta`, `ABC` base class, and `@abstractmethod` decorator

---

## The abc Module

### Challenges with Manual Implementation

Implementing `__subclasscheck__` and `__instancecheck__` correctly presents several challenges:

- Maintaining consistency between instance and subclass checks
- Handling edge cases and special scenarios
- Avoiding common implementation errors

### Standard Library Solution

The Python standard library provides the `abc` module with infrastructure for creating abstract base classes:

- **`ABCMeta`**: Metaclass with reliable ABC implementations
- **`ABC`**: Convenience base class
- **`@abstractmethod`**: Decorator for abstract method declarations
- Additional utilities for ABC development

---

## Using ABCMeta

### Basic Implementation

```python
from abc import ABCMeta
  
class Sword(metaclass=ABCMeta):  # ABCMeta knows nothing

    def thrust(self):
        print("Thrusting...")
```

**Key Characteristics:**

- `ABCMeta` replaces custom metaclasses like `SwordMeta`
- Provides built-in `__subclasscheck__` and `__instancecheck__` implementations
- Does not contain domain-specific logic (doesn't know what makes a "sword")

---

## The __subclasshook__ Protocol

### How ABCMeta Delegates Validation

`ABCMeta.__subclasscheck__` calls the special `__subclasshook__()` class method to perform custom validation. This method is present on all Python objects:

```python
>>> 
>>> object.__subclasshook__()
NotImplemented
>>> 
```

### Return Values

The `__subclasshook__()` method must return one of three values:

| Return Value | Meaning |
|-------------|---------|
| `True` | The argument class **is** a subclass |
| `False` | The argument class is **not** a subclass |
| `NotImplemented` | Defer to standard inheritance checking |

**Behavior with NotImplemented:**

- Subclass test continues with regular mechanism
- Tests non-virtual base classes through normal inheritance
- Allows fallback to traditional subclass relationships

**Behavior with Boolean Values:**

- `True` or `False` definitively indicate subclass status
- No further checks are performed
- Overrides standard inheritance relationships

---

## Implementing __subclasshook__ for Sword

### Migrating from Custom Metaclass

The validation logic previously in `SwordMeta.__subclasscheck__` moves to `Sword.__subclasshook__`:

```python
class Sword(metaclass=ABCMeta):

    # def __instancecheck__(cls, instance):
    #     return cls.__subclasscheck__(type(instance))

    # def __subclasscheck__(cls, sub):
    #     return (hasattr(sub, 'swipe') and callable(sub.swipe) and hasattr(sub, 'sharpen') and callable(sub.sharpen))

    @classmethod
    def __subclasshook__(cls, sub):
        return (hasattr(sub, 'swipe') and callable(sub.swipe)
                and
                hasattr(sub, 'sharpen') and callable(sub.sharpen))

    def thrust(self):
        print("Thrusting...")
```

### Protocol Definition

The `__subclasshook__` implementation checks for:

1. **Presence of `swipe` attribute** via `hasattr(sub, 'swipe')`
2. **Callable `swipe`** via `callable(sub.swipe)`
3. **Presence of `sharpen` attribute** via `hasattr(sub, 'sharpen')`
4. **Callable `sharpen`** via `callable(sub.sharpen)`

All conditions must be `True` for the class to be considered a subclass of `Sword`.

---

## Testing the Implementation

### Verification with issubclass and isinstance

```python
>>> from weapons import *
>>> issubclass(SamuraiSword, Sword)
True
>>> issubclass(Rifle, Sword)
False
>>> broad_sword = BroadSword()
>>> isinstance(broad_sword, Sword)
True
```

### Analysis of Results

**Successful Validations:**

- `SamuraiSword` is recognized as a subclass because it implements `swipe` and `sharpen`
- `BroadSword` instances pass `isinstance()` check due to protocol compliance

**Failed Validation:**

- `Rifle` is not a subclass because it lacks the required `swipe` and `sharpen` methods

**ABCMeta Coordination:**

- The `__subclasshook__()` class method works seamlessly with `ABCMeta`
- `ABCMeta` automatically delegates to `__subclasshook__()` for custom checks
- Both `issubclass()` and `isinstance()` work correctly without manual `__instancecheck__` implementation

---

## Advantages of abc Module

### Compared to Manual Implementation

**Reliability:**
- `ABCMeta` handles edge cases correctly
- Consistent `isinstance()` and `issubclass()` behavior
- Proven implementation used throughout Python standard library

**Maintainability:**
- Single `__subclasshook__()` method instead of two special methods
- Clear separation between ABC infrastructure and protocol definition
- Standard pattern recognized by Python developers

**Future Compatibility:**
- Additional features (like `@abstractmethod`) integrate seamlessly
- Standard library updates improve functionality automatically

---

## Summary

The `abc` module provides `ABCMeta`, a metaclass that implements reliable `__subclasscheck__` and `__instancecheck__` methods for abstract base classes. Instead of manually implementing these special methods, classes using `ABCMeta` define a `__subclasshook__()` class method that returns `True`, `False`, or `NotImplemented` to indicate subclass status. The `Sword` example demonstrates migrating from a custom metaclass to `ABCMeta` with `__subclasshook__()`, achieving the same protocol-based validation with less code and better reliability. This approach simplifies ABC implementation while maintaining full control over subclass validation logic.
