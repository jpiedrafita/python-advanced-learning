# 8.5 Method Resolution with Virtual Base Classes

## Key Ideas

- **Virtual Base Classes Excluded from MRO**: Unlike regular base classes, virtual base classes do not participate in method resolution order
- **No Method Inheritance**: Methods defined in virtual base classes are not accessible to virtual subclasses
- **AttributeError on Virtual Methods**: Attempting to call a virtual base class method raises `AttributeError`
- **super() Incompatibility**: The `super()` function cannot access virtual base class methods since it relies on the MRO

---

## Virtual Base Classes and Method Resolution Order

### Fundamental Limitation

Virtual base classes established through `__subclasscheck__` do not participate in Python's method resolution order (MRO). This is a critical distinction from traditional inheritance:

- **Regular base classes**: Appear in `__mro__` and contribute methods to subclasses
- **Virtual base classes**: Only affect `isinstance()` and `issubclass()` checks, not method lookup

---

## Demonstration with Sword Example

### Adding a Method to Virtual Base Class

```python
class Sword(metaclass=SwordMeta):

    def thrust(self):
        print("Thrusting...")
```

The `Sword` virtual base class now defines a `thrust()` method. Virtual subclasses can pass `isinstance()` checks but cannot access this method.

### Testing Method Resolution

```python
>>> from weapons import *
>>> broad_sword = BroadSword()
>>> isinstance(broad_sword, Sword)
True
>>> broad_sword.swipe()
Swoosh!
>>> broad_sword.thrust()
Traceback (most recent call last):
  File "<input>", line 1, in <module>
AttributeError: 'BroadSword' object has no attribute 'thrust'
>>> BroadSword.__mro__
(<class 'weapons.BroadSword'>, <class 'object'>)
```

### Analysis of Results

**Successful Operations:**
- `isinstance(broad_sword, Sword)` returns `True` due to custom `__subclasscheck__`
- `broad_sword.swipe()` works because `swipe` is defined in `BroadSword` itself

**Failed Operation:**
- `broad_sword.thrust()` raises `AttributeError` because `thrust` is not accessible
- `Sword` does not appear in `BroadSword.__mro__`
- The MRO only contains `BroadSword` and `object`

---

## Implications for super()

### Why super() Cannot Access Virtual Base Classes

The `super()` function works by searching through the method resolution order (`__mro__`). Since virtual base classes are not included in the MRO:

- `super()` cannot find methods defined in virtual base classes
- No cooperative multiple inheritance with virtual base classes
- Virtual inheritance is purely for type checking, not code reuse

### Comparison: Regular vs Virtual Inheritance

**Regular Inheritance:**
```python
class Base:
    def method(self):
        pass

class Derived(Base):
    pass

Derived.__mro__  # Contains Base
derived.method()  # Works
```

**Virtual Inheritance:**
```python
class VirtualBase(metaclass=CustomMeta):
    def method(self):
        pass

class VirtualDerived:
    pass

# Assuming CustomMeta makes VirtualDerived a virtual subclass
VirtualDerived.__mro__  # Does NOT contain VirtualBase
virtual_derived.method()  # AttributeError
```

---

## Summary

Virtual base classes serve exclusively as type markers for `isinstance()` and `issubclass()` checks and do not participate in method resolution. Methods defined in virtual base classes are inaccessible to virtual subclasses, as demonstrated by the `Sword` example where `thrust()` raises `AttributeError` despite `isinstance()` returning `True`. The exclusion of virtual base classes from the MRO also means `super()` cannot be used to access their methods, limiting virtual inheritance to protocol checking rather than code reuse.
