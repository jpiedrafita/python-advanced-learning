# 3.9 Attribute Lookup for Special Methods

## Key Ideas

- Special methods bypass `__getattribute__` when called through built-in functions
- `__getattribute__` only intercepts attribute lookup through the dot operator
- Built-in functions like `repr()`, `len()`, `iter()` bypass `__getattribute__` for performance
- Direct special method calls (e.g., `obj.__repr__()`) do go through `__getattribute__`
- Proxy classes must explicitly implement special methods to forward them properly
- This bypass behavior can make proxies "leaky" - some operations don't get forwarded

## The Special Method Bypass Problem

### Demonstrating the Issue

```python
>>> cv = ColoredVector(red=39, green=22, blue=89, s=45, t=12)
>>> cv
ColoredVector(red=39, green=22, blue=89, s=45, t=12)

>>> cw = LoggingProxy(cv)
>>> cw
<loggingproxy.LoggingProxy object at 0x10218ae10>
```

### Direct Special Method Call - Goes Through Proxy

```python
>>> cw.__repr__()

Retrieved attribute '__repr__' = <bound method ColoredVector.__repr__ of ColoredVector(red=39, green=22, blue=89, s=45, t=12)> from ColoredVector(red=39, green=22, blue=89, s=45, t=12)
'ColoredVector(red=39, green=22, blue=89, s=45, t=12)'
```

### Built-in Function Call - Bypasses Proxy

```python
>>> repr(cw)

'<loggingproxy.LoggingProxy object at 0x10218ae10>'
```

## Why This Happens

**`__getattribute__` only intercepts dot operator access:**
- `obj.attribute` → calls `__getattribute__`
- `obj.__repr__()` → calls `__getattribute__` to find `__repr__`

**Built-in functions bypass `__getattribute__`:**
- `repr(obj)` → Python looks for `__repr__` directly on the class
- `len(obj)` → Python looks for `__len__` directly on the class  
- `iter(obj)` → Python looks for `__iter__` directly on the class

This bypass is done for **performance reasons** - special methods are called frequently and need to be fast.

## Solution: Implement Forwarding Special Methods

### Forwarding `__repr__`

```python
def __repr__(self):
    target = super().__getattribute__('target')
    repr_callable = getattr(target, '__repr__')
    return repr_callable()
```

### Testing the Solution

```python
>>> cv = ColoredVector(red=39, green=22, blue=89, s=45, t=12)
>>> cw = LoggingProxy(cv)
>>> repr(cw)  # Now works correctly

'ColoredVector(red=39, green=22, blue=89, s=45, t=12)'

>>> cw  # Also works in REPL display
ColoredVector(red=39, green=22, blue=89, s=45, t=12)
```

## Complete Proxy with Common Special Methods

```python
class TransparentLoggingProxy:
    """LoggingProxy that forwards common special methods."""
    
    def __init__(self, target):
        super().__setattr__('target', target)

    def __getattribute__(self, name):
        target = super().__getattribute__('target')
        try:
            value = getattr(target, name)
        except AttributeError as e:
            raise AttributeError(f"LoggingProxy could not forward request {name} to {target}") from e
        print(f"Retrieved attribute {name!r} = {value!r} from {target!r}")
        return value

    def __setattr__(self, name, value):
        if name == 'target':
            super().__setattr__(name, value)
            return
        target = super().__getattribute__('target')
        try:
            setattr(target, name, value)
        except AttributeError as e:
            raise AttributeError(f"LoggingProxy could not forward request {name} to {target}") from e
        print(f"Set attribute {name!r} = {value!r} on {target!r}")

    # Forward common special methods
    def __repr__(self):
        target = super().__getattribute__('target')
        return getattr(target, '__repr__')()

    def __str__(self):
        target = super().__getattribute__('target')
        return getattr(target, '__str__')()

    def __len__(self):
        target = super().__getattribute__('target')
        return getattr(target, '__len__')()

    def __iter__(self):
        target = super().__getattribute__('target')
        return getattr(target, '__iter__')()

    def __bool__(self):
        target = super().__getattribute__('target')
        return getattr(target, '__bool__')()
```

## The Trade-off: Transparency vs Debugging

### Problem with Complete Transparency

When the proxy becomes completely transparent, it can hinder debugging:

```python
>>> cw = TransparentLoggingProxy(cv)
>>> cw
ColoredVector(red=39, green=22, blue=89, s=45, t=12)  # Looks like original object
>>> type(cw)
<class '__main__.TransparentLoggingProxy'>  # But it's actually a proxy
```

### Alternative: Debugging-Friendly Repr

```python
class DebuggableLoggingProxy(LoggingProxy):
    """Proxy that shows both proxy and target information."""
    
    def __repr__(self):
        target = super().__getattribute__('target')
        target_repr = getattr(target, '__repr__')()
        return f"LoggingProxy({target_repr})"
```

```python
>>> debug_proxy = DebuggableLoggingProxy(cv)
>>> debug_proxy
LoggingProxy(ColoredVector(red=39, green=22, blue=89, s=45, t=12))
```

## Which Special Methods Need Forwarding?

**Most commonly needed:**
- `__repr__` - String representation
- `__str__` - User-friendly string
- `__len__` - Length for `len()`
- `__bool__` - Truth value for `bool()`
- `__iter__` - Iteration support

**Arithmetic operations (if target supports them):**
- `__add__`, `__sub__`, `__mul__`, `__div__`
- `__eq__`, `__lt__`, `__gt__` (comparison)

**Container operations (if target is container-like):**
- `__getitem__`, `__setitem__`, `__delitem__`
- `__contains__` - For `in` operator

## Testing Special Method Forwarding

```python
# Test with a container-like object
class SimpleList:
    def __init__(self, items):
        self.items = list(items)
    
    def __len__(self):
        return len(self.items)
    
    def __repr__(self):
        return f"SimpleList({self.items})"
    
    def __iter__(self):
        return iter(self.items)

>>> sl = SimpleList([1, 2, 3])
>>> proxy = TransparentLoggingProxy(sl)

>>> len(proxy)  # Works with __len__ forwarding
3

>>> list(proxy)  # Works with __iter__ forwarding  
[1, 2, 3]

>>> repr(proxy)  # Works with __repr__ forwarding
'SimpleList([1, 2, 3])'
```

## Key Takeaways

- **Special method bypass**: Built-in functions bypass `__getattribute__` for performance
- **Proxy limitation**: `__getattribute__` alone cannot create fully transparent proxies  
- **Explicit forwarding**: Must implement each special method individually in proxy classes
- **Design choice**: Balance between transparency and debuggability
- **Performance reason**: Python optimizes special method lookup for speed
- **Common oversight**: Many proxy implementations forget to forward special methods
- **Testing importance**: Always test proxies with built-in functions, not just direct method calls
