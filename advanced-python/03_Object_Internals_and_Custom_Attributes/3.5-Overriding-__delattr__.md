# 3.5 Overriding `__delattr__`

## Key Ideas

- Attribute deletion is rarely used in Python but is supported through `del` and `delattr()`
- `__delattr__` allows customization of attribute deletion behavior
- Immutable classes should prevent attribute deletion to maintain integrity
- Both `del obj.attr` and `delattr(obj, 'attr')` trigger `__delattr__`
- Consistent error handling across `__setattr__` and `__delattr__` improves API design
- Attribute deletion control is essential for creating truly immutable objects

## Understanding Attribute Deletion in Python

### Default Deletion Behavior

By default, Python allows deletion of object attributes:

```python
class SimpleVector:
    def __init__(self, **coords):
        for name, value in coords.items():
            setattr(self, name, value)

# Default behavior allows deletion
>>> v = SimpleVector(x=1, y=2, z=3)
>>> v.x, v.y, v.z
(1, 2, 3)
>>> del v.x  # Using del statement
>>> delattr(v, 'y')  # Using delattr() function
>>> v.z
3
>>> hasattr(v, 'x')  # x is gone
False
>>> hasattr(v, 'y')  # y is gone
False
```

### Internal Storage and Deletion

```python
class InternalVector:
    def __init__(self, **coords):
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

# Direct access to internal storage
>>> v = InternalVector(p=1, q=2)
>>> v.__dict__
{'_p': 1, '_q': 2}
>>> dir(v)  # Shows all available attributes
['__class__', '__delattr__', '__dict__', '__doc__', ..., '_p', '_q']

# Can delete internal attributes directly
>>> delattr(v, '_p')  # Delete using delattr()
>>> del v._q         # Delete using del statement
>>> v.__dict__
{}  # Now empty
```

## Implementing `__delattr__` for Immutability

### Basic Implementation

```python
class ImmutableVector:
    def __init__(self, **coords):
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def __getattr__(self, name):
        private_name = '_' + name
        try:
            return self.__dict__[private_name]
        except KeyError:
            raise AttributeError('{!r} object has no attribute {!r}'.format(
                self.__class__, name))

    def __setattr__(self, name, value):
        raise AttributeError("Can't set attribute {!r}".format(name))

    def __delattr__(self, name):
        raise AttributeError("Can't delete attribute {!r}".format(name))

    def __repr__(self):
        return "{}({})".format(
            self.__class__.__name__,
            ', '.join("{}={}".format(k[1:], self.__dict__[k])
                     for k in sorted(self.__dict__.keys()))
        )
```

### Testing Deletion Prevention

```python
>>> v = ImmutableVector(p=9, q=12)
>>> v
ImmutableVector(p=9, q=12)
>>> v.p, v.q
(9, 12)

# Attempting to delete public interface
>>> del v.q
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "vector.py", line 15, in __delattr__
    raise AttributeError("Can't delete attribute {!r}".format(name))
AttributeError: Can't delete attribute 'q'

# Attempting to delete private attributes
>>> delattr(v, '_p')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "vector.py", line 15, in __delattr__
    raise AttributeError("Can't delete attribute {!r}".format(name))
AttributeError: Can't delete attribute '_p'
```

## Advanced `__delattr__` Implementations

### Selective Deletion Control

```python
class SelectiveVector:
    def __init__(self, **coords):
        self._protected = set()
        self._coords = coords.keys()
        
        # Store coordinates
        for name, value in coords.items():
            self.__dict__['_' + name] = value
            
    def protect(self, *names):
        """Mark attributes as protected from deletion."""
        self._protected.update(names)
        
    def unprotect(self, *names):
        """Remove protection from attributes."""
        self._protected.difference_update(names)

    def __getattr__(self, name):
        private_name = '_' + name
        try:
            return self.__dict__[private_name]
        except KeyError:
            raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, name, value):
        # Allow internal attributes during initialization
        if name.startswith('_'):
            self.__dict__[name] = value
        else:
            raise AttributeError(f"Can't set attribute '{name}'")

    def __delattr__(self, name):
        # Check if attribute is protected
        if name in self._protected or name.lstrip('_') in self._protected:
            raise AttributeError(f"Can't delete protected attribute '{name}'")
        
        # Check if it exists
        if name.startswith('_'):
            target = name
        else:
            target = '_' + name
            
        if target not in self.__dict__:
            raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")
            
        # Allow deletion
        del self.__dict__[target]

    def __repr__(self):
        coords = []
        for key in sorted(self.__dict__.keys()):
            if key.startswith('_') and not key.startswith('__') and key[1:] in self._coords:
                coords.append(f"{key[1:]}={self.__dict__[key]}")
        return f"{self.__class__.__name__}({', '.join(coords)})"

# Usage example
>>> v = SelectiveVector(x=1, y=2, z=3)
>>> v.protect('x', 'y')  # Protect x and y from deletion
>>> del v.z  # Allowed
>>> v
SelectiveVector(x=1, y=2)
>>> del v.x  # Protected
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: Can't delete protected attribute 'x'
```

### Logging Deletion Attempts

```python
import logging
from datetime import datetime

class LoggingVector:
    def __init__(self, **coords):
        self._deletion_log = []
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def __getattr__(self, name):
        private_name = '_' + name
        try:
            return self.__dict__[private_name]
        except KeyError:
            raise AttributeError(f"No attribute '{name}'")

    def __setattr__(self, name, value):
        if name.startswith('_'):
            self.__dict__[name] = value
        else:
            raise AttributeError(f"Can't set attribute '{name}'")

    def __delattr__(self, name):
        # Log the deletion attempt
        timestamp = datetime.now().isoformat()
        self._deletion_log.append({
            'timestamp': timestamp,
            'attribute': name,
            'action': 'deletion_attempted'
        })
        
        # Prevent deletion
        raise AttributeError(f"Can't delete attribute '{name}' (attempt logged)")

    def get_deletion_log(self):
        """Return log of all deletion attempts."""
        return self._deletion_log.copy()

    def __repr__(self):
        coords = [f"{k[1:]}={self.__dict__[k]}" 
                 for k in sorted(self.__dict__.keys()) 
                 if k.startswith('_') and not k.startswith('__') and k != '_deletion_log']
        return f"{self.__class__.__name__}({', '.join(coords)})"

# Usage with logging
>>> v = LoggingVector(x=1, y=2)
>>> del v.x  # This will be logged
Traceback (most recent call last):
AttributeError: Can't delete attribute 'x' (attempt logged)
>>> del v.y  # This will also be logged
Traceback (most recent call last):
AttributeError: Can't delete attribute 'y' (attempt logged)
>>> v.get_deletion_log()
[{'timestamp': '2025-10-12T10:30:45.123456', 'attribute': 'x', 'action': 'deletion_attempted'},
 {'timestamp': '2025-10-12T10:30:47.654321', 'attribute': 'y', 'action': 'deletion_attempted'}]
```

## Deletion vs Assignment Consistency

### Coordinated Behavior

```python
class ConsistentVector:
    def __init__(self, **coords):
        self._frozen = False
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)
        self._frozen = True  # Freeze after initialization

    def __getattr__(self, name):
        private_name = '_' + name
        try:
            return self.__dict__[private_name]
        except KeyError:
            raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, name, value):
        if not getattr(self, '_frozen', False):
            # Allow setting during initialization
            self.__dict__[name] = value
        else:
            # Prevent modification after initialization
            raise AttributeError(f"'{self.__class__.__name__}' object is immutable. Can't set attribute '{name}'")

    def __delattr__(self, name):
        if not getattr(self, '_frozen', False):
            # Allow deletion during initialization (unlikely but consistent)
            if name in self.__dict__:
                del self.__dict__[name]
            else:
                raise AttributeError(f"No attribute '{name}'")
        else:
            # Prevent deletion after initialization
            raise AttributeError(f"'{self.__class__.__name__}' object is immutable. Can't delete attribute '{name}'")

    def __repr__(self):
        coords = [f"{k[1:]}={self.__dict__[k]}" 
                 for k in sorted(self.__dict__.keys()) 
                 if k.startswith('_') and not k.startswith('__') and k != '_frozen']
        return f"{self.__class__.__name__}({', '.join(coords)})"
```

### Testing Consistent Behavior

```python
>>> v = ConsistentVector(x=10, y=20)
>>> v.x, v.y
(10, 20)

# Both operations prevented with consistent messages
>>> v.x = 100
Traceback (most recent call last):
AttributeError: 'ConsistentVector' object is immutable. Can't set attribute 'x'

>>> del v.x
Traceback (most recent call last):
AttributeError: 'ConsistentVector' object is immutable. Can't delete attribute 'x'
```

## Handling Special Cases

### Dealing with Non-Existent Attributes

```python
class RobustVector:
    def __init__(self, **coords):
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def __getattr__(self, name):
        private_name = '_' + name
        try:
            return self.__dict__[private_name]
        except KeyError:
            raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, name, value):
        raise AttributeError(f"Can't set attribute '{name}'")

    def __delattr__(self, name):
        # Check if we're trying to delete a coordinate
        private_name = '_' + name
        if private_name in self.__dict__:
            raise AttributeError(f"Can't delete coordinate '{name}'")
        elif name in self.__dict__:
            raise AttributeError(f"Can't delete attribute '{name}'")
        else:
            # Mimic Python's default behavior for non-existent attributes
            raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __repr__(self):
        coords = [f"{k[1:]}={self.__dict__[k]}" 
                 for k in sorted(self.__dict__.keys()) 
                 if k.startswith('_') and not k.startswith('__')]
        return f"{self.__class__.__name__}({', '.join(coords)})"

# Testing various deletion scenarios
>>> v = RobustVector(x=1, y=2)
>>> del v.x  # Existing coordinate
Traceback (most recent call last):
AttributeError: Can't delete coordinate 'x'

>>> del v.z  # Non-existent coordinate
Traceback (most recent call last):
AttributeError: 'RobustVector' object has no attribute 'z'
```

## Performance Considerations

### Benchmarking Deletion Prevention

```python
import timeit

class SimpleVector:
    def __init__(self, **coords):
        for k, v in coords.items():
            setattr(self, k, v)

class ProtectedVector:
    def __init__(self, **coords):
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def __delattr__(self, name):
        raise AttributeError(f"Can't delete attribute '{name}'")

# Benchmark deletion attempts
simple = SimpleVector(x=1, y=2, z=3)
protected = ProtectedVector(x=1, y=2, z=3)

def try_delete_simple():
    try:
        del simple.w  # Non-existent attribute
    except AttributeError:
        pass

def try_delete_protected():
    try:
        del protected.x  # Existing attribute, but protected
    except AttributeError:
        pass

simple_time = timeit.timeit(try_delete_simple, number=100000)
protected_time = timeit.timeit(try_delete_protected, number=100000)

print(f"Simple (non-existent): {simple_time:.4f}s")
print(f"Protected (existing): {protected_time:.4f}s")
```

## Integration with Descriptor Protocol

### Coordinated Attribute Control

```python
class CoordinateDescriptor:
    def __init__(self, name):
        self.name = name
        self.private_name = '_' + name

    def __get__(self, instance, owner):
        if instance is None:
            return self
        return getattr(instance, self.private_name)

    def __set__(self, instance, value):
        raise AttributeError(f"Can't set coordinate '{self.name}'")

    def __delete__(self, instance):
        raise AttributeError(f"Can't delete coordinate '{self.name}'")

class DescriptorVector:
    def __init__(self, **coords):
        # Set up descriptors for each coordinate
        for name in coords:
            setattr(type(self), name, CoordinateDescriptor(name))
            setattr(self, '_' + name, coords[name])

    def __delattr__(self, name):
        # Handle deletion of non-descriptor attributes
        if hasattr(type(self), name) and isinstance(getattr(type(self), name), CoordinateDescriptor):
            # Let the descriptor handle it
            delattr(type(self), name)
        else:
            raise AttributeError(f"Can't delete attribute '{name}'")

# The descriptor handles coordinate deletion
>>> v = DescriptorVector(x=1, y=2)
>>> del v.x  # Descriptor prevents this
Traceback (most recent call last):
AttributeError: Can't delete coordinate 'x'
```

## Common Patterns and Best Practices

### Pattern 1: Complete Immutability

```python
class ImmutablePoint:
    def __init__(self, x, y):
        self._x = x
        self._y = y

    @property
    def x(self):
        return self._x

    @property
    def y(self):
        return self._y

    def __setattr__(self, name, value):
        if hasattr(self, '_x'):  # After initialization
            raise AttributeError(f"'{self.__class__.__name__}' object is immutable")
        super().__setattr__(name, value)

    def __delattr__(self, name):
        raise AttributeError(f"'{self.__class__.__name__}' object is immutable")

    def __repr__(self):
        return f"{self.__class__.__name__}(x={self.x}, y={self.y})"
```

### Pattern 2: Controlled Mutability

```python
class ControlledVector:
    def __init__(self, **coords):
        self._mutable = True
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def freeze(self):
        """Make the vector immutable."""
        self._mutable = False

    def unfreeze(self):
        """Make the vector mutable again."""
        self._mutable = True

    def __setattr__(self, name, value):
        if name.startswith('_'):
            self.__dict__[name] = value
        elif getattr(self, '_mutable', True):
            self.__dict__['_' + name] = value
        else:
            raise AttributeError(f"Vector is frozen. Can't set '{name}'")

    def __delattr__(self, name):
        if not getattr(self, '_mutable', True):
            raise AttributeError(f"Vector is frozen. Can't delete '{name}'")
        
        target = '_' + name if not name.startswith('_') else name
        if target in self.__dict__:
            del self.__dict__[target]
        else:
            raise AttributeError(f"No attribute '{name}'")
```

### Pattern 3: Audit Trail

```python
class AuditVector:
    def __init__(self, **coords):
        self._audit_log = []
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def _log_action(self, action, attribute, details=None):
        """Log an action for audit purposes."""
        entry = {
            'timestamp': datetime.now().isoformat(),
            'action': action,
            'attribute': attribute
        }
        if details:
            entry['details'] = details
        self._audit_log.append(entry)

    def __delattr__(self, name):
        self._log_action('delete_attempted', name, {'prevented': True})
        raise AttributeError(f"Deletion not allowed for attribute '{name}' (logged)")

    def get_audit_log(self):
        return self._audit_log.copy()
```

## Error Handling Best Practices

### Informative Error Messages

```python
class WellDocumentedVector:
    def __init__(self, **coords):
        self._coordinates = set(coords.keys())
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def __delattr__(self, name):
        if name.lstrip('_') in self._coordinates:
            raise AttributeError(
                f"Cannot delete coordinate '{name.lstrip('_')}'. "
                f"{self.__class__.__name__} objects are immutable. "
                f"Create a new instance instead."
            )
        else:
            raise AttributeError(
                f"'{self.__class__.__name__}' object has no attribute '{name}'. "
                f"Available coordinates: {', '.join(sorted(self._coordinates))}"
            )
```

### Debugging Support

```python
class DebuggableVector:
    def __init__(self, **coords, debug=False):
        self._debug = debug
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def __delattr__(self, name):
        if self._debug:
            print(f"DEBUG: Deletion attempt for attribute '{name}'")
            print(f"DEBUG: Available attributes: {list(self.__dict__.keys())}")
        
        raise AttributeError(f"Can't delete attribute '{name}'")
```

## Key Takeaways

- **Immutability Control**: `__delattr__` is essential for creating truly immutable objects
- **Consistency**: Coordinate `__delattr__` behavior with `__setattr__` for coherent APIs
- **Error Messages**: Provide clear, informative error messages that guide users
- **Selective Control**: Consider allowing different deletion policies for different attributes
- **Performance**: `__delattr__` overhead is minimal for prevention-only implementations
- **Integration**: Works well with descriptors and properties for comprehensive attribute control
- **Audit Capabilities**: Can be used for logging and debugging attribute access patterns
- **Design Philosophy**: Attribute deletion is rare in Python, so prevention is usually the right choice for immutable classes