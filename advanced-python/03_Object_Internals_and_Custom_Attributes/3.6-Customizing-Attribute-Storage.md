# 3.6 Customizing Attribute Storage

## Key Ideas

- Attributes don't have to be stored directly in `__dict__` - custom storage is possible
- Different attribute groups can use different storage mechanisms within the same object
- `__getattr__` and `__setattr__` enable transparent access to custom storage
- Inheritance complications arise when base classes make assumptions about `__dict__` contents
- Proper fallback to superclass methods is essential for attribute delegation
- Custom storage enables efficient data organization and specialized data structures
- Design for inheritance requires careful consideration of base class assumptions

## Understanding Custom Attribute Storage

### Traditional vs Custom Storage

**Traditional Storage** (direct in `__dict__`):
```python
class TraditionalVector:
    def __init__(self, x, y, z):
        self.x = x  # Stored as __dict__['x']
        self.y = y  # Stored as __dict__['y'] 
        self.z = z  # Stored as __dict__['z']

>>> v = TraditionalVector(1, 2, 3)
>>> v.__dict__
{'x': 1, 'y': 2, 'z': 3}
```

**Custom Storage** (organized differently):
```python
class CustomVector:
    def __init__(self, x, y, z):
        self.__dict__['coords'] = [x, y, z]  # All coordinates in one list
        
    def __getattr__(self, name):
        coord_names = ['x', 'y', 'z']
        if name in coord_names:
            return self.__dict__['coords'][coord_names.index(name)]
        raise AttributeError(f"No attribute '{name}'")

>>> v = CustomVector(1, 2, 3)
>>> v.__dict__
{'coords': [1, 2, 3]}
>>> v.x, v.y, v.z  # Still accessible as attributes
(1, 2, 3)
```

## Implementing ColoredVector with Custom Storage

### Base Vector Class (for reference)

```python
class Vector:
    def __init__(self, **coords):
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def __getattr__(self, name):
        private_name = '_' + name
        try:
            return self.__dict__[private_name]
        except KeyError:
            raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, name, value):
        raise AttributeError(f"Can't set attribute '{name}'")

    def __delattr__(self, name):
        raise AttributeError(f"Can't delete attribute '{name}'")

    def __repr__(self):
        return "{}({})".format(
            self.__class__.__name__,
            ', '.join("{}={}".format(k[1:], self.__dict__[k])
                     for k in sorted(self.__dict__.keys()))
        )
```

### ColoredVector Implementation

```python
class ColoredVector(Vector):
    COLOR_INDEXES = ('red', 'green', 'blue')

    def __init__(self, red, green, blue, **coords):
        super().__init__(**coords)  # Initialize vector components
        self.__dict__['color'] = [red, green, blue]  # Custom storage for colors

    def __getattr__(self, name):
        try:
            # Check if this is a color channel request
            channel = ColoredVector.COLOR_INDEXES.index(name)
        except ValueError:
            # Not a color channel, delegate to parent
            return super().__getattr__(name)
        else:
            # Return color channel from custom storage
            return self.__dict__['color'][channel]

    def __setattr__(self, name, value):
        try:
            # Check if this is a color channel assignment
            channel = ColoredVector.COLOR_INDEXES.index(name)
        except ValueError:
            # Not a color channel, delegate to parent
            super().__setattr__(name, value)
        else:
            # Set color channel in custom storage
            self.__dict__['color'][channel] = value
```

### Testing the Implementation

```python
>>> cv = ColoredVector(red=23, green=44, blue=238, p=9, q=14)

# Access color channels (stored in list)
>>> cv.red
23
>>> cv.green  
44
>>> cv.blue
238

# Access vector components (stored as _p, _q)
>>> cv.p
9
>>> cv.q
14

# Examine internal storage
>>> cv.__dict__
{'_p': 9, '_q': 14, 'color': [23, 44, 238]}

# See all attributes
>>> dir(cv)
['COLOR_INDEXES', '__class__', '__delattr__', '__dict__', '__doc__', 
 '__getattr__', '__init__', '__repr__', '__setattr__', 
 '_p', '_q', 'color']
```

## The `__repr__` Problem

### What Goes Wrong

The base class `__repr__` assumes all attributes follow the `_name` pattern:

```python
# Base class __repr__ implementation
def __repr__(self):
    return "{}({})".format(
        self.__class__.__name__,
        ', '.join("{}={}".format(k[1:], self.__dict__[k])  # Assumes k[1:] valid
                 for k in sorted(self.__dict__.keys()))
    )

# What happens with ColoredVector
>>> cv = ColoredVector(red=23, green=44, blue=238, p=9, q=14)
>>> cv
ColoredVector(p=9, q=14, olor=[23, 44, 238])  # 'color'[1:] = 'olor' - WRONG!
```

### The Problem Analysis

```python
# Step by step what happens:
>>> cv.__dict__.keys()
dict_keys(['_p', '_q', 'color'])

# Base class __repr__ processes each key:
# '_p'[1:] = 'p' ✓ (correct)
# '_q'[1:] = 'q' ✓ (correct)  
# 'color'[1:] = 'olor' ✗ (wrong!)

# Result: "ColoredVector(p=9, q=14, olor=[23, 44, 238])"
```

## Solutions to the Inheritance Problem

### Solution 1: Override `__repr__` in Subclass

```python
class ColoredVector(Vector):
    COLOR_INDEXES = ('red', 'green', 'blue')

    def __init__(self, red, green, blue, **coords):
        super().__init__(**coords)
        self.__dict__['color'] = [red, green, blue]

    def __getattr__(self, name):
        try:
            channel = ColoredVector.COLOR_INDEXES.index(name)
        except ValueError:
            return super().__getattr__(name)
        else:
            return self.__dict__['color'][channel]

    def __setattr__(self, name, value):
        try:
            channel = ColoredVector.COLOR_INDEXES.index(name)
        except ValueError:
            super().__setattr__(name, value)
        else:
            self.__dict__['color'][channel] = value

    def __repr__(self):
        # Filter out 'color' key and process remaining keys like base class
        keys = set(self.__dict__.keys())
        keys.discard('color')  # Remove 'color' from processing
        
        coords = ', '.join(
            "{}={}".format(k[1:], self.__dict__[k])
            for k in sorted(keys)
        )

        return "{cls}({red}, {green}, {blue}, {coords})".format(
            cls=self.__class__.__name__,
            red=self.red,    # Uses __getattr__
            green=self.green, # Uses __getattr__
            blue=self.blue,   # Uses __getattr__
            coords=coords
        )

# Now works correctly
>>> cv = ColoredVector(red=23, green=44, blue=238, p=9, q=14)
>>> cv
ColoredVector(23, 44, 238, p=9, q=14)
```

### Solution 2: Redesign Base Class for Better Inheritance

```python
class ImprovedVector:
    def __init__(self, **coords):
        # Store coordinates in dedicated dictionary
        self.__dict__['_coordinates'] = coords.copy()

    def __getattr__(self, name):
        try:
            return self.__dict__['_coordinates'][name]
        except KeyError:
            raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, name, value):
        raise AttributeError(f"Can't set attribute '{name}'")

    def __delattr__(self, name):
        raise AttributeError(f"Can't delete attribute '{name}'")

    def __repr__(self):
        coords = ', '.join("{}={}".format(k, v) 
                          for k, v in sorted(self.__dict__['_coordinates'].items()))
        return f"{self.__class__.__name__}({coords})"

class BetterColoredVector(ImprovedVector):
    COLOR_INDEXES = ('red', 'green', 'blue')

    def __init__(self, red, green, blue, **coords):
        super().__init__(**coords)
        self.__dict__['_colors'] = [red, green, blue]

    def __getattr__(self, name):
        try:
            channel = self.COLOR_INDEXES.index(name)
            return self.__dict__['_colors'][channel]
        except ValueError:
            return super().__getattr__(name)

    def __repr__(self):
        # Base class handles coordinates correctly
        base_repr = super().__repr__()
        # Extract just the coordinates part
        coords_part = base_repr[base_repr.find('(')+1:base_repr.rfind(')')]
        return f"{self.__class__.__name__}({self.red}, {self.green}, {self.blue}, {coords_part})"
```

### Solution 3: Composition Over Inheritance

```python
class ColoredVector:
    """A vector with color using composition instead of inheritance."""
    
    def __init__(self, red, green, blue, **coords):
        self._vector = Vector(**coords)  # Compose instead of inherit
        self._colors = {'red': red, 'green': green, 'blue': blue}

    def __getattr__(self, name):
        # Try colors first
        if name in self._colors:
            return self._colors[name]
        # Then delegate to vector
        return getattr(self._vector, name)

    def __setattr__(self, name, value):
        if name.startswith('_'):
            # Allow internal attributes
            super().__setattr__(name, value)
        elif name in ['red', 'green', 'blue']:
            # Handle color attributes
            if hasattr(self, '_colors'):
                self._colors[name] = value
            else:
                super().__setattr__(name, value)
        else:
            # Delegate to vector
            setattr(self._vector, name, value)

    def __repr__(self):
        vector_coords = str(self._vector)[7:-1]  # Extract coordinates from "Vector(...)"
        return f"ColoredVector({self.red}, {self.green}, {self.blue}, {vector_coords})"

# Usage is the same but implementation is cleaner
>>> cv = ColoredVector(red=255, green=128, blue=64, x=10, y=20)
>>> cv
ColoredVector(255, 128, 64, x=10, y=20)
```

## Advanced Custom Storage Patterns

### Pattern 1: Hierarchical Storage

```python
class HierarchicalObject:
    """Demonstrates nested custom storage."""
    
    def __init__(self):
        self.__dict__['_storage'] = {
            'metadata': {},
            'coordinates': {},
            'properties': {}
        }

    def set_metadata(self, key, value):
        self.__dict__['_storage']['metadata'][key] = value

    def set_coordinate(self, name, value):
        self.__dict__['_storage']['coordinates'][name] = value

    def set_property(self, name, value):
        self.__dict__['_storage']['properties'][name] = value

    def __getattr__(self, name):
        storage = self.__dict__['_storage']
        
        # Search in each storage compartment
        for compartment in ['metadata', 'coordinates', 'properties']:
            if name in storage[compartment]:
                return storage[compartment][name]
                
        raise AttributeError(f"No attribute '{name}'")

    def __setattr__(self, name, value):
        if name.startswith('_'):
            self.__dict__[name] = value
        else:
            # Default to properties compartment
            self.__dict__['_storage']['properties'][name] = value

# Usage
>>> obj = HierarchicalObject()
>>> obj.set_metadata('version', '1.0')
>>> obj.set_coordinate('x', 100)
>>> obj.name = 'test'  # Goes to properties
>>> obj.version, obj.x, obj.name
('1.0', 100, 'test')
```

### Pattern 2: Array-Based Storage

```python
class ArrayVector:
    """Store all data in a single array for memory efficiency."""
    
    COORD_NAMES = ['x', 'y', 'z', 'w']
    
    def __init__(self, **coords):
        # Initialize array with zeros
        self.__dict__['_data'] = [0.0] * len(self.COORD_NAMES)
        
        # Set provided coordinates
        for name, value in coords.items():
            if name in self.COORD_NAMES:
                index = self.COORD_NAMES.index(name)
                self.__dict__['_data'][index] = value

    def __getattr__(self, name):
        try:
            index = self.COORD_NAMES.index(name)
            return self.__dict__['_data'][index]
        except ValueError:
            raise AttributeError(f"No attribute '{name}'")

    def __setattr__(self, name, value):
        if name.startswith('_'):
            self.__dict__[name] = value
        else:
            try:
                index = self.COORD_NAMES.index(name)
                self.__dict__['_data'][index] = value
            except ValueError:
                raise AttributeError(f"Can't set attribute '{name}'")

    def __repr__(self):
        coords = []
        for i, name in enumerate(self.COORD_NAMES):
            if self.__dict__['_data'][i] != 0.0:
                coords.append(f"{name}={self.__dict__['_data'][i]}")
        return f"{self.__class__.__name__}({', '.join(coords)})"

# Usage
>>> av = ArrayVector(x=1, y=2, z=3)
>>> av.__dict__
{'_data': [1, 2, 3, 0.0]}
>>> av.x, av.y, av.z, av.w
(1, 2, 3, 0.0)
```

### Pattern 3: Database-Backed Storage

```python
class DatabaseVector:
    """Attributes stored in a simple in-memory database."""
    
    _database = {}  # Shared storage across instances
    _next_id = 1
    
    def __init__(self, **coords):
        # Get unique ID for this instance
        self.__dict__['_instance_id'] = DatabaseVector._next_id
        DatabaseVector._next_id += 1
        
        # Initialize database entry
        DatabaseVector._database[self._instance_id] = coords.copy()

    def __getattr__(self, name):
        try:
            return DatabaseVector._database[self._instance_id][name]
        except KeyError:
            raise AttributeError(f"No attribute '{name}'")

    def __setattr__(self, name, value):
        if name.startswith('_'):
            self.__dict__[name] = value
        else:
            DatabaseVector._database[self._instance_id][name] = value

    def __delattr__(self, name):
        try:
            del DatabaseVector._database[self._instance_id][name]
        except KeyError:
            raise AttributeError(f"No attribute '{name}'")

    def __repr__(self):
        data = DatabaseVector._database[self._instance_id]
        coords = ', '.join(f"{k}={v}" for k, v in sorted(data.items()))
        return f"{self.__class__.__name__}({coords})"

    @classmethod
    def get_all_data(cls):
        """Debug method to see all stored data."""
        return cls._database.copy()

# Usage
>>> dv1 = DatabaseVector(x=1, y=2)
>>> dv2 = DatabaseVector(a=10, b=20)
>>> dv1.x, dv2.a
(1, 10)
>>> DatabaseVector.get_all_data()
{1: {'x': 1, 'y': 2}, 2: {'a': 10, 'b': 20}}
```

## Performance Considerations

### Memory Usage Comparison

```python
import sys

class TraditionalVector:
    def __init__(self, x, y, z):
        self.x = x
        self.y = y  
        self.z = z

class ArrayVector:
    def __init__(self, x, y, z):
        self.__dict__['coords'] = [x, y, z]
        
    def __getattr__(self, name):
        names = ['x', 'y', 'z']
        return self.__dict__['coords'][names.index(name)]

# Compare memory usage
tv = TraditionalVector(1, 2, 3)
av = ArrayVector(1, 2, 3)

print("Traditional __dict__:", sys.getsizeof(tv.__dict__))
print("Array __dict__:", sys.getsizeof(av.__dict__))
print("Traditional total:", sys.getsizeof(tv) + sys.getsizeof(tv.__dict__))
print("Array total:", sys.getsizeof(av) + sys.getsizeof(av.__dict__) + sys.getsizeof(av.__dict__['coords']))
```

### Access Speed Benchmark

```python
import timeit

class DirectAccess:
    def __init__(self):
        self.x = 42

class CustomAccess:
    def __init__(self):
        self.__dict__['data'] = {'x': 42}
        
    def __getattr__(self, name):
        return self.__dict__['data'][name]

direct = DirectAccess()
custom = CustomAccess()

# Benchmark attribute access
direct_time = timeit.timeit(lambda: direct.x, number=1000000)
custom_time = timeit.timeit(lambda: custom.x, number=1000000)

print(f"Direct access: {direct_time:.4f}s")
print(f"Custom access: {custom_time:.4f}s") 
print(f"Slowdown: {custom_time/direct_time:.1f}x")
```

## Design Guidelines for Custom Storage

### When to Use Custom Storage

**Good Use Cases:**
- Memory optimization for objects with many instances
- Specialized data structures (arrays, trees, databases)
- Transparent persistence or caching
- Attribute validation or transformation
- Legacy system integration

**Poor Use Cases:**
- Simple objects with few attributes
- When inheritance from existing classes is required
- Performance-critical code without proven benefits

### Best Practices

**1. Consistent Interface**
```python
class ConsistentCustomStorage:
    def __getattr__(self, name):
        # Always provide consistent attribute access
        return self._get_from_storage(name)
    
    def __setattr__(self, name, value):
        # Always provide consistent attribute setting
        if name.startswith('_'):
            super().__setattr__(name, value)
        else:
            self._set_in_storage(name, value)
```

**2. Proper Error Handling**
```python
def __getattr__(self, name):
    try:
        return self._storage[name]
    except KeyError:
        # Convert to standard AttributeError
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")
```

**3. Documentation**
```python
class DocumentedCustomStorage:
    """
    Custom storage implementation details:
    - Attributes stored in self._storage dictionary
    - Access through __getattr__/__setattr__
    - Internal attributes (starting with _) stored normally
    """
    pass
```

## Common Pitfalls and Solutions

### Pitfall 1: Infinite Recursion in Storage Access

```python
# WRONG - Can cause infinite recursion
class BadCustomStorage:
    def __getattr__(self, name):
        if not hasattr(self, '_storage'):  # This calls __getattr__ again!
            self._storage = {}
        return self._storage[name]

# CORRECT - Use __dict__ directly
class GoodCustomStorage:
    def __getattr__(self, name):
        if '_storage' not in self.__dict__:
            self.__dict__['_storage'] = {}
        return self.__dict__['_storage'][name]
```

### Pitfall 2: Forgetting Internal Attributes

```python
# WRONG - Breaks internal attributes
class BadSetAttr:
    def __setattr__(self, name, value):
        self._storage[name] = value  # _storage itself can't be set!

# CORRECT - Handle internal attributes
class GoodSetAttr:
    def __setattr__(self, name, value):
        if name.startswith('_'):
            self.__dict__[name] = value
        else:
            if '_storage' not in self.__dict__:
                self.__dict__['_storage'] = {}
            self.__dict__['_storage'][name] = value
```

### Pitfall 3: Inheritance Assumptions

```python
# WRONG - Base class assumes specific __dict__ structure
class BaseWithAssumptions:
    def process_all(self):
        for key, value in self.__dict__.items():
            if key.startswith('data_'):  # Assumption!
                self._process(key, value)

# CORRECT - Design for inheritance
class BaseForInheritance:
    def process_all(self):
        for key, value in self._get_processable_items():
            self._process(key, value)
    
    def _get_processable_items(self):
        # Allow subclasses to override this
        return [(k, v) for k, v in self.__dict__.items() 
                if k.startswith('data_')]
```

## Key Takeaways

- **Flexibility**: Custom storage enables creative solutions for memory, performance, and functionality
- **Transparency**: Good implementations maintain normal attribute access syntax
- **Inheritance Challenges**: Custom storage can complicate inheritance; design base classes carefully
- **Performance Trade-offs**: Custom storage adds overhead; measure before optimizing
- **Error Handling**: Convert storage errors to appropriate AttributeError exceptions
- **Documentation**: Custom storage behavior should be well-documented for maintainers
- **Composition Alternative**: Consider composition over inheritance for complex custom storage needs
- **Testing**: Thoroughly test edge cases, especially with inheritance and error conditions
