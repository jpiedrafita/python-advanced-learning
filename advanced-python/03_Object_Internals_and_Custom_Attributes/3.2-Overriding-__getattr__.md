# 3.2 Overriding `__getattr__`

## Key Ideas

- `__getattr__` is called only when normal attribute lookup fails
- `__getattribute__` is called for all attribute access (use with caution)
- `__getattr__` enables dynamic attribute access and computed properties
- Unintended attribute assignment can bypass `__getattr__` mechanisms
- Proper implementation requires understanding attribute lookup order
- Common use cases include proxying, validation, and immutable interfaces

## The Problem: Private Attributes and Public Access

From the previous lesson, we had private attributes that couldn't be accessed publicly:

```python
>>> v = Vector(p=9, q=3)
>>> v
Vector(p=9, q=3)

>>> dir(v)
['__class__', '__delattr__', '__dict__', ..., '_p', '_q']

>>> v.p  # Public access no longer works
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    v.p
AttributeError: 'Vector' object has no attribute 'p'
```

We need to provide read-only access to coordinates while keeping them stored privately.

## Understanding `__getattr__` vs `__getattribute__`

### Key Differences

| Method | When Called | Use Case |
|--------|-------------|----------|
| `__getattr__` | Only when normal lookup fails | Fallback for missing attributes |
| `__getattribute__` | For ALL attribute access | Complete control (dangerous) |

### `__getattr__` - Fallback Mechanism

`__getattr__` is called only after Python's normal attribute lookup process fails to find the requested attribute.

## Basic `__getattr__` Implementation

### Debug Version

```python
class Vector:
    def __init__(self, **coords):
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def __getattr__(self, name):
        print("name =", name)  # Debug output

    def __repr__(self):
        return "{}({})".format(
            self.__class__.__name__, 
            ', '.join("{}={}".format(k[1:], self.__dict__[k])
                     for k in sorted(self.__dict__.keys()))
        )
```

### Testing the Debug Version

```python
>>> v = Vector(p=3, q=9)
>>> v.p
name = p
>>> v.q
name = q
>>> v._q  # Existing attribute - no __getattr__ call
9
>>> v._p  # Existing attribute - no __getattr__ call
3
```

**Observation**: `__getattr__` is only called for non-existent attributes (`p`, `q`), not for existing ones (`_p`, `_q`).

## Working Implementation

### Forwarding to Private Attributes

```python
class Vector:
    def __init__(self, **coords):
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def __getattr__(self, name):
        private_name = '_' + name
        return getattr(self, private_name)

    def __repr__(self):
        return "{}({})".format(
            self.__class__.__name__, 
            ', '.join("{}={}".format(k[1:], self.__dict__[k])
                     for k in sorted(self.__dict__.keys()))
        )
```

### Testing the Working Version

```python
>>> v = Vector(p=5, q=10)
>>> v.p
5
>>> v.q
10
```

**Success**: We can now access coordinates using public names while they're stored privately.

## The Hidden Problem: Attribute Assignment

### Unintended Behavior

```python
>>> v = Vector(p=5, q=10)
>>> v.p
5
>>> v.q
10
>>> v.p = 13  # This creates a new attribute!
>>> v.p
13
>>> v._p      # Original private attribute unchanged
5
>>> dir(v)
['__class__', '__delattr__', '__dict__', ..., '_p', '_q', 'p']
```

### What Happened?

1. **Assignment creates new attribute**: `v.p = 13` creates a real `p` attribute
2. **`__getattr__` bypassed**: Since `p` now exists, `__getattr__` is no longer called
3. **Data inconsistency**: We have both `p` (13) and `_p` (5) with different values
4. **Broken encapsulation**: The private storage is compromised

## Understanding Attribute Lookup Order

### Python's Attribute Resolution Process

1. **Instance `__dict__`**: Check if attribute exists in object's `__dict__`
2. **Class hierarchy**: Look up the class hierarchy for the attribute
3. **`__getattr__`**: Call `__getattr__` as a last resort (if defined)

### Lookup Flow Diagram

```
obj.attr access
    ↓
obj.__dict__['attr'] exists?
    ↓ YES          ↓ NO
return value   Look in class
                    ↓
                Class has attr?
                    ↓ YES          ↓ NO
                return value   Call __getattr__
```

## Improved Implementation with Validation

### Preventing Unwanted Attributes

```python
class Vector:
    def __init__(self, **coords):
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)
        self._valid_coords = set(coords.keys())

    def __getattr__(self, name):
        if name in self._valid_coords:
            private_name = '_' + name
            return getattr(self, private_name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

    def __setattr__(self, name, value):
        if name.startswith('_') or name in ['_valid_coords']:
            # Allow private attribute setting during initialization
            super().__setattr__(name, value)
        elif hasattr(self, '_valid_coords') and name in self._valid_coords:
            raise AttributeError(f"Cannot modify coordinate '{name}' - Vector is immutable")
        else:
            raise AttributeError(f"Cannot add new attribute '{name}' to Vector")

    def __repr__(self):
        return "{}({})".format(
            self.__class__.__name__, 
            ', '.join("{}={}".format(k[1:], self.__dict__[k])
                     for k in sorted(self.__dict__.keys()) 
                     if k.startswith('_') and k != '_valid_coords')
        )
```

### Testing the Improved Version

```python
>>> v = Vector(p=5, q=10)
>>> v.p
5
>>> v.q
10
>>> v.p = 13  # Now this fails!
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    v.p = 13
AttributeError: Cannot modify coordinate 'p' - Vector is immutable
>>> v.r = 20  # New attributes also fail
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    v.r = 20
AttributeError: Cannot add new attribute 'r' to Vector
```

## Advanced `__getattr__` Patterns

### Proxy Objects

```python
class DatabaseProxy:
    def __init__(self, connection):
        self._connection = connection
        self._cache = {}

    def __getattr__(self, table_name):
        if table_name not in self._cache:
            self._cache[table_name] = TableProxy(self._connection, table_name)
        return self._cache[table_name]

class TableProxy:
    def __init__(self, connection, table_name):
        self._connection = connection
        self._table_name = table_name

    def select(self, *columns):
        # Generate SQL SELECT statement
        return f"SELECT {', '.join(columns)} FROM {self._table_name}"

# Usage
>>> db = DatabaseProxy(connection)
>>> db.users.select('name', 'email')
'SELECT name, email FROM users'
>>> db.orders.select('id', 'total')
'SELECT id, total FROM orders'
```

### Configuration Objects

```python
class Config:
    def __init__(self, **defaults):
        self._values = defaults
        self._accessed = set()

    def __getattr__(self, name):
        if name in self._values:
            self._accessed.add(name)
            return self._values[name]
        raise AttributeError(f"Configuration key '{name}' not found")

    def get_accessed_keys(self):
        return self._accessed.copy()

# Usage
>>> config = Config(debug=True, port=8080, host='localhost')
>>> config.debug
True
>>> config.port
8080
>>> config.get_accessed_keys()
{'debug', 'port'}
```

### Attribute Validation and Transformation

```python
class ValidatedData:
    def __init__(self, **data):
        self._data = {}
        self._validators = {}
        for key, value in data.items():
            self._data['_' + key] = value

    def add_validator(self, attr_name, validator_func):
        self._validators[attr_name] = validator_func

    def __getattr__(self, name):
        private_name = '_' + name
        if private_name in self._data:
            value = self._data[private_name]
            if name in self._validators:
                return self._validators[name](value)
            return value
        raise AttributeError(f"No attribute '{name}'")

# Usage
>>> data = ValidatedData(temperature=25.5, pressure=1013.25)
>>> data.add_validator('temperature', lambda x: f"{x}°C")
>>> data.add_validator('pressure', lambda x: f"{x} hPa")
>>> data.temperature
'25.5°C'
>>> data.pressure
'1013.25 hPa'
```

## Common Pitfalls and Solutions

### Pitfall 1: Infinite Recursion

```python
# WRONG - This causes infinite recursion
class BadVector:
    def __getattr__(self, name):
        private_name = '_' + name
        return self.__dict__[private_name]  # If not found, calls __getattr__ again!

# CORRECT - Use getattr() builtin or check existence first
class GoodVector:
    def __getattr__(self, name):
        private_name = '_' + name
        if private_name in self.__dict__:
            return self.__dict__[private_name]
        raise AttributeError(f"No attribute '{name}'")
```

### Pitfall 2: Missing AttributeError

```python
# WRONG - Silently returns None for missing attributes
class BadConfig:
    def __getattr__(self, name):
        return self._defaults.get(name)  # Returns None if missing

# CORRECT - Raise AttributeError for missing attributes
class GoodConfig:
    def __getattr__(self, name):
        if name in self._defaults:
            return self._defaults[name]
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")
```

### Pitfall 3: Forgetting to Handle Assignment

```python
# WRONG - Allows unwanted attribute creation
class WeakVector:
    def __getattr__(self, name):
        return getattr(self, '_' + name)
    # Missing __setattr__ control

# CORRECT - Control both getting and setting
class StrongVector:
    def __getattr__(self, name):
        return getattr(self, '_' + name)
    
    def __setattr__(self, name, value):
        if name.startswith('_'):
            super().__setattr__(name, value)
        else:
            raise AttributeError("Vector is immutable")
```

## Performance Considerations

### Overhead Analysis

```python
import time

class DirectAccess:
    def __init__(self, x, y):
        self.x = x
        self.y = y

class GetAttrAccess:
    def __init__(self, x, y):
        self._x = x
        self._y = y
    
    def __getattr__(self, name):
        return getattr(self, '_' + name)

# Performance test
def benchmark_access(obj, iterations=1000000):
    start = time.time()
    for _ in range(iterations):
        _ = obj.x
        _ = obj.y
    return time.time() - start

direct = DirectAccess(1, 2)
getattr_obj = GetAttrAccess(1, 2)

print(f"Direct access: {benchmark_access(direct):.4f}s")
print(f"__getattr__ access: {benchmark_access(getattr_obj):.4f}s")
```

**Performance Impact**: `__getattr__` adds overhead since it's a method call for each access.

## Best Practices

**1. Use `__getattr__` for Missing Attributes Only**

```python
# Good: Only handle missing attributes
def __getattr__(self, name):
    if name in self._computed_properties:
        return self._compute_property(name)
    raise AttributeError(f"No attribute '{name}'")
```

**2. Always Raise AttributeError for Invalid Attributes**

```python
# Good: Clear error messages
def __getattr__(self, name):
    if name in self._valid_names:
        return self._get_value(name)
    raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")
```

**3. Consider Performance for Frequently Accessed Attributes**

```python
# Good: Cache computed results
class CachedProxy:
    def __init__(self):
        self._cache = {}
    
    def __getattr__(self, name):
        if name not in self._cache:
            self._cache[name] = self._compute_expensive_value(name)
        return self._cache[name]
```

**4. Combine with `__setattr__` for Immutability**

```python
# Good: Complete control over attribute access
class ImmutableData:
    def __getattr__(self, name):
        # Handle getting
        return self._get_value(name)
    
    def __setattr__(self, name, value):
        # Handle setting with restrictions
        if self._is_initialization_phase():
            super().__setattr__(name, value)
        else:
            raise AttributeError("Object is immutable")
```

## Key Takeaways

- `__getattr__` is called only when normal attribute lookup fails
- It enables dynamic attribute access and computed properties
- Uncontrolled attribute assignment can bypass `__getattr__` mechanisms
- Always raise `AttributeError` for truly missing attributes
- Combine with `__setattr__` for complete attribute control
- Consider performance implications for frequently accessed attributes
- Use for proxying, validation, and creating flexible interfaces
- Understand Python's attribute resolution order to predict behavior
