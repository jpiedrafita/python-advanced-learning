# 3.4 Pitfalls with `__getattr__`

## Key Ideas

- Naive `__getattr__` implementations can cause infinite recursion
- Using `getattr()` or `hasattr()` within `__getattr__` creates recursion loops
- Direct `__dict__` access is essential for safe `__getattr__` implementations
- EAFP (try/except) is preferred over LBYL (check first) for attribute access
- Proper error handling must convert `KeyError` to `AttributeError`
- Understanding recursion pitfalls is crucial for robust attribute handling

## The Infinite Recursion Problem

### What Goes Wrong

Starting with a naive `__getattr__` implementation:

```python
class Vector:
    def __init__(self, **coords):
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def __getattr__(self, name):
        private_name = '_' + name
        return getattr(self, private_name)  # DANGEROUS!

    def __repr__(self):
        return "{}({})".format(
            self.__class__.__name__, 
            ', '.join("{}={}".format(k[1:], self.__dict__[k])
                     for k in sorted(self.__dict__.keys()))
        )
```

### The Recursion Trap

```python
>>> v = Vector(p=9, q=14)
>>> v.x  # Requesting non-existent attribute
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    v.x
  File "vector.py", line 8, in __getattr__
    return getattr(self, private_name)
  File "vector.py", line 8, in __getattr__
    return getattr(self, private_name)
  File "vector.py", line 8, in __getattr__
    return getattr(self, private_name)
  [Previous line repeated 988 more times]
RecursionError: maximum recursion depth exceeded
```

### Why This Happens

**The Recursion Chain:**
1. `v.x` → calls `__getattr__(self, 'x')`
2. `__getattr__` looks for `_x` using `getattr(self, '_x')`
3. `_x` doesn't exist → calls `__getattr__(self, '_x')`
4. `__getattr__` looks for `__x` using `getattr(self, '__x')`
5. `__x` doesn't exist → calls `__getattr__(self, '__x')`
6. **Infinite loop continues...**

## Attempted Solutions and Why They Fail

### Attempt 1: Using `hasattr()` - Still Recursive

```python
def __getattr__(self, name):
    private_name = '_' + name
    if not hasattr(self, private_name):  # STILL DANGEROUS!
        raise AttributeError('{!r} object has no attribute {!r}'.format(
            self.__class__, name
        ))
    return getattr(self, private_name)
```

**Problem**: `hasattr()` also calls `__getattr__` internally, causing the same recursion issue.

### The Recursion Pattern

```
v.x → __getattr__('x')
    → hasattr(self, '_x')
        → __getattr__('_x') 
            → hasattr(self, '__x')
                → __getattr__('__x')
                    → ... (infinite recursion)
```

## Safe Solutions: Direct `__dict__` Access

### Solution 1: LBYL (Look Before You Leap)

```python
def __getattr__(self, name):
    private_name = '_' + name
    if private_name not in self.__dict__:
        raise AttributeError('{!r} object has no attribute {!r}'.format(
            self.__class__, name
        ))
    return self.__dict__[private_name]
```

### Solution 2: EAFP (Easier to Ask Forgiveness than Permission)

```python
def __getattr__(self, name):
    private_name = '_' + name
    try:
        return self.__dict__[private_name]
    except KeyError:
        raise AttributeError('{!r} object has no attribute {!r}'.format(
            self.__class__, name))
```

## Testing the Safe Implementation

### Working Vector Class

```python
class Vector:
    def __init__(self, **coords):
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def __getattr__(self, name):
        private_name = '_' + name
        try:
            return self.__dict__[private_name]
        except KeyError:
            raise AttributeError('{!r} object has no attribute {!r}'.format(
                self.__class__, name))

    def __repr__(self):
        return "{}({})".format(
            self.__class__.__name__, 
            ', '.join("{}={}".format(k[1:], self.__dict__[k])
                     for k in sorted(self.__dict__.keys()))
        )
```

### Successful Testing

```python
>>> v = Vector(p=9, q=14)
>>> v
Vector(p=9, q=14)
>>> v.p
9
>>> v.q
14
>>> v.x  # Now properly raises AttributeError
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    v.x
  File "vector.py", line 11, in __getattr__
    raise AttributeError('{!r} object has no attribute {!r}'.format(
AttributeError: <class 'vector.Vector'> object has no attribute 'x'
```

## LBYL vs EAFP Comparison

### LBYL: Look Before You Leap

```python
def __getattr__(self, name):
    private_name = '_' + name
    if private_name in self.__dict__:  # Check first
        return self.__dict__[private_name]
    else:
        raise AttributeError(f"No attribute '{name}'")
```

**Characteristics:**
- Checks condition before attempting operation
- Two dictionary lookups for existing attributes
- More explicit logic flow

### EAFP: Easier to Ask Forgiveness than Permission

```python
def __getattr__(self, name):
    private_name = '_' + name
    try:
        return self.__dict__[private_name]  # Try directly
    except KeyError:
        raise AttributeError(f"No attribute '{name}'")
```

**Characteristics:**
- Attempts operation directly
- One dictionary lookup for existing attributes
- More Pythonic and typically faster

### Performance Comparison

```python
import timeit

class LBYLVector:
    def __init__(self, **coords):
        self.__dict__.update({'_' + k: v for k, v in coords.items()})
    
    def __getattr__(self, name):
        private_name = '_' + name
        if private_name in self.__dict__:
            return self.__dict__[private_name]
        raise AttributeError(f"No attribute '{name}'")

class EAFPVector:
    def __init__(self, **coords):
        self.__dict__.update({'_' + k: v for k, v in coords.items()})
    
    def __getattr__(self, name):
        private_name = '_' + name
        try:
            return self.__dict__[private_name]
        except KeyError:
            raise AttributeError(f"No attribute '{name}'")

# Benchmark existing attributes (common case)
lbyl_vector = LBYLVector(x=1, y=2, z=3)
eafp_vector = EAFPVector(x=1, y=2, z=3)

lbyl_time = timeit.timeit(lambda: lbyl_vector.x, number=1000000)
eafp_time = timeit.timeit(lambda: eafp_vector.x, number=1000000)

print(f"LBYL: {lbyl_time:.4f}s")
print(f"EAFP: {eafp_time:.4f}s")  # Typically faster
```

## Advanced Error Handling

### Improved Error Messages

```python
class Vector:
    def __init__(self, **coords):
        self._coords = set(coords.keys())
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def __getattr__(self, name):
        private_name = '_' + name
        try:
            return self.__dict__[private_name]
        except KeyError:
            if self._coords:
                available = ', '.join(sorted(self._coords))
                raise AttributeError(
                    f"'{self.__class__.__name__}' object has no attribute '{name}'. "
                    f"Available coordinates: {available}"
                )
            else:
                raise AttributeError(
                    f"'{self.__class__.__name__}' object has no attribute '{name}'"
                )

# Usage with better error messages
>>> v = Vector(x=1, y=2)
>>> v.z
AttributeError: 'Vector' object has no attribute 'z'. Available coordinates: x, y
```

### Attribute Suggestions

```python
import difflib

class SmartVector:
    def __init__(self, **coords):
        self._coords = set(coords.keys())
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def __getattr__(self, name):
        private_name = '_' + name
        try:
            return self.__dict__[private_name]
        except KeyError:
            # Suggest similar attribute names
            suggestions = difflib.get_close_matches(name, self._coords, n=3)
            if suggestions:
                suggestion_text = ', '.join(f"'{s}'" for s in suggestions)
                raise AttributeError(
                    f"'{self.__class__.__name__}' object has no attribute '{name}'. "
                    f"Did you mean: {suggestion_text}?"
                )
            else:
                raise AttributeError(
                    f"'{self.__class__.__name__}' object has no attribute '{name}'"
                )

# Usage with suggestions
>>> v = SmartVector(x=1, y=2, z=3)
>>> v.w
AttributeError: 'SmartVector' object has no attribute 'w'. Did you mean: 'x', 'y', 'z'?
>>> v.X  # Case mismatch
AttributeError: 'SmartVector' object has no attribute 'X'. Did you mean: 'x'?
```

## Common Pitfalls and Solutions

### Pitfall 1: Using Built-in Attribute Functions

```python
# WRONG - Creates recursion
def __getattr__(self, name):
    if hasattr(self, '_' + name):  # Calls __getattr__ again!
        return getattr(self, '_' + name)  # More recursion!

# CORRECT - Direct dictionary access
def __getattr__(self, name):
    try:
        return self.__dict__['_' + name]
    except KeyError:
        raise AttributeError(f"No attribute '{name}'")
```

### Pitfall 2: Forgetting to Convert KeyError

```python
# WRONG - Leaks KeyError
def __getattr__(self, name):
    return self.__dict__['_' + name]  # KeyError escapes

# CORRECT - Convert to AttributeError
def __getattr__(self, name):
    try:
        return self.__dict__['_' + name]
    except KeyError:
        raise AttributeError(f"No attribute '{name}'")
```

### Pitfall 3: Inconsistent Error Messages

```python
# WRONG - Inconsistent with Python's standard messages
def __getattr__(self, name):
    try:
        return self.__dict__['_' + name]
    except KeyError:
        raise AttributeError("Bad attribute")  # Uninformative

# CORRECT - Follow Python's conventions
def __getattr__(self, name):
    try:
        return self.__dict__['_' + name]
    except KeyError:
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")
```

## Debugging `__getattr__` Issues

### Debug Version for Development

```python
class DebugVector:
    def __init__(self, **coords):
        print(f"Initializing with coords: {coords}")
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def __getattr__(self, name):
        print(f"__getattr__ called with name: {name}")
        private_name = '_' + name
        print(f"Looking for private name: {private_name}")
        print(f"Available attributes: {list(self.__dict__.keys())}")
        
        try:
            result = self.__dict__[private_name]
            print(f"Found: {private_name} = {result}")
            return result
        except KeyError:
            print(f"Not found: {private_name}")
            raise AttributeError(f"No attribute '{name}'")

# Usage for debugging
>>> v = DebugVector(x=1, y=2)
Initializing with coords: {'x': 1, 'y': 2}
>>> v.x
__getattr__ called with name: x
Looking for private name: _x
Available attributes: ['_x', '_y']
Found: _x = 1
1
>>> v.z
__getattr__ called with name: z
Looking for private name: _z
Available attributes: ['_x', '_y']
Not found: _z
AttributeError: No attribute 'z'
```

## Best Practices

**1. Always Use Direct `__dict__` Access**

```python
# Good: Direct dictionary access
def __getattr__(self, name):
    try:
        return self.__dict__['_' + name]
    except KeyError:
        raise AttributeError(f"No attribute '{name}'")
```

**2. Prefer EAFP over LBYL**

```python
# Good: Try first, handle exception
def __getattr__(self, name):
    try:
        return self.__dict__['_' + name]
    except KeyError:
        raise AttributeError(f"No attribute '{name}'")

# Acceptable: Check first (but slower)
def __getattr__(self, name):
    private_name = '_' + name
    if private_name in self.__dict__:
        return self.__dict__[private_name]
    raise AttributeError(f"No attribute '{name}'")
```

**3. Provide Helpful Error Messages**

```python
# Good: Informative error with context
def __getattr__(self, name):
    try:
        return self.__dict__['_' + name]
    except KeyError:
        available = [k[1:] for k in self.__dict__.keys() if k.startswith('_')]
        raise AttributeError(
            f"'{self.__class__.__name__}' object has no attribute '{name}'. "
            f"Available: {', '.join(available)}"
        )
```

**4. Test Edge Cases**

```python
def test_vector():
    # Test normal access
    v = Vector(x=1, y=2)
    assert v.x == 1
    assert v.y == 2
    
    # Test missing attributes
    try:
        v.z
        assert False, "Should raise AttributeError"
    except AttributeError:
        pass
    
    # Test empty vector
    empty = Vector()
    try:
        empty.x
        assert False, "Should raise AttributeError"
    except AttributeError:
        pass
```

## Key Takeaways

- Naive `__getattr__` implementations using `getattr()` or `hasattr()` cause infinite recursion
- Always use direct `__dict__` access to avoid recursion loops
- EAFP (try/except) is generally preferred over LBYL (check first) for performance
- Proper error handling must convert `KeyError` to `AttributeError`
- Provide helpful error messages that follow Python's conventions
- Test edge cases thoroughly, including missing attributes and empty objects
- Understanding these pitfalls is essential for robust attribute handling in advanced Python programming