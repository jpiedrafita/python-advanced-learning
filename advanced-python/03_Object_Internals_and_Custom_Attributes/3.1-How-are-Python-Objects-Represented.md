# 3.1 How are Python Objects Represented?

## Key Ideas

- Python objects store instance attributes in the `__dict__` dictionary
- `__dict__` is a regular Python dictionary accessible for direct manipulation
- Built-in functions provide preferred interfaces for attribute operations
- Dynamic attribute creation enables flexible obje### Performance Consideratio### Error Handling
- Safe Attribute Access
- Dictionary Overhead Designs
- Private attributes use underscore prefixes by convention
- Understanding `__dict__` is essential for advanced Python programming

## Basic Object Representation

### Simple Vector Class

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return "{}({}, {})".format(
            self.__class__.__name__, self.x, self.y
        )
```

### Object Instantiation and Inspection

```python
>>> v = Vector(5, 3)
>>> v
Vector(5, 3)
>>> dir(v)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', 
 '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', 
 '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', 
 '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 
 '__weakref__', 'x', 'y']
```

The `dir()` function reveals both custom attributes (`x`, `y`) and Python's special dunder attributes.

## The `__dict__` Attribute

### Understanding `__dict__`

Every Python object has a `__dict__` attribute that stores instance attributes:

```python
>>> v.__dict__
{'x': 5, 'y': 3}
>>> type(v.__dict__)
<class 'dict'>
```

`__dict__` is a regular Python dictionary where:
- **Keys**: Attribute names (strings)
- **Values**: Attribute values (any Python object)

### Direct Dictionary Operations

**Reading Attributes**

```python
>>> v.__dict__['x']
5
```

**Modifying Attributes**

```python
>>> v.__dict__['x'] = 17
>>> v.x
17
```

**Deleting Attributes**

```python
>>> del v.__dict__['x']
>>> v.x
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    v.x
AttributeError: 'Vector' object has no attribute 'x'
```

**Testing Existence and Adding Attributes**

```python
>>> 'x' in v.__dict__
False
>>> 'y' in v.__dict__
True
>>> v.__dict__['z'] = 13
>>> v.z
13
```

## Preferred Attribute Operations

While direct `__dict__` manipulation is possible, Python provides built-in functions for attribute operations:

### Built-in Attribute Functions

```python
>>> v = Vector(5, 3)

# Get attribute value
>>> getattr(v, 'y')
3

# Check attribute existence
>>> hasattr(v, 'x')
True

# Delete attribute
>>> delattr(v, 'z')

# Set attribute value
>>> setattr(v, 'x', 9)
>>> v.x
9
```

### Function Comparison

| Function | Direct `__dict__` | Purpose |
|----------|-------------------|---------|
| `getattr(obj, name)` | `obj.__dict__[name]` | Get attribute value |
| `setattr(obj, name, value)` | `obj.__dict__[name] = value` | Set attribute value |
| `hasattr(obj, name)` | `name in obj.__dict__` | Check attribute existence |
| `delattr(obj, name)` | `del obj.__dict__[name]` | Delete attribute |

## Dynamic Attribute Creation

### Flexible Vector with Arbitrary Coordinates

```python
class Vector:
    def __init__(self, **coords):
        self.__dict__.update(coords)

    def __repr__(self):
        return "{}({})".format(
            self.__class__.__name__, 
            ', '.join("{}={}".format(k, self.__dict__[k])
                     for k in sorted(self.__dict__.keys()))
        )
```

### Usage Examples

```python
>>> v1 = Vector(x=5, y=3)
>>> v1
Vector(x=5, y=3)

>>> v2 = Vector(p=3, q=7)
>>> v2
Vector(p=3, q=7)

>>> v3 = Vector(u=1, v=2, w=3)
>>> v3
Vector(u=1, v=2, w=3)
```

**Key Features**

- **`**coords`**: Accepts arbitrary keyword arguments
- **`__dict__.update(coords)`**: Merges coordinate dictionary into object's `__dict__`
- **Sorted keys**: Ensures consistent string representation
- **Flexible naming**: Supports different coordinate systems (x/y, p/q, u/v/w)

## Private Attributes and Encapsulation

### Creating Private Attributes

```python
class Vector:
    def __init__(self, **coords):
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def __repr__(self):
        return "{}({})".format(
            self.__class__.__name__, 
            ', '.join("{}={}".format(k[1:], self.__dict__[k])
                     for k in sorted(self.__dict__.keys()))
        )
```

### Private Attribute Behavior

```python
>>> v = Vector(p=9, q=3)
>>> v
Vector(p=9, q=3)

>>> dir(v)
['__class__', '__delattr__', '__dict__', ..., '_p', '_q']

>>> v.p  # Public access no longer works
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    v.p
AttributeError: 'Vector' object has no attribute 'p'

>>> v._p  # Private attribute access
9
```

**Implementation Details**

- **Dictionary comprehension**: `{'_' + k: v for k, v in coords.items()}` creates private names
- **String slicing**: `k[1:]` strips underscore prefix in `__repr__`
- **Encapsulation**: Public interface hides internal storage details

## Advanced `__dict__` Concepts

### Object Attribute Storage

```python
class Example:
    class_attr = "shared"
    
    def __init__(self, value):
        self.instance_attr = value

>>> obj = Example("instance")
>>> obj.__dict__
{'instance_attr': 'instance'}

>>> Example.__dict__['class_attr']
'shared'
```

**Important**: `__dict__` only contains instance attributes, not class attributes.

### Dynamic Attribute Addition

```python
>>> class DynamicObject:
...     pass

>>> obj = DynamicObject()
>>> obj.__dict__
{}

>>> obj.new_attr = "dynamically added"
>>> obj.__dict__
{'new_attr': 'dynamically added'}
```

### Memory Considerations

```python
>>> import sys
>>> obj = Vector(x=1, y=2)
>>> sys.getsizeof(obj.__dict__)
296  # Dictionary overhead

# Each object carries dictionary overhead
>>> v1 = Vector(x=1, y=2)
>>> v2 = Vector(x=3, y=4)
>>> sys.getsizeof(v1.__dict__) + sys.getsizeof(v2.__dict__)
592  # Total overhead for two objects
```

## Practical Applications

### Configuration Objects

```python
class Config:
    def __init__(self, **settings):
        self.__dict__.update(settings)
    
    def get(self, key, default=None):
        return getattr(self, key, default)
    
    def update(self, **new_settings):
        self.__dict__.update(new_settings)

>>> config = Config(debug=True, port=8080, host='localhost')
>>> config.debug
True
>>> config.get('timeout', 30)
30
>>> config.update(debug=False, timeout=60)
```

### Data Transfer Objects

```python
class DataRecord:
    def __init__(self, **data):
        self.__dict__.update(data)
    
    def to_dict(self):
        return self.__dict__.copy()
    
    def from_dict(self, data):
        self.__dict__.clear()
        self.__dict__.update(data)

>>> record = DataRecord(name="John", age=30, city="New York")
>>> record.name
'John'
>>> data_dict = record.to_dict()
>>> data_dict
{'name': 'John', 'age': 30, 'city': 'New York'}
```

### Namespace Objects

```python
class SimpleNamespace:
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)
    
    def __repr__(self):
        items = ', '.join(f"{k}={v!r}" for k, v in self.__dict__.items())
        return f"{self.__class__.__name__}({items})"

>>> ns = SimpleNamespace(x=1, y=2, name="point")
>>> ns.x
1
>>> ns.name
'point'
```

## Performance Considerations

### Dictionary Overhead

```python
# Traditional approach with fixed attributes
class FixedVector:
    __slots__ = ['x', 'y']  # No __dict__ overhead
    
    def __init__(self, x, y):
        self.x = x
        self.y = y

# Dynamic approach with __dict__
class DynamicVector:
    def __init__(self, **coords):
        self.__dict__.update(coords)
```

**Memory Usage Comparison**

| Approach | Memory per Object | Flexibility | Performance |
|----------|-------------------|-------------|-------------|
| Fixed attributes | Lower | Limited | Faster |
| `__dict__` based | Higher | High | Slower |

## Error Handling

### Safe Attribute Access

```python
def safe_getattr(obj, name, default=None):
    """Safely get attribute with fallback."""
    try:
        return getattr(obj, name)
    except AttributeError:
        return default

def safe_setattr(obj, name, value):
    """Safely set attribute with validation."""
    if not isinstance(name, str):
        raise TypeError("Attribute name must be string")
    if name.startswith('__') and name.endswith('__'):
        raise ValueError("Cannot set dunder attributes")
    setattr(obj, name, value)
```

**Attribute Validation**

```python
class ValidatedVector:
    def __init__(self, **coords):
        for name, value in coords.items():
            if not isinstance(value, (int, float)):
                raise TypeError(f"Coordinate {name} must be numeric")
            if not name.isidentifier():
                raise ValueError(f"Invalid coordinate name: {name}")
        self.__dict__.update(coords)
```

## Best Practices

### 1. Prefer Built-in Functions

```python
# Good: Using built-in functions
value = getattr(obj, 'attr', default_value)
setattr(obj, 'attr', new_value)

# Avoid: Direct __dict__ manipulation (unless specifically needed)
value = obj.__dict__.get('attr', default_value)
obj.__dict__['attr'] = new_value
```

### 2. Use Private Attributes for Internal State

```python
class Vector:
    def __init__(self, **coords):
        # Store as private attributes
        for name, value in coords.items():
            setattr(self, f'_{name}', value)
        self._coord_names = list(coords.keys())
```

### 3. Validate Dynamic Attributes

```python
class SafeVector:
    def __init__(self, **coords):
        for name, value in coords.items():
            self._validate_coordinate(name, value)
        self.__dict__.update(coords)
    
    def _validate_coordinate(self, name, value):
        if not isinstance(name, str) or not name.isidentifier():
            raise ValueError(f"Invalid coordinate name: {name}")
        if not isinstance(value, (int, float)):
            raise TypeError(f"Coordinate {name} must be numeric")
```

### 4. Document Dynamic Behavior

```python
class FlexibleVector:
    """
    A vector class supporting arbitrary coordinate names.
    
    Args:
        **coords: Coordinate names and values (must be numeric)
        
    Example:
        >>> v1 = FlexibleVector(x=1, y=2)
        >>> v2 = FlexibleVector(u=3, v=4, w=5)
    """
    def __init__(self, **coords):
        self.__dict__.update(coords)
```

## Key Takeaways

- Python objects store instance attributes in the `__dict__` dictionary
- Direct `__dict__` manipulation is powerful but should be used judiciously
- Built-in functions (`getattr`, `setattr`, `hasattr`, `delattr`) provide safer interfaces
- Dynamic attribute creation enables flexible object designs
- Private attributes (underscore prefix) support encapsulation patterns
- `__dict__` incurs memory overhead compared to fixed attribute approaches
- Understanding object representation is crucial for advanced Python programming
- Validation and error handling are important with dynamic attributes
