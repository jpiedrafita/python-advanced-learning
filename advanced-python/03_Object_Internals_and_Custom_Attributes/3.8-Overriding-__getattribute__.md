# 3.8 Overriding __getattribute__

## Key Ideas

- `__getattribute__` intercepts ALL attribute access, unlike `__getattr__` which only handles missing attributes
- `__getattribute__` is implemented in the base `object` class and provides normal lookup behavior
- Overriding `__getattribute__` gives complete control but requires extreme care to avoid infinite recursion
- Use `super().__getattribute__()` to access attributes safely within `__getattribute__`
- Proxy patterns benefit from `__getattribute__` to intercept and forward all attribute access
- Must also override `__setattr__` and `__delattr__` for complete proxy functionality
- This level of control is rarely needed - consider `__getattr__` first

## Understanding `__getattribute__` vs `__getattr__`

### Key Differences

| Aspect | `__getattr__` | `__getattribute__` |
|--------|---------------|-------------------|
| **When Called** | Only when normal lookup fails | Every attribute access |
| **Use Case** | Handle missing attributes | Intercept all attribute access |
| **Risk Level** | Low - safe fallback | High - easy to break |
| **Performance** | Minimal impact | Called for every access |
| **Common Use** | Dynamic attributes | Proxies, logging, debugging |

### Attribute Lookup Flow

```python
# Normal attribute access: obj.attr

# 1. __getattribute__ is ALWAYS called first
def __getattribute__(self, name):
    # This method handles ALL attribute access
    # - Check __dict__
    # - Check class attributes  
    # - Check parent classes
    # - If nothing found, call __getattr__ (if defined)
    pass

# 2. __getattr__ is called ONLY if __getattribute__ raises AttributeError
def __getattr__(self, name):
    # This is the "last resort" for missing attributes
    pass
```

### Demonstration of the Difference

```python
class GetAttrExample:
    def __init__(self):
        self.existing = "I exist"
    
    def __getattr__(self, name):
        print(f"__getattr__ called for: {name}")
        return f"Generated: {name}"

class GetAttributeExample:
    def __init__(self):
        # Use super() to avoid infinite recursion
        super().__setattr__('existing', "I exist")
    
    def __getattribute__(self, name):
        print(f"__getattribute__ called for: {name}")
        return super().__getattribute__(name)

# Testing __getattr__
>>> getattr_obj = GetAttrExample()
>>> getattr_obj.existing  # No output - normal lookup succeeds
'I exist'
>>> getattr_obj.missing   # __getattr__ is called
__getattr__ called for: missing
'Generated: missing'

# Testing __getattribute__
>>> getattribute_obj = GetAttributeExample()
>>> getattribute_obj.existing  # __getattribute__ is called
__getattribute__ called for: existing
'I exist'
>>> getattribute_obj.missing   # __getattribute__ is called, then fails
__getattribute__ called for: missing
AttributeError: 'GetAttributeExample' object has no attribute 'missing'
```

## The Infinite Recursion Trap

### What Goes Wrong

```python
class BadExample:
    def __init__(self, value):
        self.value = value  # This will cause problems!
    
    def __getattribute__(self, name):
        print(f"Accessing: {name}")
        if name == 'value':
            return self.value  # INFINITE RECURSION!
        return super().__getattribute__(name)

# This crashes with RecursionError
>>> bad = BadExample(42)
RecursionError: maximum recursion depth exceeded
```

### Why This Happens

```
obj.value → __getattribute__('value')
          → self.value → __getattribute__('value')  
                      → self.value → __getattribute__('value')
                                  → ... (infinite loop)
```

### Safe Implementation

```python
class SafeExample:
    def __init__(self, value):
        # Use super() in __init__ to avoid triggering our __getattribute__
        super().__setattr__('value', value)
    
    def __getattribute__(self, name):
        print(f"Accessing: {name}")
        # Always use super() to access any attribute
        return super().__getattribute__(name)

>>> safe = SafeExample(42)
>>> safe.value
Accessing: value
42
```

## Implementing a Logging Proxy

### Basic LoggingProxy Implementation

```python
class LoggingProxy:
    """A proxy that logs all attribute access."""
    
    def __init__(self, target):
        # Use super().__setattr__ to avoid triggering our own __setattr__
        super().__setattr__('target', target)

    def __getattribute__(self, name):
        # Get the target object using super() to avoid recursion
        target = super().__getattribute__('target')

        try:
            # Delegate attribute access to the target
            value = getattr(target, name)
        except AttributeError as e:
            # Provide informative error message
            class_name = super().__getattribute__('__class__').__name__
            raise AttributeError(f"{class_name} could not forward request {name} to {target}") from e

        print(f"Retrieved attribute {name!r} = {value!r} from {target!r}")
        return value
```

### Testing Basic Functionality

```python
# Assuming we have a ColoredVector class from previous lessons
>>> cv = ColoredVector(red=23, green=44, blue=238, p=9, q=14)
>>> proxy = LoggingProxy(cv)
>>> proxy.p
Retrieved attribute 'p' = 9 from ColoredVector(red=23, green=44, blue=238, p=9, q=14)
9
>>> proxy.red
Retrieved attribute 'red' = 23 from ColoredVector(red=23, green=44, blue=238, p=9, q=14)
23
```

## The Write-Through Problem

### What Happens Without `__setattr__`

```python
>>> proxy.p = 19      # Appears to succeed
>>> proxy.red = 5     # Appears to succeed

# But checking the values...
>>> proxy.p
Retrieved attribute 'p' = 9 from ColoredVector(red=23, green=44, blue=238, p=9, q=14)
9
>>> proxy.red
Retrieved attribute 'red' = 23 from ColoredVector(red=23, green=44, blue=238, p=9, q=14)
23
```

### Why This Happens

**When we write: proxy.p = 19**
1. Python calls proxy.__setattr__('p', 19)
2. We haven't overridden __setattr__, so object.__setattr__ is used
3. object.__setattr__ creates proxy.__dict__['p'] = 19
4. The target object is unchanged!

**When we read: proxy.p**
1. Python calls proxy.__getattribute__('p') 
2. Our __getattribute__ delegates to getattr(target, 'p')
3. We get the target's value, not the proxy's __dict__

The proxy's __dict__ becomes "write-only"!


### Demonstrating the Problem

```python
class DiagnosticProxy(LoggingProxy):
    def show_state(self):
        proxy_dict = super().__getattribute__('__dict__')
        target = super().__getattribute__('target')
        print(f"Proxy __dict__: {proxy_dict}")
        print(f"Target: {target}")

>>> dp = DiagnosticProxy(ColoredVector(x=1, y=2))
>>> dp.x = 999  # Writes to proxy's __dict__
>>> dp.show_state()
Proxy __dict__: {'target': ColoredVector(x=1, y=2), 'x': 999}
Target: ColoredVector(x=1, y=2)
>>> dp.x  # Reads from target, not proxy's __dict__
Retrieved attribute 'x' = 1 from ColoredVector(x=1, y=2)
1
```

## Complete Proxy Implementation

### Adding `__setattr__` for Write-Through

```python
class CompleteLoggingProxy:
    """A complete proxy that forwards all attribute operations."""
    
    def __init__(self, target):
        super().__setattr__('target', target)

    def __getattribute__(self, name):
        target = super().__getattribute__('target')

        try:
            value = getattr(target, name)
        except AttributeError as e:
            class_name = super().__getattribute__('__class__').__name__
            raise AttributeError(f"{class_name} could not forward request {name} to {target}") from e

        print(f"Retrieved attribute {name!r} = {value!r} from {target!r}")
        return value

    def __setattr__(self, name, value):
        # Skip the target attribute during initialization
        if name == 'target':
            super().__setattr__(name, value)
            return
            
        target = super().__getattribute__('target')

        try:
            setattr(target, name, value)
        except AttributeError as e:
            class_name = super().__getattribute__('__class__').__name__
            raise AttributeError(f"{class_name} could not forward request {name} to {target}") from e

        print(f"Set attribute {name!r} = {value!r} on {target!r}")

    def __delattr__(self, name):
        target = super().__getattribute__('target')

        try:
            delattr(target, name)
        except AttributeError as e:
            class_name = super().__getattribute__('__class__').__name__
            raise AttributeError(f"{class_name} could not forward request {name} to {target}") from e

        print(f"Deleted attribute {name!r} from {target!r}")
```

### Testing Complete Proxy

```python
>>> cv = ColoredVector(red=23, green=44, blue=238, p=9, q=14)
>>> proxy = CompleteLoggingProxy(cv)

# Test successful attribute modification
>>> proxy.red = 55
Set attribute 'red' = 55 on ColoredVector(55, 44, 238, p=9, q=14)
>>> proxy.red
Retrieved attribute 'red' = 55 from ColoredVector(55, 44, 238, p=9, q=14)
55

# Test immutable attribute rejection
>>> proxy.p = 19
AttributeError: CompleteLoggingProxy could not forward request p to ColoredVector(55, 44, 238, p=9, q=14)
```

## Advanced Proxy Patterns

### Selective Logging Proxy

```python
class SelectiveLoggingProxy:
    """Proxy that only logs specified attributes."""
    
    def __init__(self, target, log_attributes=None):
        super().__setattr__('target', target)
        super().__setattr__('log_attributes', set(log_attributes or []))

    def __getattribute__(self, name):
        # Handle internal attributes normally
        if name in ('target', 'log_attributes'):
            return super().__getattribute__(name)
            
        target = super().__getattribute__('target')
        log_attributes = super().__getattribute__('log_attributes')

        try:
            value = getattr(target, name)
        except AttributeError as e:
            raise AttributeError(f"Could not access {name}") from e

        # Only log if attribute is in the log set
        if name in log_attributes:
            print(f"LOGGED: Retrieved {name!r} = {value!r}")
        
        return value

    def __setattr__(self, name, value):
        if name in ('target', 'log_attributes'):
            super().__setattr__(name, value)
            return
            
        target = super().__getattribute__('target')
        log_attributes = super().__getattribute__('log_attributes')

        try:
            setattr(target, name, value)
        except AttributeError as e:
            raise AttributeError(f"Could not set {name}") from e

        if name in log_attributes:
            print(f"LOGGED: Set {name!r} = {value!r}")

# Usage
>>> cv = ColoredVector(red=23, green=44, blue=238, x=1, y=2)
>>> selective_proxy = SelectiveLoggingProxy(cv, log_attributes={'red', 'x'})
>>> selective_proxy.red  # Logged
```

```python
LOGGED: Retrieved 'red' = 23
23
```

```python
>>> selective_proxy.y    # Not logged
2
```

### Caching Proxy

```python
class CachingProxy:
    """Proxy that caches attribute values to improve performance."""
    
    def __init__(self, target):
        super().__setattr__('target', target)
        super().__setattr__('cache', {})

    def __getattribute__(self, name):
        if name in ('target', 'cache'):
            return super().__getattribute__(name)
            
        cache = super().__getattribute__('cache')
        
        # Return cached value if available
        if name in cache:
            print(f"Cache HIT for {name!r}")
            return cache[name]
            
        target = super().__getattribute__('target')
        
        try:
            value = getattr(target, name)
        except AttributeError as e:
            raise AttributeError(f"Could not access {name}") from e
            
        # Cache the value
        cache[name] = value
        print(f"Cache MISS for {name!r} - cached value")
        return value

    def __setattr__(self, name, value):
        if name in ('target', 'cache'):
            super().__setattr__(name, value)
            return
            
        target = super().__getattribute__('target')
        cache = super().__getattribute__('cache')
        
        try:
            setattr(target, name, value)
        except AttributeError as e:
            raise AttributeError(f"Could not set {name}") from e
            
        # Update cache
        cache[name] = value
        print(f"Updated cache for {name!r}")

    def clear_cache(self):
        """Clear the attribute cache."""
        cache = super().__getattribute__('cache')
        cache.clear()
        print("Cache cleared")

# Usage
>>> cv = ColoredVector(red=23, green=44, blue=238)
>>> caching_proxy = CachingProxy(cv)
>>> caching_proxy.red  # First access - cache miss
```

```python
Cache MISS for 'red' - cached value
23
```

```python
>>> caching_proxy.red  # Second access - cache hit
```

```python
Cache HIT for 'red'
23
```

### Validation Proxy

```python
class ValidationProxy:
    """Proxy that validates attribute values before setting."""
    
    def __init__(self, target, validators=None):
        super().__setattr__('target', target)
        super().__setattr__('validators', validators or {})

    def __getattribute__(self, name):
        if name in ('target', 'validators'):
            return super().__getattribute__(name)
            
        target = super().__getattribute__('target')
        
        try:
            return getattr(target, name)
        except AttributeError as e:
            raise AttributeError(f"Could not access {name}") from e

    def __setattr__(self, name, value):
        if name in ('target', 'validators'):
            super().__setattr__(name, value)
            return
            
        target = super().__getattribute__('target')
        validators = super().__getattribute__('validators')
        
        # Validate if validator exists
        if name in validators:
            validator = validators[name]
            if not validator(value):
                raise ValueError(f"Validation failed for {name!r} = {value!r}")
            print(f"Validation passed for {name!r} = {value!r}")
        
        try:
            setattr(target, name, value)
        except AttributeError as e:
            raise AttributeError(f"Could not set {name}") from e

# Usage with validators
>>> def color_validator(value):
...     return isinstance(value, int) and 0 <= value <= 255

>>> cv = ColoredVector(red=23, green=44, blue=238)
>>> validators = {'red': color_validator, 'green': color_validator, 'blue': color_validator}
>>> val_proxy = ValidationProxy(cv, validators)

>>> val_proxy.red = 200  # Valid
```

```python
Validation passed for 'red' = 200
```

```python
>>> val_proxy.red = 300  # Invalid
```

```python
ValueError: Validation failed for 'red' = 300
```

## Performance Considerations

### Overhead of `__getattribute__`

```python
import timeit

class NormalClass:
    def __init__(self):
        self.value = 42

class ProxyClass:
    def __init__(self, target):
        super().__setattr__('target', target)
    
    def __getattribute__(self, name):
        if name == 'target':
            return super().__getattribute__(name)
        target = super().__getattribute__('target')
        return getattr(target, name)

# Benchmark
normal = NormalClass()
proxy = ProxyClass(normal)

normal_time = timeit.timeit(lambda: normal.value, number=1000000)
proxy_time = timeit.timeit(lambda: proxy.value, number=1000000)

print(f"Normal access: {normal_time:.4f}s")
print(f"Proxy access: {proxy_time:.4f}s")
print(f"Overhead: {proxy_time/normal_time:.1f}x")
```

```python
Normal access: 0.0823s
Proxy access: 0.2156s
Overhead: 2.6x
```

### Optimization Strategies

```python
class OptimizedProxy:
    """Optimized proxy that minimizes overhead for common attributes."""
    
    def __init__(self, target):
        super().__setattr__('target', target)
        # Cache frequently accessed attributes
        super().__setattr__('_common_attrs', {'__class__', '__dict__'})

    def __getattribute__(self, name):
        # Fast path for proxy's own attributes
        if name in ('target', '_common_attrs'):
            return super().__getattribute__(name)
            
        # Fast path for very common attributes
        common_attrs = super().__getattribute__('_common_attrs')
        if name in common_attrs:
            target = super().__getattribute__('target')
            return getattr(target, name)
            
        # Regular path for other attributes
        target = super().__getattribute__('target')
        return getattr(target, name)
```

## Common Pitfalls and Solutions

### Pitfall 1: Accessing Self Attributes

```python
# WRONG - Infinite recursion
class BadProxy:
    def __init__(self, target):
        self.target = target  # This triggers __getattribute__!
    
    def __getattribute__(self, name):
        if self.target:  # Infinite recursion!
            return getattr(self.target, name)

# CORRECT - Use super()
class GoodProxy:
    def __init__(self, target):
        super().__setattr__('target', target)
    
    def __getattribute__(self, name):
        target = super().__getattribute__('target')
        return getattr(target, name)
```

### Pitfall 2: Forgetting Internal Attributes

```python
# WRONG - Can't access proxy's own methods
class BadProxy:
    def __getattribute__(self, name):
        target = super().__getattribute__('target')
        return getattr(target, name)  # Even methods go to target!
    
    def show_info(self):  # This method is unreachable!
        return "Proxy info"

# CORRECT - Handle proxy's own attributes
class GoodProxy:
    def __getattribute__(self, name):
        # Allow access to proxy's own methods
        if name in ('target', 'show_info'):
            return super().__getattribute__(name)
        target = super().__getattribute__('target')
        return getattr(target, name)
    
    def show_info(self):
        return "Proxy info"
```

### Pitfall 3: Exception Handling

```python
# WRONG - Poor error handling
class BadProxy:
    def __getattribute__(self, name):
        target = super().__getattribute__('target')
        return getattr(target, name)  # Lets AttributeError escape

# CORRECT - Proper exception handling
class GoodProxy:
    def __getattribute__(self, name):
        if name == 'target':
            return super().__getattribute__(name)
        target = super().__getattribute__('target')
        try:
            return getattr(target, name)
        except AttributeError as e:
            # Provide context about the proxy
            raise AttributeError(f"Proxy could not forward {name}") from e
```

## Testing and Debugging

### Debug Proxy for Development

```python
class DebugProxy:
    """Proxy with extensive debugging information."""
    
    def __init__(self, target, debug=True):
        super().__setattr__('target', target)
        super().__setattr__('debug', debug)
        super().__setattr__('access_count', {})

    def __getattribute__(self, name):
        if name in ('target', 'debug', 'access_count', 'get_stats'):
            return super().__getattribute__(name)
            
        debug = super().__getattribute__('debug')
        access_count = super().__getattribute__('access_count')
        target = super().__getattribute__('target')
        
        # Track access frequency
        access_count[name] = access_count.get(name, 0) + 1
        
        if debug:
            print(f"DEBUG: Accessing {name!r} (count: {access_count[name]})")
            
        try:
            return getattr(target, name)
        except AttributeError as e:
            if debug:
                print(f"DEBUG: Failed to access {name!r}")
            raise

    def get_stats(self):
        """Return access statistics."""
        access_count = super().__getattribute__('access_count')
        return dict(access_count)

# Usage
>>> cv = ColoredVector(red=23, green=44, blue=238)
>>> debug_proxy = DebugProxy(cv)
>>> debug_proxy.red
```

```python
DEBUG: Accessing 'red' (count: 1)
23
```

```python
>>> debug_proxy.red
```

```python
DEBUG: Accessing 'red' (count: 2)
23
```

```python
>>> debug_proxy.get_stats()
```

```python
{'red': 2}
```

## Real-World Applications

### Database ORM Proxy

```python
class ORMProxy:
    """Simplified ORM-style proxy that tracks changes."""
    
    def __init__(self, target):
        super().__setattr__('target', target)
        super().__setattr__('changes', {})
        super().__setattr__('original_values', {})

    def __getattribute__(self, name):
        if name in ('target', 'changes', 'original_values', 'save', 'rollback'):
            return super().__getattribute__(name)
            
        target = super().__getattribute__('target')
        return getattr(target, name)

    def __setattr__(self, name, value):
        if name in ('target', 'changes', 'original_values'):
            super().__setattr__(name, value)
            return
            
        target = super().__getattribute__('target')
        changes = super().__getattribute__('changes')
        original_values = super().__getattribute__('original_values')
        
        # Store original value if first change
        if name not in changes:
            try:
                original_values[name] = getattr(target, name)
            except AttributeError:
                original_values[name] = None
        
        # Track the change
        changes[name] = value
        
        # Apply to target
        setattr(target, name, value)

    def save(self):
        """Commit changes (clear change tracking)."""
        changes = super().__getattribute__('changes')
        original_values = super().__getattribute__('original_values')
        print(f"Saving changes: {changes}")
        changes.clear()
        original_values.clear()

    def rollback(self):
        """Rollback all changes."""
        target = super().__getattribute__('target')
        original_values = super().__getattribute__('original_values')
        changes = super().__getattribute__('changes')
        
        for name, original_value in original_values.items():
            if original_value is not None:
                setattr(target, name, original_value)
        
        print(f"Rolled back changes: {list(changes.keys())}")
        changes.clear()
        original_values.clear()
```

### Thread-Safe Proxy

```python
import threading

class ThreadSafeProxy:
    """Proxy that synchronizes all attribute access."""
    
    def __init__(self, target):
        super().__setattr__('target', target)
        super().__setattr__('lock', threading.RLock())

    def __getattribute__(self, name):
        if name in ('target', 'lock'):
            return super().__getattribute__(name)
            
        lock = super().__getattribute__('lock')
        with lock:
            target = super().__getattribute__('target')
            return getattr(target, name)

    def __setattr__(self, name, value):
        if name in ('target', 'lock'):
            super().__setattr__(name, value)
            return
            
        lock = super().__getattribute__('lock')
        with lock:
            target = super().__getattribute__('target')
            setattr(target, name, value)
```

## Key Takeaways

- **Power and Responsibility**: `__getattribute__` provides complete control over attribute access but requires careful implementation
- **Always Use `super()`**: Never access attributes directly within `__getattribute__` to avoid infinite recursion
- **Complete Implementation**: For proxies, implement `__setattr__` and `__delattr__` alongside `__getattribute__`
- **Performance Impact**: `__getattribute__` adds significant overhead to every attribute access
- **Consider Alternatives**: Use `__getattr__` instead if you only need to handle missing attributes
- **Exception Handling**: Provide clear error messages that indicate the proxy's role
- **Testing**: Thoroughly test edge cases, especially initialization and internal method access
- **Real-World Use**: Most useful for proxies, ORMs, debugging tools, and cross-cutting concerns like logging or validation

