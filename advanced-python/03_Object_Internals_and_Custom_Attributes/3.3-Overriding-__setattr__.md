# 3.3 Overriding `__setattr__`

## Key Ideas

- `__setattr__` is called for ALL attribute assignments
- Overriding `__setattr__` enables complete control over attribute modification
- Essential for creating truly immutable objects
- Must be carefully implemented to avoid breaking object initialization
- Complements `__getattr__` to provide comprehensive attribute control
- Can prevent the attribute assignment problems from the previous lesson

## The Problem from Previous Lesson

In lesson 3.2, we saw that `__getattr__` alone wasn't sufficient for immutability:

```python
>>> v = Vector(p=5, q=10)
>>> v.p = 13  # This created a new attribute, bypassing __getattr__
>>> v.p
13
>>> v._p      # Original private attribute unchanged
5
```

The assignment `v.p = 13` created a real `p` attribute, breaking our encapsulation.

## Solution: Overriding `__setattr__`

We can prevent unwanted attribute assignment by intercepting ALL attribute writes with `__setattr__`:

```python
class Vector:
    def __init__(self, **coords):
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def __getattr__(self, name):
        private_name = '_' + name
        return getattr(self, private_name)

    def __setattr__(self, name, value):
        raise AttributeError("Can't set attribute {!r}".format(name))

    def __repr__(self):
        return "{}({})".format(
            self.__class__.__name__,
            ', '.join("{}={}".format(k[1:], self.__dict__[k])
                     for k in sorted(self.__dict__.keys()))
        )
```

## How `__setattr__` Works

### Key Characteristics

- **Called for ALL assignments**: Unlike `__getattr__`, `__setattr__` intercepts every attribute assignment
- **No exceptions**: Even assignments during `__init__` go through `__setattr__`
- **Complete control**: Can validate, transform, or reject any attribute assignment
- **Dangerous if misused**: Can break object initialization if not handled properly

### Testing the Immutable Vector

```python
>>> v = Vector(p=5, q=10)
>>> v.p
5
>>> v.q
10
>>> v.p = 13  # Now this is prevented!
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    v.p = 13
AttributeError: Can't set attribute 'p'
>>> v.new_attr = 20  # All assignments are blocked
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    v.new_attr = 20
AttributeError: Can't set attribute 'new_attr'
```

## The Initialization Problem

The simple implementation above has a critical flaw - it prevents ALL attribute setting, including during initialization. This would break the `__init__` method:

```python
# This won't work because __init__ tries to set attributes
class BrokenVector:
    def __init__(self, **coords):
        # This line will fail because __setattr__ blocks everything!
        self.__dict__.update(coords)  # Calls __setattr__ internally
    
    def __setattr__(self, name, value):
        raise AttributeError("Can't set attribute")
```

## Proper `__setattr__` Implementation

### Solution 1: Initialization Flag

```python
class Vector:
    def __init__(self, **coords):
        self._initializing = True
        private_coords = {'_' + k: v for k, v in coords.items()}
        for name, value in private_coords.items():
            setattr(self, name, value)
        self._initializing = False

    def __getattr__(self, name):
        private_name = '_' + name
        return getattr(self, private_name)

    def __setattr__(self, name, value):
        if hasattr(self, '_initializing') and self._initializing:
            super().__setattr__(name, value)
        else:
            raise AttributeError("Can't set attribute {!r}".format(name))

    def __repr__(self):
        return "{}({})".format(
            self.__class__.__name__,
            ', '.join("{}={}".format(k[1:], self.__dict__[k])
                     for k in sorted(self.__dict__.keys())
                     if not k.startswith('_initializing'))
        )
```

### Solution 2: Direct Dictionary Manipulation

```python
class Vector:
    def __init__(self, **coords):
        # Bypass __setattr__ by directly modifying __dict__
        private_coords = {'_' + k: v for k, v in coords.items()}
        self.__dict__.update(private_coords)

    def __getattr__(self, name):
        private_name = '_' + name
        return getattr(self, private_name)

    def __setattr__(self, name, value):
        raise AttributeError("Can't set attribute {!r}".format(name))

    def __repr__(self):
        return "{}({})".format(
            self.__class__.__name__,
            ', '.join("{}={}".format(k[1:], self.__dict__[k])
                     for k in sorted(self.__dict__.keys()))
        )
```

### Solution 3: Allow Private Attributes

```python
class Vector:
    def __init__(self, **coords):
        private_coords = {'_' + k: v for k, v in coords.items()}
        for name, value in private_coords.items():
            setattr(self, name, value)

    def __getattr__(self, name):
        private_name = '_' + name
        return getattr(self, private_name)

    def __setattr__(self, name, value):
        if name.startswith('_'):
            # Allow private attributes
            super().__setattr__(name, value)
        else:
            # Block public attributes
            raise AttributeError("Can't set attribute {!r}".format(name))

    def __repr__(self):
        return "{}({})".format(
            self.__class__.__name__,
            ', '.join("{}={}".format(k[1:], self.__dict__[k])
                     for k in sorted(self.__dict__.keys()))
        )
```

## Advanced `__setattr__` Patterns

### Validation and Transformation

```python
class ValidatedVector:
    def __init__(self, **coords):
        self._coords = set()
        for name, value in coords.items():
            setattr(self, name, value)

    def __setattr__(self, name, value):
        if name.startswith('_'):
            super().__setattr__(name, value)
        else:
            # Validate numeric values
            if not isinstance(value, (int, float)):
                raise TypeError(f"Coordinate {name} must be numeric, got {type(value)}")
            
            # Store as private attribute
            private_name = '_' + name
            super().__setattr__(private_name, float(value))  # Convert to float
            
            # Track coordinate names
            if hasattr(self, '_coords'):
                self._coords.add(name)

    def __getattr__(self, name):
        if hasattr(self, '_coords') and name in self._coords:
            return getattr(self, '_' + name)
        raise AttributeError(f"No attribute {name}")

# Usage
>>> v = ValidatedVector(x=5, y=10)
>>> v.x = 3.14  # Validates and converts
>>> v.x
3.14
>>> v.x = "invalid"  # Validation fails
TypeError: Coordinate x must be numeric, got <class 'str'>
```

### Read-Only Properties

```python
class ConfigurableVector:
    def __init__(self, readonly=False, **coords):
        self._readonly = readonly
        self._coords = set()
        for name, value in coords.items():
            setattr(self, name, value)

    def __setattr__(self, name, value):
        if name.startswith('_'):
            super().__setattr__(name, value)
        elif hasattr(self, '_readonly') and self._readonly:
            raise AttributeError("Vector is read-only")
        else:
            # Normal attribute setting
            private_name = '_' + name
            super().__setattr__(private_name, value)
            if hasattr(self, '_coords'):
                self._coords.add(name)

    def __getattr__(self, name):
        if hasattr(self, '_coords') and name in self._coords:
            return getattr(self, '_' + name)
        raise AttributeError(f"No attribute {name}")

# Usage
>>> v1 = ConfigurableVector(x=1, y=2)  # Mutable
>>> v1.x = 10  # OK
>>> v2 = ConfigurableVector(readonly=True, x=1, y=2)  # Immutable
>>> v2.x = 10  # Raises AttributeError
```

## Comparison with Property Decorators

### `__setattr__` vs `@property`

| Feature | `__setattr__` | `@property` |
|---------|---------------|-------------|
| **Scope** | All attributes | Specific attributes |
| **Dynamic** | Yes | No (defined at class time) |
| **Performance** | Slower (method call) | Faster |
| **Flexibility** | High | Medium |
| **Complexity** | High | Low |

### When to Use Each

**Use `__setattr__` when:**
- You need dynamic attribute names (unknown at class definition time)
- You want to control ALL attribute access uniformly
- You're building proxy objects or metaclass-like behavior

**Use `@property` when:**
- You have specific, known attributes to control
- You want better performance
- You prefer explicit, readable code

## Best Practices

**1. Always Handle Initialization**

```python
def __setattr__(self, name, value):
    if name.startswith('_') or not hasattr(self, '_initialized'):
        super().__setattr__(name, value)
    else:
        # Your custom logic here
        pass
```

**2. Use `super().__setattr__()` for Allowed Assignments**

```python
def __setattr__(self, name, value):
    if self._should_allow(name, value):
        super().__setattr__(name, value)  # Don't call setattr(self, name, value)!
    else:
        raise AttributeError("Not allowed")
```

**3. Provide Clear Error Messages**

```python
def __setattr__(self, name, value):
    if self._is_readonly:
        raise AttributeError(f"Cannot modify '{name}' - object is read-only")
    if not self._is_valid_name(name):
        raise AttributeError(f"Invalid attribute name: '{name}'")
    # Continue with setting...
```

**4. Consider Performance Impact**

```python
# Cache validation results when possible
class OptimizedVector:
    def __init__(self):
        self._valid_names = set()
    
    def __setattr__(self, name, value):
        if name in self._valid_names or self._validate_once(name):
            super().__setattr__(name, value)
        else:
            raise AttributeError(f"Invalid attribute: {name}")
```

## Key Takeaways

- `__setattr__` is called for ALL attribute assignments, providing complete control
- Essential complement to `__getattr__` for creating truly immutable objects
- Must carefully handle initialization to avoid breaking object creation
- More powerful but more complex than property decorators
- Use direct `__dict__` manipulation or initialization flags to handle setup
- Always use `super().__setattr__()` for allowed assignments to avoid recursion
- Provides foundation for advanced patterns like validation, transformation, and proxying
- Consider performance implications for frequently modified objects

    