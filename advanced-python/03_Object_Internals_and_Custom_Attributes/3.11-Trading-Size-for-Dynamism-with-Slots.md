# 3.11 Trading Size for Dynamism with Slots

## Key Ideas

- Python objects store attributes in dictionaries, which consume significant memory (288 bytes for empty dict)
- `__slots__` mechanism reduces memory usage by eliminating per-instance `__dict__`
- Slots provide substantial memory savings but remove dynamic attribute addition
- Use slots only when measurements indicate memory issues - they have interaction tradeoffs
- Slots represent a pragmatic compromise between Python's dynamism and memory efficiency

## The Memory Problem

Every Python object stores its attributes in a dictionary, which is memory-expensive:

```python
>>> import sys
>>> d = {}
>>> sys.getsizeof(d)
288
```

With thousands or millions of objects, this quickly adds up to megabytes or gigabytes of memory usage, leading to reduced performance as CPU caches can hold fewer objects.

## Regular Class Memory Usage

Consider a simple `Resistor` class representing electronic components:

```python
class Resistor:

    def __init__(self, resistance_ohms, tolerance_percent, power_watts):
        self.resistance_ohms = resistance_ohms
        self.tolerance_percent = tolerance_percent
        self.power_watts = power_watts
```

### Memory Measurement

To measure memory usage, we need to account for both the object and its `__dict__`:

```python
>>> from resistor import *
>>> r10 = Resistor(10, 5, 0.25)
>>> import sys
>>> sys.getsizeof(r10) + sys.getsizeof(r10.__dict__)
152

>>> r10.cost_dollars = 0.02
>>> sys.getsizeof(r10) + sys.getsizeof(r10.__dict__)
248
```

The initial object weighs 152 bytes, but adding a single attribute increases it to 248 bytes. Compare this to a C struct which would use no more than 64 bytes.

## Using `__slots__` for Memory Optimization

To use slots, declare a `__slots__` class attribute:

```python
class Resistor:

    __slots__ = ['resistance_ohms', 'tolerance_percent', 'power_watts']

    def __init__(self, resistance_ohms, tolerance_percent, power_watts):
        self.resistance_ohms = resistance_ohms
        self.tolerance_percent = tolerance_percent
        self.power_watts = power_watts
```

### Memory Savings with Slots

```python
>>> from resistor import *
>>> r10 = Resistor(10, 5, 0.25)
>>> r10.tolerance_percent
5

>>> r10.power_watts
0.25

>>> sys.getsizeof(r10)
64

>>> r10.cost_dollars = 0.02
Traceback (most recent call last):
  File "<input>", line 1, in <module>
AttributeError: 'Resistor' object has no attribute 'cost_dollars'
```

**Benefits:**
- Memory usage reduced from 152 bytes to 64 bytes (less than half)
- Attribute access works exactly the same way

**Tradeoffs:**
- No dynamic attribute addition allowed
- No `__dict__` attribute available

### No More `__dict__`

```python
>>> r10.__dict__
Traceback (most recent call last):
  File "<input>", line 1, in <module>
AttributeError: 'Resistor' object has no attribute '__dict__'
```

## When to Use Slots

**Use slots when:**
- Measurements indicate memory usage problems
- You have thousands or millions of objects
- The memory savings are significant for your application

**Avoid slots when:**
- You need dynamic attribute addition
- Memory usage is not a concern
- You haven't measured the actual benefit

**Important considerations:**
- Slots can interact with other Python features in surprising ways
- They can affect diagnostic tools
- They're considered an "ugly" but necessary language feature

## Key Takeaways

- **Memory efficiency**: Slots can reduce memory usage by 50% or more
- **Dynamic limitation**: Slots prevent runtime attribute addition
- **Pragmatic tool**: Use slots only when measurements justify the tradeoffs
- **Performance impact**: Memory savings can improve CPU cache efficiency
- **Design philosophy**: Slots represent a compromise between Python's flexibility and performance needs

**Best practice**: Don't use slots unless measurements indicate they will help. When they do help, they can make the difference between staying in Python vs. moving to a lower-level language.

