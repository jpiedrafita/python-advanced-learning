# 6.6 A Practical Metaclass Example

## Key Ideas

- **Problem Solution**: Metaclasses can solve practical problems like detecting duplicate class attribute definitions
- **Custom Namespace**: Using `__prepare__` to provide specialized dictionaries for class construction
- **Error Prevention**: Implement validation during class definition rather than runtime
- **Improved Diagnostics**: Custom error messages provide better debugging information

## The Duplicate Attribute Problem

Python silently allows duplicate class attribute definitions, with later definitions overwriting earlier ones:

```python
class Dodgy():
    def method(self):
        return "first definition"

    def method(self):
        return "second definition"
```

```python
>>> from duplicatesmeta import *
>>> dodgy = Dodgy()
>>> dodgy.method()
'second definition'
```

**Problem Analysis**: The second `method` definition overwrites the first in the namespace dictionary during class processing, with no error notification.

## Solution: Custom Dictionary for Class Namespace

To prevent duplicate attribute assignments, we need a specialized dictionary that raises errors on key reassignment: 

```python
class OneShotDict(dict):

    def __init__(self, existing=None):
        super().__init__()
        if existing is not None:
            for k, v in existing:
                self[k] = v

    def __setitem__(self, key, value):
        if key in self:
            raise ValueError("Cannot assign to existing key {!r}".format(key))
        super().__setitem__(key, value)
```

**OneShotDict Implementation**:
- **Inheritance**: Specializes the built-in `dict` type
- **Simplified Initializer**: Accepts optional existing key-value pairs
- **Assignment Protection**: Overrides `__setitem__` to prevent key reassignment
- **Error Mechanism**: Raises `ValueError` when attempting to assign to existing keys

### Testing OneShotDict Behavior

```python
>>> from duplicatesmeta import OneShotDict
>>> d = OneShotDict()
>>> d['A'] = 65
>>> d['B'] = 66
>>> d['A'] = 32
Traceback (most recent call last):
  File "<input>", line 1, in <module>
  File "/Users/rjs/training/tmp/metaclass/duplicatesmeta.py", line 12, in __setitem__
    raise ValueError("Cannot assign to existing key {!r}".format(key))
ValueError: Cannot assign to existing key 'A'
```

**Verification**: The `ValueError` is triggered as expected when attempting key reassignment.

## Implementing the Duplicate Prevention Metaclass

```python
class ProhibitDuplicatesMeta(type):

    @classmethod
    def __prepare__(mcs, name, bases):
        return OneShotDict()


class Dodgy(metaclass=ProhibitDuplicatesMeta):

    def method(self):
        return "first definition"

    def method(self):
        return "second definition"
```

**Implementation Strategy**:
- **Override `__prepare__`**: Return `OneShotDict` instance instead of regular dictionary
- **Automatic Protection**: Classes using this metaclass automatically prevent duplicate attribute definitions

### Initial Error Detection

```python
>>> from duplicatesmeta import *
Traceback (most recent call last):
  File "<input>", line 1, in <module>
  File "/Applications/PyCharm.app/Contents/helpers/pydev/pydev_import_hook.py", line 21, in do_import
    module = self._system_import(name, *args, **kwargs)
  File "/Users/rjs/training/tmp/metaclass/duplicatesmeta.py", line 23, in <module>
    class Dodgy(metaclass=ProhibitDuplicatesMeta):
  File "/Users/rjs/training/tmp/metaclass/duplicatesmeta.py", line 28, in Dodgy
    def method(self):
  File "/Users/rjs/training/tmp/metaclass/duplicatesmeta.py", line 12, in __setitem__
    raise ValueError("Cannot assign to existing key 'method'
ValueError: Cannot assign to existing key 'method'
```

**Limitation**: The error message lacks context about which class contains the duplicate attribute.

## Improved Solution: Enhanced Error Messages

To provide better diagnostics, we create a specialized namespace class with more informative error messages:

```python
class OneShotClassNamespace(dict):

    def __init__(self, name, existing=None):
        super().__init__()
        self._name = name
        if existing is not None:
            for k, v in existing:
                self[k] = v

    def __setitem__(self, key, value):
        if key in self:
            raise TypeError("Cannot reassign existing class attribute {!r} of {!r}".format(key, self._name))
        super().__setitem__(key, value)
```

**Enhanced Features**:
- **Class Name Context**: Accepts and stores the class name being defined
- **Better Error Type**: Uses `TypeError` instead of `ValueError` (more appropriate for this context)
- **Informative Messages**: Includes both attribute name and class name in error messages
- **Diagnostic Information**: Provides context about where the duplicate occurs

### Updated Metaclass Implementation

```python
class ProhibitDuplicatesMeta(type):

    @classmethod
    def __prepare__(mcs, name, bases):
        return OneShotClassNamespace(name)
```

**Key Change**: Forward the class name from `__prepare__` to the `OneShotClassNamespace` constructor for better error reporting.

### Final Result with Improved Error Messages

```python
>>> from duplicatesmeta import *
Traceback (most recent call last):
  File "<input>", line 1, in <module>
  File "/Applications/PyCharm.app/Contents/helpers/pydev/pydev_import_hook.py", line 21, in do_import
    module = self._system_import(name, *args, **kwargs)
  File "/Users/rjs/training/tmp/metaclass/duplicatesmeta.py", line 24, in <module>
    class Dodgy(metaclass=ProhibitDuplicatesMeta):
  File "/Users/rjs/training/tmp/metaclass/duplicatesmeta.py", line 29, in Dodgy
    def method(self):
  File "/Users/rjs/training/tmp/metaclass/duplicatesmeta.py", line 13, in __setitem__
    raise TypeError("Cannot reassign existing class attribute {!r} of {!r}".format(key, self._name))
TypeError: Cannot reassign existing class attribute 'method' of 'Dodgy'
```

**Improved Diagnostics**: The error message now clearly identifies both the duplicate attribute name (`'method'`) and the class where it occurs (`'Dodgy'`).

## Summary

This practical metaclass example demonstrates:

- **Problem Identification**: Detecting silent duplicate attribute definitions in Python classes
- **Custom Namespace Usage**: Leveraging `__prepare__` to provide specialized dictionaries for class construction
- **Error Prevention**: Catching problems at class definition time rather than runtime
- **Progressive Improvement**: Enhancing error messages with contextual information for better debugging
- **Practical Application**: Solving real-world issues that developers encounter in Python codebases

**Key Takeaway**: Metaclasses provide powerful mechanisms for enforcing coding standards and preventing common errors at the language level.
