# 5.2 Allocation with __new__()

## Key Ideas

- `__new__` signature takes `cls` as first parameter, not `self`
- `__new__` is a special-cased static method that receives the class as first argument
- Constructor arguments are forwarded to both `__new__` and `__init__`
- Object allocation must be done through `object.__new__` - there's no other way
- The object returned by `__new__` becomes the `self` parameter in `__init__`
- Use `super().__new__(cls)` for maintainable base class delegation

## Discovering the `__new__` Signature

Let's implement a basic `__new__` override that delegates to the base class while inspecting arguments and return values.

### Basic `__new__` Override

```python
class ChessCoordinate:
    def __new__(cls, *args, **kwargs):
        print("args =", repr(args))
        print("kwargs =", repr(kwargs))
        obj = super().__new__(cls)
        print("id(obj) =", id(obj))
        return obj
```

### Key Observations about `__new__`

**Class method behavior**: `__new__` appears to be implicitly a class method - it accepts `cls` as its first argument rather than `self`.

**Actually a static method**: In fact, `__new__` is a special-cased static method that happens to take the class type as its first argument, but this distinction isn't important for practical use.

**The `cls` parameter**: This is the class of the new object to be allocated. In our case, it will be `ChessCoordinate`, but with inheritance, `cls` isn't necessarily the class that defines the `__new__` method.

## Handling Constructor Arguments

`__new__` accepts whatever parameters have been passed to the constructor:

- We can use `*args` and `**kwargs` to capture all arguments
- Alternatively, we could use specific argument names (just like in `__init__`)
- These arguments get forwarded from the constructor call

## Object Allocation Process

### The Core Principle
**There's no special command for object allocation in Python.** All object allocation must be done by the `__new__` implementation on the ultimate base class `object`.

### Best Practice: Use `super()`
```python
obj = super().__new__(cls)  # Recommended approach
```

Rather than calling `object.__new__` directly, we use `super()`. This is more maintainable should our immediate base class change in the future.

### Return Value
The return value from `object.__new__` is the new instance of `ChessCoordinate`. We print its `id()` for demonstration (we can't use `repr()` yet since the object isn't initialized).

## Connecting `__new__` to `__init__`

The object returned by `__new__` becomes the `self` argument passed to `__init__`.

### Modified `__init__` for Demonstration

```python
def __init__(self, file, rank):
    print("id(self)", id(self))
    
    if len(file) != 1:
        raise ValueError("{} component file {!r} does not have a length of one."
                         .format(self.__class__.__name__, file))
    if file not in 'abcdefgh':
        raise ValueError("{} component file {!r} is out of range."
                         .format(self.__class__.__name__, file))

    if rank not in range(1, 9):
        raise ValueError("{} component rank {!r} is out of range."
                         .format(self.__class__.__name__, rank))

    self._file = file
    self._rank = rank
```

## Verification: Tracing the Object Flow

Running the code demonstrates the connection:

```bash
> python chess.py
args = ('d', 4)
kwargs = {}
id(obj) = 4323365832
id(self) = 4323365832
d4
```

### What This Shows

1. **Arguments forwarded**: Constructor arguments `('d', 4)` are passed to `__new__`
2. **Same object**: The `id(obj)` in `__new__` equals `id(self)` in `__init__`
3. **Successful flow**: The object flows correctly from allocation to initialization

## Key Takeaways

- **Signature pattern**: `__new__(cls, *args, **kwargs)` is the standard signature
- **Class-level method**: Takes the class as first parameter, not an instance
- **Argument forwarding**: Constructor arguments go to both `__new__` and `__init__`
- **Base class delegation**: Always use `super().__new__(cls)` for allocation
- **Object identity**: The same object flows from `__new__` to `__init__`
- **No alternatives**: `object.__new__` is the only way to allocate objects in Python
- **Return requirement**: `__new__` must return the allocated souobject
