# 5.1 Instance Creation

## Key Ideas

- Object creation involves two phases: `__new__` creates the object, `__init__` initializes it
- `__init__` is **not** the constructor - it's just the initializer
- `__new__` is the actual constructor that allocates memory for the object
- By the time `__init__` runs, the object already exists with the correct type
- Most classes inherit `__new__` from the base `object` class
- Understanding this separation enables fine control over instance creation

## What Happens During Object Creation?

We'll explore instance creation using a chess coordinate class that models positions on a chess board.

### The ChessCoordinate Class

```python
class ChessCoordinate:

    def __init__(self, file, rank):
        if len(file) != 1:
            raise ValueError("{} component file {!r} does not have a length of one."
                             .format(self.__class__.__name__, file))

        if file not in 'abcdefgh':
            raise ValueError("{} component file {!r} is out of range."
                             .format(self.__class__.__name__, file))

        if rank not in range(1, 9):
            raise ValueError("{} component rank {!r} is out of range."
                             .format(self.__class__.__name__, rank))

        self._file = file
        self._rank = rank

    @property
    def file(self):
        return self._file

    @property
    def rank(self):
        return self._rank

    def __repr__(self):
        return "{}(file={}, rank={})".format(self.__class__.__name__, self.file, self.rank)

    def __str__(self):
        return '{}{}'.format(self.file, self.rank)

def main():
    white_queen = ChessCoordinate('d', 4)
    print(white_queen)
```

This class implements an **immutable value type**:
- The initializer establishes invariants through validation
- Property accessors prevent inadvertent modification of encapsulated data

## The Key Insight: `__init__` is NOT the Constructor

It's easy to think of `__init__` as the constructor implementation, but this is **incorrect**. Let's examine what actually happens when we create an instance:

```python
white_queen = ChessCoordinate('d', 4)  # Creating instance at coordinate (d, 4)
```

### Debugging the Creation Process

When stepping through with a debugger and pausing on the first line of `__init__`:

```python
# Debugger paused at:
if len(file) != 1:
```

**Key observation**: The `self` parameter in `__init__` **already refers to an existing object**.

- The object has already been constructed
- `__init__` only **initializes** the already-created object
- `type(self)` shows the object already has the correct type
- `self.__dict__` shows an empty instance dictionary (not yet initialized)

### What `__init__` Actually Does

As we step through the initializer:
1. The instance dictionary gets populated by assignments to `self` attributes
2. Behind the scenes, `object.__setattr__` is being called
3. `__init__` **doesn't return anything** - it simply mutates the given instance

## Finding the Real Constructor: `__new__`

If `__init__` isn't responsible for creating the instance, what is?

### Discovering `__new__`

```python
>>> dir(ChessCoordinate)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__firstlineno__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__static_attributes__', '__str__', '__subclasshook__', '__weakref__', 'file', 'rank']
```

Notice `__new__` in the method list - this is the actual constructor.

### Inherited from `object`

```python
>>> ChessCoordinate.__new__
<built-in method __new__ of type object at 0x10570f9b0>

>>> ChessCoordinate.__new__ is object.__new__
True
```

**Key findings**:
- We haven't defined `__new__` ourselves
- We inherit the implementation from the universal base class `object`
- The base class implementation of `__new__` is responsible for allocating our object
- `ChessCoordinate.__new__` is exactly the same method as `object.__new__`

## The Two-Phase Creation Process

1. **`__new__` (Construction)**: Allocates memory and creates the object instance
2. **`__init__` (Initialization)**: Initializes the already-created object with data

## What's Next?

Understanding `__new__` opens up possibilities for customizing object creation in powerful ways. The signature and behavior of `__new__` will be explored through overriding it in subsequent lessons.

## Key Takeaways

- **Terminology correction**: `__init__` is the initializer, not the constructor
- **Real constructor**: `__new__` is responsible for actual object creation
- **Two-phase process**: Creation happens before initialization
- **Inherited behavior**: Most classes use `object.__new__` for basic allocation
- **Debugging insight**: Objects exist before `__init__` runs
- **Customization potential**: Understanding `__new__` enables advanced object creation patterns
