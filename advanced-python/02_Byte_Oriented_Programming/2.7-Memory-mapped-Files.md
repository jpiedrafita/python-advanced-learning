# 2.7 Memory-mapped Files

## Key Ideas

- Memory-mapped files eliminate the need to read entire files into memory
- The OS virtual memory system handles loading and discarding data pages on-demand
- Python's mmap module provides memory-mapped file functionality
- mmap objects support the buffer protocol and work with memoryview
- Page-based access (typically 4KB pages) makes large file processing memory-efficient
- Reference counting in the buffer protocol requires careful lifetime management

## The Problem: File-to-Memory Copying

Even with memoryview eliminating internal copying, one copy still occurs:

```python
# Still one copy happening here
with open('colors.bin', 'rb') as f:
    buffer = f.read()  # File contents copied to bytes object
```

For large files, this file-to-memory transfer can be prohibitive in terms of both memory usage and performance.

## Memory-Mapped Files Solution

Memory-mapped files use the operating system's virtual memory system to make files appear as if they're in memory without actually loading the entire file.

### How It Works

1. **Virtual Memory Mapping**: File contents are mapped to virtual memory addresses
2. **Page-Based Loading**: OS loads only needed pages (typically 4KB) on demand
3. **Automatic Management**: OS handles loading, discarding, and syncing pages
4. **Efficient Access**: Small portions of large files can be accessed efficiently

## The mmap Module

The `mmap` module provides a single class that behaves like a hybrid between a bytearray and a file-like object.

### Basic Usage

```python
import mmap

def main():
    with open('colors.bin', 'rb') as f:
        with mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ) as buffer:
            print("buffer: {} bytes".format(len(buffer)))

            # Diagnostic output (same as before)
            indexes = ' '.join(str(n).zfill(2) for n in range(len(buffer)))
            print(indexes)

            hex_buffer = hexlify(buffer).decode('ascii')
            hex_pairs = ' '.join(hex_buffer[i:i+2] for i in range(0, len(hex_buffer), 2))
            print(hex_pairs)

            # Create memoryview from mmap
            mem = memoryview(buffer)

            VERTEX_SIZE = 18
            VERTEX_STRIDE = VERTEX_SIZE + 2

            vertex_mems = [mem[i:i+VERTEX_SIZE] for i in range(0, len(mem), VERTEX_STRIDE)]
            vertices = [make_colored_vertex(vertex_mem) for vertex_mem in vertex_mems]

            pp(vertices)
```

### mmap Constructor Parameters

- **File descriptor**: `f.fileno()` gets the underlying file descriptor/handle
- **Length**: `0` means map the entire file
- **Access mode**: `mmap.ACCESS_READ` for read-only access

## Buffer Protocol Integration

mmap objects support the C API buffer protocol, making them compatible with memoryview:

```python
# mmap object can be used directly with memoryview
buffer = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)
mem = memoryview(buffer)  # Works seamlessly
```

## Reference Counting and Lifetime Management

### The Problem: Exported Pointers

When the mmap context manager closes, you may encounter:

```
BufferError: cannot close exported pointers exist
```

This occurs because memoryview objects still reference the mmap object.

### Understanding the Object Graph

```python
# These objects maintain references to the mmap:
mem = memoryview(buffer)           # Direct reference
vertices = [vertex1, vertex2, ...]  # Indirect references through Vector/Color objects
```

### Solution: Explicit Cleanup

```python
def main():
    with open('colors.bin', 'rb') as f:
        with mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ) as buffer:
            # ... processing code ...
            
            # Clean up references before context manager closes
            del vertices  # Remove vertex objects
            del mem       # Remove memoryview
            
            # Now mmap can close safely
```

### Design Principle

**The lifetime of memory-mapped file backed objects must be shorter than the lifetime of the memory mapping.**

## Complete Working Example

```python
import mmap
from binascii import hexlify
from pprint import pprint as pp

class Vector:
    def __init__(self, mem_float32):
        if mem_float32.format not in "fd":
            raise TypeError("Vector: memoryview values must be floating-point numbers")
        if len(mem_float32) < 3:
            raise TypeError("Vector: memoryview must contain at least 3 floats")
        self._mem = mem_float32

    @property
    def x(self):
        return self._mem[0]

    @property
    def y(self):
        return self._mem[1]

    @property
    def z(self):
        return self._mem[2]

    def __repr__(self):
        return 'Vector({}, {}, {})'.format(self.x, self.y, self.z)

class Color:
    def __init__(self, mem_uint16):
        if mem_uint16.format not in "HILQ":
            raise TypeError("Color: memoryview values must be unsigned integers")
        if len(mem_uint16) < 3:
            raise TypeError("Color: memoryview must contain at least 3 integers")
        self._mem = mem_uint16

    @property
    def red(self):
        return self._mem[0]

    @property
    def green(self):
        return self._mem[1]

    @property
    def blue(self):
        return self._mem[2]

    def __repr__(self):
        return 'Color({}, {}, {})'.format(self.red, self.green, self.blue)

class Vertex:
    def __init__(self, vector, color):
        self.vector = vector
        self.color = color

    def __repr__(self):
        return 'Vertex({!r}, {!r})'.format(self.vector, self.color)

def make_colored_vertex(mem_vertex):
    mem_vector = mem_vertex[0:12].cast('f')
    mem_color = mem_vertex[12:18].cast('H')
    return Vertex(Vector(mem_vector), Color(mem_color))

def main():
    with open('colors.bin', 'rb') as f:
        with mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ) as buffer:
            print("buffer: {} bytes".format(len(buffer)))

            indexes = ' '.join(str(n).zfill(2) for n in range(len(buffer)))
            print(indexes)

            hex_buffer = hexlify(buffer).decode('ascii')
            hex_pairs = ' '.join(hex_buffer[i:i+2] for i in range(0, len(hex_buffer), 2))
            print(hex_pairs)

            mem = memoryview(buffer)

            VERTEX_SIZE = 18
            VERTEX_STRIDE = VERTEX_SIZE + 2

            vertex_mems = [mem[i:i+VERTEX_SIZE] for i in range(0, len(mem), VERTEX_STRIDE)]
            vertices = [make_colored_vertex(vertex_mem) for vertex_mem in vertex_mems]

            pp(vertices)
            
            # Clean up before mmap closes
            del vertices
            del mem

if __name__ == '__main__':
    main()
```

## mmap Access Modes

### Read-Only Access

```python
# Read-only mapping
buffer = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)
```

### Read-Write Access

```python
# Read-write mapping (file must be opened in read-write mode)
with open('data.bin', 'r+b') as f:
    buffer = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_WRITE)
    buffer[0] = 255  # Modify the file through the mapping
```

### Copy-on-Write Access

```python
# Changes don't affect the original file
buffer = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_COPY)
buffer[0] = 255  # Only affects the mapping, not the file
```

## Advanced mmap Features

### Partial File Mapping

```python
# Map only a portion of the file
with open('large_file.bin', 'rb') as f:
    # Map 1MB starting at offset 1024
    buffer = mmap.mmap(f.fileno(), 1024*1024, offset=1024)
```

### Cross-Platform Considerations

```python
import mmap
import os

def create_mmap(filename, mode='rb', access=mmap.ACCESS_READ):
    """Cross-platform mmap creation."""
    with open(filename, mode) as f:
        if os.name == 'nt':  # Windows
            return mmap.mmap(f.fileno(), 0, access=access)
        else:  # Unix-like systems
            return mmap.mmap(f.fileno(), 0, prot=mmap.PROT_READ)
```

## Performance Characteristics

### Memory Usage Comparison

| Approach | Memory Usage | File Access |
|----------|---------------|-------------|
| `f.read()` | Full file size | One-time copy |
| `mmap` | Page-based (4KB) | On-demand loading |

### When to Use mmap

**Good for:**
- Large files where you access small portions
- Random access patterns
- Files larger than available RAM
- Shared access between processes

**Not ideal for:**
- Small files (overhead not worth it)
- Sequential reading of entire file
- Frequent small writes (page faults)

## Practical Examples

### Large Binary File Processing

```python
def process_large_binary_file(filename):
    """Process a large binary file efficiently."""
    with open(filename, 'rb') as f:
        with mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ) as buffer:
            mem = memoryview(buffer)
            
            # Process file in chunks
            chunk_size = 64 * 1024  # 64KB chunks
            for i in range(0, len(mem), chunk_size):
                chunk = mem[i:i+chunk_size]
                yield process_chunk(chunk)
            
            del mem  # Clean up
```

### Memory-Mapped Database Records

```python
class RecordView:
    """View into a memory-mapped database file."""
    
    def __init__(self, mmap_buffer, record_size):
        self.buffer = mmap_buffer
        self.record_size = record_size
        self.mem = memoryview(mmap_buffer)
    
    def get_record(self, index):
        """Get a specific record without copying."""
        start = index * self.record_size
        end = start + self.record_size
        return self.mem[start:end]
    
    def __len__(self):
        return len(self.buffer) // self.record_size
    
    def cleanup(self):
        del self.mem
```

### Shared Memory Between Processes

```python
import mmap
import os

def create_shared_memory(name, size):
    """Create shared memory region."""
    # Create a temporary file
    fd = os.open(name, os.O_CREAT | os.O_RDWR)
    os.ftruncate(fd, size)
    
    # Memory map the file
    buffer = mmap.mmap(fd, size, access=mmap.ACCESS_WRITE)
    os.close(fd)  # Can close file descriptor, mmap keeps it alive
    
    return buffer
```

## Error Handling

### Common Errors and Solutions

```python
def safe_mmap_processing(filename):
    """Robust mmap processing with error handling."""
    try:
        with open(filename, 'rb') as f:
            try:
                with mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ) as buffer:
                    mem = memoryview(buffer)
                    try:
                        # Process data
                        result = process_data(mem)
                        return result
                    finally:
                        del mem  # Always clean up
                        
            except mmap.error as e:
                print(f"mmap error: {e}")
                # Fall back to regular file reading
                f.seek(0)
                return process_data(f.read())
                
    except IOError as e:
        print(f"File error: {e}")
        return None
```

## Best Practices

### 1. Always Use Context Managers

```python
# Good: Automatic cleanup
with mmap.mmap(f.fileno(), 0) as buffer:
    # Use buffer
    pass  # Automatically closed

# Avoid: Manual cleanup
buffer = mmap.mmap(f.fileno(), 0)
try:
    # Use buffer
    pass
finally:
    buffer.close()  # Easy to forget
```

### 2. Explicit Reference Management

```python
def process_with_cleanup():
    with mmap.mmap(f.fileno(), 0) as buffer:
        mem = memoryview(buffer)
        objects = create_objects(mem)
        
        # Process objects
        result = process_objects(objects)
        
        # Clean up before mmap closes
        del objects
        del mem
        
        return result
```

### 3. Check File Size Before Mapping

```python
def smart_file_processing(filename):
    """Choose processing method based on file size."""
    file_size = os.path.getsize(filename)
    
    if file_size < 1024 * 1024:  # < 1MB
        # Small file: regular reading is fine
        with open(filename, 'rb') as f:
            return process_data(f.read())
    else:
        # Large file: use mmap
        with open(filename, 'rb') as f:
            with mmap.mmap(f.fileno(), 0) as buffer:
                return process_data_mmap(buffer)
```

## Key Takeaways

- Memory-mapped files eliminate file-to-memory copying for large files
- OS handles page-based loading and unloading automatically (typically 4KB pages)
- mmap objects support the buffer protocol and work seamlessly with memoryview
- Reference counting requires careful lifetime management with explicit cleanup
- Best suited for large files with random or sparse access patterns
- Context managers provide automatic resource management
- Cross-platform considerations may require different approaches
- Fallback strategies should handle mmap errors gracefully
