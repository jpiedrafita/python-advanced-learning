# 2.2 Byte-wise Operations with Integers
# 2.2 Byte-wise Operations with Integers

## Key Idea

- **Convert integers to bytes** using the `to_bytes()` method for byte-oriented representation.
- **Control byte order** with endianness specification (big-endian vs little-endian).
- **Handle negative integers** with Two's Complement representation using the `signed` parameter.
- **Convert bytes back to integers** using the `from_bytes()` class method.

## Converting Integers to Bytes

### Basic `to_bytes()` Method

The `to_bytes()` method converts an integer to a bytes object with explicit control over length and byte order.

```python
>>> int(0xcafebabe).to_bytes(length=4, byteorder='big')
b'\xca\xfe\xba\xbe'
>>> int(0xcafebabe).to_bytes(length=4, byteorder='little')
b'\xbe\xba\xfe\xca'
```

**Parameters**:
- **length**: Number of bytes in the result
- **byteorder**: `'big'` (most significant byte first) or `'little'` (least significant byte first)

### Endianness Explanation

**Big-endian** (network byte order):
```python
>>> int(0xcafebabe).to_bytes(length=4, byteorder='big')
b'\xca\xfe\xba\xbe'  # Most significant byte first
>>> hex(0xca)  # First byte (most significant)
'0xca'
>>> hex(0xbe)  # Last byte (least significant)
'0xbe'
```

**Little-endian** (Intel x86 order):
```python
>>> int(0xcafebabe).to_bytes(length=4, byteorder='little')
b'\xbe\xba\xfe\xca'  # Least significant byte first
>>> hex(0xbe)  # First byte (least significant)
'0xbe'
>>> hex(0xca)  # Last byte (most significant)
'0xca'
```

### Detecting System Byte Order

```python
>>> import sys
>>> sys.byteorder
'little'  # On most modern machines

# Using native byte order with the course example
>>> little_cafebabe = int(0xcafebabe).to_bytes(length=4, byteorder=sys.byteorder)
>>> little_cafebabe
b'\xbe\xba\xfe\xca'  # Little-endian on this machine
```

**Common byte orders**:
- **Big-endian**: Network protocols, ARM (sometimes), PowerPC
- **Little-endian**: x86, x86-64, ARM (sometimes)

## Converting Bytes to Integers

### Using `from_bytes()` Class Method

```python
>>> little_cafebabe = b'\xbe\xba\xfe\xca'
>>> int.from_bytes(little_cafebabe, byteorder='little')
3405691582
>>> hex(_)
'0xcafebabe'

# With big-endian
>>> big_cafebabe = b'\xca\xfe\xba\xbe'
>>> int.from_bytes(big_cafebabe, byteorder='big')
3405691582
>>> hex(_)
'0xcafebabe'
```

### Round-trip Conversion Example

```python
>>> original = 0xcafebabe
>>> hex(original)
'0xcafebabe'

# Convert to bytes using system byte order and back
>>> little_cafebabe = int(0xcafebabe).to_bytes(length=4, byteorder=sys.byteorder)
>>> little_cafebabe
b'\xbe\xba\xfe\xca'
>>> int.from_bytes(little_cafebabe, byteorder=sys.byteorder)
3405691582
>>> hex(_)
'0xcafebabe'
>>> original == 3405691582
True
```

## Handling Negative Integers

### Problem with Negative Numbers

By default, `to_bytes()` fails with negative integers:

```python
>>> int(-241).to_bytes(2, byteorder='big')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
OverflowError: can't convert negative int to unsigned
```

### Solution: Using `signed=True`

```python
>>> int(-241).to_bytes(2, byteorder='little', signed=True)
b'\x0f\xff'
>>> int(-241).to_bytes(2, byteorder='big', signed=True)
b'\xff\x0f'
>>> int(-1).to_bytes(1, byteorder='big', signed=True)
b'\xff'
>>> int(-128).to_bytes(1, byteorder='big', signed=True)
b'\x80'
```

### Two's Complement Representation

```python
# Positive number
>>> 127.to_bytes(1, 'big', signed=True)
b'\x7f'
>>> bin(127)
'0b1111111'

# Negative number in Two's Complement
>>> (-128).to_bytes(1, 'big', signed=True)
b'\x80'
>>> bin(0x80)
'0b10000000'

# Converting back
>>> int.from_bytes(b'\x80', 'big', signed=True)
-128
>>> int.from_bytes(b'\x80', 'big', signed=False)  # Unsigned interpretation
128
```

## Round-Trip Conversions

Converting integers to bytes and back again:

```python
>>> value = -241
>>> bytes_data = value.to_bytes(2, byteorder='little', signed=True)
>>> bytes_data
b'\x0f\xff'
>>> int.from_bytes(bytes_data, byteorder='little', signed=True)
-241

>>> value = -241
>>> bytes_data = value.to_bytes(2, byteorder='big', signed=True)
>>> bytes_data
b'\xff\x0f'
>>> int.from_bytes(bytes_data, byteorder='big', signed=True)
-241
```

## Practical Examples

### Working with Different Data Sizes

```python
# 8-bit values (1 byte)
>>> 255.to_bytes(1, 'big')
b'\xff'
>>> (-1).to_bytes(1, 'big', signed=True)
b'\xff'

# 16-bit values (2 bytes)
>>> 65535.to_bytes(2, 'big')
b'\xff\xff'
>>> (-1).to_bytes(2, 'big', signed=True)
b'\xff\xff'

# 32-bit values (4 bytes)
>>> (2**31 - 1).to_bytes(4, 'big', signed=True)  # Max 32-bit signed int
b'\x7f\xff\xff\xff'
>>> (-2**31).to_bytes(4, 'big', signed=True)     # Min 32-bit signed int
b'\x80\x00\x00\x00'
```

### Extracting Individual Bytes

```python
>>> value = 0x12345678
>>> bytes_rep = value.to_bytes(4, 'big')
>>> bytes_rep
b'\x124Vx'

# Extract individual bytes by indexing
>>> bytes_rep[0]  # Most significant byte
18
>>> hex(bytes_rep[0])
'0x12'
>>> bytes_rep[3]  # Least significant byte
120
>>> hex(bytes_rep[3])
'0x78'

# Alternative approach for getting least significant byte
>>> value & 0xFF
120
>>> hex(value & 0xFF)
'0x78'
```

### Converting Bytes to Binary Representation

As mentioned in the transcript - getting binary representation of the least significant byte:

```python
>>> value = 240  # 0b11110000
>>> bytes_rep = value.to_bytes(1, 'big')
>>> bytes_rep
b'\xf0'
>>> least_significant_byte = bytes_rep[0]
>>> least_significant_byte
240
>>> bin(least_significant_byte)
'0b11110000'

# More concise but less readable approach
>>> bin(value.to_bytes(1, 'big')[0])
'0b11110000'
```

## Network Protocol Example

```python
# Simulating network packet header
>>> packet_size = 1500
>>> packet_id = 0x1234
>>> flags = 0x80

# Pack into network byte order (big-endian)
>>> header = (
...     packet_size.to_bytes(2, 'big') +
...     packet_id.to_bytes(2, 'big') +
...     flags.to_bytes(1, 'big')
... )
>>> header
b'\x05\xdc\x124\x80'

# Unpack the header
>>> size = int.from_bytes(header[0:2], 'big')
>>> id_val = int.from_bytes(header[2:4], 'big')
>>> flag_val = int.from_bytes(header[4:5], 'big')
>>> print(f"Size: {size}, ID: 0x{id_val:04x}, Flags: 0x{flag_val:02x}")
Size: 1500, ID: 0x1234, Flags: 0x80
```

## Error Handling

### Insufficient Bytes

```python
>>> (256).to_bytes(1, 'big')  # 256 doesn't fit in 1 byte
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
OverflowError: int too big to convert to bytes

# Solution: Use more bytes
>>> (256).to_bytes(2, 'big')
b'\x01\x00'
```

### Signed vs Unsigned Range

```python
# Signed 8-bit range: -128 to 127
>>> 127.to_bytes(1, 'big', signed=True)
b'\x7f'
>>> 128.to_bytes(1, 'big', signed=True)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
OverflowError: int too big to convert to signed bytes

# Unsigned 8-bit range: 0 to 255
>>> 255.to_bytes(1, 'big', signed=False)
b'\xff'
>>> 256.to_bytes(1, 'big', signed=False)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
OverflowError: int too big to convert to bytes
```

## Best Practices

### 1. **Specify Endianness Explicitly**
```python
# Good: Explicit byte order
>>> value.to_bytes(4, 'big')

# Avoid: Relying on system default
>>> value.to_bytes(4, sys.byteorder)  # Less portable
```

### 2. **Use Appropriate Byte Lengths**
```python
# Match the data size to expected range
>>> ip_octet = 192
>>> ip_octet.to_bytes(1, 'big')  # 1 byte for 0-255 range

>>> port_number = 8080
>>> port_number.to_bytes(2, 'big')  # 2 bytes for 0-65535 range
```

### 3. **Handle Signed Data Appropriately**
```python
# For signed data, always specify signed=True
>>> temperature = -10
>>> temperature.to_bytes(2, 'big', signed=True)

# For unsigned data, signed=False is default
>>> count = 100
>>> count.to_bytes(1, 'big')  # signed=False is default
```

## Key Takeaways

- **`to_bytes()`** provides precise control over byte representation of integers
- **Endianness matters** for multi-byte values - always specify explicitly
- **Negative integers** require `signed=True` parameter for Two's Complement representation  
- **`from_bytes()`** performs the reverse conversion from bytes to integers
- **Round-trip conversions** are reliable when using consistent parameters
- **Error handling** is important for values that don't fit in specified byte lengths
