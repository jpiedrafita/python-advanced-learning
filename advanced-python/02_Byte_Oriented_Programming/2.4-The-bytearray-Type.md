# 2.4 The bytearray Type

## Key Ideas

- Mutable complement to the immutable bytes type
- Supports all constructors available for bytes objects
- Implements mutable sequence operations similar to list
- Provides string-like operations for ASCII-compatible content
- Can be modified in-place using assignment, slicing, and sequence methods
- Combines the functionality of mutable sequences with byte-oriented operations

## bytearray Constructors

The bytearray type supports the same constructors as bytes, but creates mutable sequences:

### Empty bytearray

```python
>>> bytearray()
bytearray(b'')
```

### Zero-filled bytearray

```python
>>> bytearray(5)
bytearray(b'\x00\x00\x00\x00\x00')
```

### From bytes sequence

```python
>>> bytearray(b'Construct from a sequence of bytes')
bytearray(b'Construct from a sequence of bytes')
```

### From Unicode string with encoding

```python
>>> bytearray('Norwegian characters Å and Ø', 'utf16')
bytearray(b'\xff\xfeN\x00o\x00r\x00w\x00e\x00g\x00i\x00a\x00n\x00 \x00c\x00h\x00a\x00r\x00a\x00c\x00t\x00e\x00r\x00s\x00 \x00\xc5\x00 \x00a\x00n\x00d\x00 \x00\xd8\x00')
```

### From hexadecimal string

```python
>>> bytearray.fromhex('54686520717569636b2062726f776e20666f78')
bytearray(b'The quick brown fox')
```

## Mutable Sequence Operations

Since bytearray is mutable, it supports all standard mutable sequence operations:

### Extending sequences

```python
>>> pangram = bytearray(b'The quick brown fox')
>>> pangram.extend(b' jumps over the lazy dog')
>>> pangram
bytearray(b'The quick brown fox jumps over the lazy dog')
```

### Slice assignment

```python
>>> pangram[40:43] = b'god'
>>> pangram
bytearray(b'The quick brown fox jumps over the lazy god')
```

### Other mutable operations

```python
>>> data = bytearray(b'Hello')

# Append single byte
>>> data.append(ord(' '))
>>> data.append(ord('!'))
>>> data
bytearray(b'Hello !')

# Insert at position
>>> data.insert(5, ord(','))
>>> data
bytearray(b'Hello, !')

# Remove by value
>>> data.remove(ord('!'))
>>> data
bytearray(b'Hello, ')

# Pop elements
>>> data.pop()
32
>>> data
bytearray(b'Hello,')
```

## String-like Operations

bytearray supports many string-like operations, but only for ASCII-compatible content:

![ASCII Table](../images/ascii.png)
*ASCII operations work reliably only with 7-bit ASCII characters*

### Case operations

```python
>>> pangram.upper()
bytearray(b'THE QUICK BROWN FOX JUMPS OVER THE LAZY GOD')

>>> pangram.lower()
bytearray(b'the quick brown fox jumps over the lazy god')

>>> bytearray(b'hello world').capitalize()
bytearray(b'Hello world')
```

### Splitting and joining

```python
>>> words = pangram.split()
>>> words
[bytearray(b'The'), bytearray(b'quick'), bytearray(b'brown'), bytearray(b'fox'), bytearray(b'jumps'), bytearray(b'over'), bytearray(b'the'), bytearray(b'lazy'), bytearray(b'god')]

>>> bytearray(b' ').join(words)
bytearray(b'The quick brown fox jumps over the lazy god')
```

### Search operations

```python
>>> data = bytearray(b'The quick brown fox')

# Find substring
>>> data.find(b'quick')
4
>>> data.find(b'slow')
-1

# Check membership
>>> b'fox' in data
True

# Count occurrences
>>> data.count(b'o')
1
```

## Indexing and Item Assignment

Unlike bytes, bytearray allows item assignment:

```python
>>> data = bytearray(b'Hello')
>>> data[0]
72
>>> data[0] = ord('h')  # Assign new byte value
>>> data
bytearray(b'hello')

# Multiple assignments
>>> data[1:3] = b'EL'
>>> data
bytearray(b'hELlo')
```

## Conversion Between Types

### bytearray to bytes

```python
>>> mutable_data = bytearray(b'Hello')
>>> immutable_data = bytes(mutable_data)
>>> immutable_data
b'Hello'
```

### bytes to bytearray

```python
>>> immutable_data = b'Hello'
>>> mutable_data = bytearray(immutable_data)
>>> mutable_data
bytearray(b'Hello')
```

## Practical Examples

### Building binary data incrementally

```python
>>> packet = bytearray()
>>> packet.extend(b'\xff\xfe')  # Header
>>> packet.append(0x01)         # Version
>>> packet.extend(b'Hello')     # Payload
>>> packet
bytearray(b'\xff\xfe\x01Hello')
```

### Modifying binary protocols

```python
>>> header = bytearray(b'\x00\x00\x00\x00')  # 4-byte header
>>> header[0] = 0x01  # Set version
>>> header[1] = 0x02  # Set type
>>> header[2:4] = (1234).to_bytes(2, 'big')  # Set length
>>> header
bytearray(b'\x01\x02\x04\xd2')
```

### Text processing with bytes

```python
>>> text = bytearray(b'Hello, World!')

# Replace specific bytes
>>> text.replace(b'World', b'Python')
bytearray(b'Hello, Python!')

# Strip whitespace
>>> text = bytearray(b'  Hello  ')
>>> text.strip()
bytearray(b'Hello')
```

### Buffer operations

```python
>>> buffer = bytearray(1024)  # 1KB buffer
>>> buffer[:5] = b'START'
>>> buffer[-3:] = b'END'
>>> len(buffer)
1024
>>> buffer[:10]
bytearray(b'START\x00\x00\x00\x00\x00')
```

## Performance Considerations

### When to use bytearray vs bytes

```python
# Use bytearray for:
# - Building data incrementally
# - Modifying existing binary data
# - Buffer operations

# Use bytes for:
# - Immutable binary data
# - Hash keys (bytes are hashable)
# - API returns that shouldn't be modified
```

## Best Practices

### ASCII-only string operations

```python
# Safe: ASCII-only content
>>> data = bytearray(b'Hello World')
>>> data.upper()
bytearray(b'HELLO WORLD')

# Dangerous: Non-ASCII content
>>> data = bytearray('Héllo'.encode('utf-8'))
>>> data.upper()  # May not work as expected
bytearray(b'H\xc3\x89LLO')
```

### Efficient building

```python
# Efficient: Build incrementally
>>> result = bytearray()
>>> for i in range(10):
...     result.extend(f'Item {i}\n'.encode('ascii'))

# Less efficient: Multiple concatenations
>>> result = b''
>>> for i in range(10):
...     result += f'Item {i}\n'.encode('ascii')  # Creates new bytes each time
```

### Type conversion clarity

```python
# Explicit conversion
>>> def process_data(data: bytes) -> bytes:
...     mutable_copy = bytearray(data)
...     # Modify mutable_copy
...     return bytes(mutable_copy)
```

## Key Takeaways

- bytearray provides a mutable alternative to immutable bytes
- Supports all bytes constructors plus mutable sequence operations
- String-like operations work reliably only with ASCII content
- Ideal for building or modifying binary data incrementally
- Can be converted to/from bytes when immutability is needed
- Combines the power of mutable sequences with byte-oriented functionality
