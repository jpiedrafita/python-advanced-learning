# 1.5 Try-else Clauses

# 1.5 Try-else Clauses

## Key Idea

- `try-else` allows you to **execute code only when no exception occurs**.
- **Narrows the scope** of exception handling to specific operations.
- **Clarifies intent** by separating exception-prone code from follow-up operations.
- Useful when multiple operations can raise the **same exception type** but you only want to handle exceptions from specific operations.

## Basic Syntax

```python
try:
    # Code that might raise an exception
    risky_operation()
except SomeException:
    # Handle the exception
    handle_exception()
else:
    # Executes only if NO exception was raised
    # We know risky_operation() succeeded
    safe_follow_up_operation()
```

## Why Use Try-else vs. Sequential Code?

### Problem with Sequential Approach
```python
try:
    # This code might raise an exception
    do_something()
    do_something_else()  # This could also raise an exception
except ValueError:
    # ValueError caught and handled
    handle_value_error()  # But which function raised it?
```

**Issues**:
- **Ambiguous exception source**: Can't tell which function raised the exception
- **Enlarged try scope**: Obscures the intent of exception handling
- **Mixed concerns**: Exception-prone and safe operations are mixed

### Solution with Try-else
```python
try:
    # This code might raise an exception
    do_something()
except ValueError:
    # ValueError caught and handled
    handle_value_error()
else:
    # No exception was raised
    # We know that do_something() succeeded, so
    do_something_else()
```

**Benefits**:
- **Clear exception source**: Only `do_something()` can trigger the except block
- **Narrow try scope**: Only the risky operation is in the try block
- **Clear intent**: Follow-up operations are separate and conditional

## Practical Example: File Operations

```python
try:
    f = open(filename, 'r')
except OSError:  # OSError replaces IOError from Python 3.3 onwards
    print("File could not be opened for read")
else:
    # Now we're sure the file is open
    print("Number of lines", sum(1 for line in f))
    f.close()
```

**Why this pattern is useful**:
- **Both operations can raise OSError**: `open()` and iterating over file
- **We only want to handle exceptions from `open()`**: File access errors
- **File iteration errors should propagate**: They indicate different problems

## When Try-else Executes

### Exception Raised
```python
try:
    result = 10 / 0  # ZeroDivisionError
except ZeroDivisionError:
    print("Division by zero!")
else:
    print("Success!")  # This won't execute
```
Output: `"Division by zero!"`

### No Exception Raised  
```python
try:
    result = 10 / 2  # No exception
except ZeroDivisionError:
    print("Division by zero!")
else:
    print("Success!")  # This executes
```
Output: `"Success!"`

## Try-else with Finally

```python
try:
    risky_operation()
except SomeException:
    handle_exception()
else:
    # Executes only if no exception
    success_operation()
finally:
    # Always executes
    cleanup_operation()
```

**Execution order**:
- **No exception**: `try` → `else` → `finally`
- **Exception caught**: `try` → `except` → `finally`
- **Exception not caught**: `try` → `finally` → exception propagates

## Common Use Cases

### 1. **Resource Management**
```python
try:
    resource = acquire_resource()
except ResourceError:
    print("Failed to acquire resource")
else:
    # Resource acquired successfully
    try:
        use_resource(resource)
    finally:
        release_resource(resource)
```

### 2. **Data Validation and Processing**
```python
try:
    data = parse_input(user_input)
except ParseError:
    print("Invalid input format")
else:
    # Input parsed successfully
    process_data(data)
    save_results(data)
```

### 3. **Network Operations**
```python
try:
    connection = establish_connection(server)
except ConnectionError:
    print("Failed to connect to server")
else:
    # Connection established
    send_data(connection, payload)
    response = receive_response(connection)
    connection.close()
```

## Best Practices

### 1. **Keep Try Blocks Minimal**
- Only include the **specific operation** that you want to catch exceptions from
- Move follow-up operations to the `else` block

### 2. **Use for Selective Exception Handling**
- When multiple operations can raise the **same exception type**
- But you only want to handle exceptions from **specific operations**

### 3. **Clarify Intent**
- Use `try-else` to make it **clear which operation** might fail
- **Separate concerns**: risky operations vs. follow-up operations

## Key Takeaway

**Try-else is rarely seen but quite useful** for:
- **Narrowing exception scope** to specific operations
- **Clarifying exception handling intent**
- **Separating exception-prone code** from follow-up operations

Use it when you have **sequential operations** where only the **first operation's exceptions** should be handled, while **later operations' exceptions** should propagate.
