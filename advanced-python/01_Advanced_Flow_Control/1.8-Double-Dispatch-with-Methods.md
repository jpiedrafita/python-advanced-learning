# 1.8 Double Dispatch with Methods

## Overview

Double dispatch is a technique where the function to be called is determined by the types of two arguments. While `singledispatch` works well for functions, using it directly with methods creates several problems that require alternative approaches.

## Problems with `singledispatch` and Methods

### The Naive Approach

Consider this attempt to implement a generic `intersects` method using `singledispatch`:

```python
class Circle(Shape):
    def __init__(self, center, radius, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.center = center
        self.radius = radius

    @singledispatch
    def intersects(self, shape):
        raise TypeError(
            "Don't know how to compute intersection with {!r}".format(shape)
        )

    @intersects.register(Circle)
    def _(self, shape):
        return circle_intersects_circle(self, shape)

    @intersects.register(Parallelogram)
    def _(self, shape):
        return circle_intersects_parallelogram(self, shape)

    @intersects.register(Triangle)
    def _(self, shape):
        return circle_intersects_triangle(self, shape)
```

### Problems with This Approach

#### Problem 1: Class Definition Timing
The first issue is that you cannot register the type of the class currently being defined. In the example above, registering `Circle` fails because the `Circle` class definition is not yet complete when the decorator attempts to register it.

#### Problem 2: Argument Position Confusion
The more fundamental problem relates to how `singledispatch` works. When calling:
```python
my_circle.intersects(my_parallelogram)
```

The actual arguments passed to the method are:
- First argument: `my_circle` (becomes `self`)
- Second argument: `my_parallelogram` (becomes `shape`)

Since `singledispatch` only considers the **first argument** for dispatch, and `self` will always be a `Circle` instance, the dispatch mechanism will always select the same overload regardless of the `shape` parameter type.

## Solution: External Generic Functions

### Moving `singledispatch` Outside the Class

The solution is to move the generic function outside the class and use a regular method to delegate to it:

```python
class Circle(Shape):
    def __init__(self, center, radius, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.center = center
        self.radius = radius

    def intersects(self, shape):
        # Delegate to the generic function, swapping arguments
        return intersects_with_circle(shape, self)

@singledispatch
def intersects_with_circle(shape, circle):
    raise TypeError("Don't know how to compute intersection of {!r} with {!r}"
                   .format(circle, shape))

@intersects_with_circle.register(Circle)
def _(shape, circle):
    return circle_intersects_circle(circle, shape)

@intersects_with_circle.register(Parallelogram)
def _(shape, circle):
    return circle_intersects_parallelogram(circle, shape)

@intersects_with_circle.register(Triangle)
def _(shape, circle):
    return circle_intersects_triangle(circle, shape)
```

### How the Solution Works

1. **External Generic Function**: `intersects_with_circle` is defined at module level, not as a method
2. **Argument Swapping**: The `intersects` method calls `intersects_with_circle(shape, self)`, placing the variable-type argument first
3. **Proper Dispatch**: Now `singledispatch` can properly dispatch based on the `shape` parameter type
4. **Clean Interface**: The method interface remains the same: `circle.intersects(other_shape)`

## Implementing Complete Double Dispatch

### Full Implementation Pattern

To achieve complete double dispatch for all shape combinations, you would need:

```python
# For Circle methods
@singledispatch
def intersects_with_circle(shape, circle):
    raise TypeError("Don't know how to compute intersection of {!r} with {!r}"
                   .format(circle, shape))

# For Parallelogram methods  
@singledispatch
def intersects_with_parallelogram(shape, parallelogram):
    raise TypeError("Don't know how to compute intersection of {!r} with {!r}"
                   .format(parallelogram, shape))

# For Triangle methods
@singledispatch
def intersects_with_triangle(shape, triangle):
    raise TypeError("Don't know how to compute intersection of {!r} with {!r}"
                   .format(triangle, shape))
```

### Benefits of This Approach

1. **True Double Dispatch**: Function selection depends on both object types
2. **Loose Coupling**: Shape classes have no knowledge of each other
3. **Extensibility**: Easy to add new shape types without modifying existing classes
4. **Maintainability**: Intersection logic is separated from shape data

## Key Concepts

### Why `singledispatch` Fails with Methods

- `singledispatch` only considers the first argument for type dispatch
- In method calls, `self` is always the first argument
- The varying parameter (second argument) is ignored for dispatch decisions

### Argument Swapping Strategy

- Move the generic function outside the class
- Create a thin method wrapper that swaps arguments
- Ensure the variable-type argument becomes the first parameter

### Double Dispatch Definition

Double dispatch means the function called depends on the runtime types of **two** arguments, not just one. This pattern is essential for operations that depend on the combination of two different object types.

## Best Practices

1. **Avoid `singledispatch` on methods**: Always use external generic functions
2. **Use descriptive names**: Generic function names should indicate their purpose (e.g., `intersects_with_circle`)
3. **Implement symmetrically**: For true double dispatch, implement generic functions for all participating types
4. **Handle unknown combinations**: Provide meaningful error messages for unsupported type combinations
5. **Keep coupling low**: Avoid direct dependencies between the dispatched classes
