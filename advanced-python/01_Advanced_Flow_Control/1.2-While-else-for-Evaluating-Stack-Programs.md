# 1.2 While-else for Evaluating Stack Programs

## Key Idea

- Practical demonstration of `while-else` for implementing a **stack-based program evaluator**.
- Shows two common use cases: **comment filtering** and **program execution**.
- Uses `while-else` for **search failure handling** - the most common real-world application.
- Authors admit they've never used `while-else` in practice - most cases have better alternatives.
## Stack Program Concept

### How Stack Programs Work
- Programs consist of a stack of items: **operators** (callable functions) and **operands** (arguments).
- Evaluation uses **Reverse Polish Notation (RPN)**: operators come after their operands.
- Example: `5 + 2` becomes `[+, 2, 5]` on the stack.
- Complex example: `(5+2)*3` becomes `[*, 3, +, 2, 5]`.

### Implementation Details
- **Stack representation**: Python list (top of stack = end of list).
- **Operators**: Functions from `operator` module (`operator.add`, `operator.mul`).
- **Comments**: Strings starting with `#`, allowed only at the beginning.
- **Stack reversal**: Use `reversed()` to get correct evaluation order.
- **Implementation**: [evaluator.py](./demo/evaluator.py) 
## Code Structure

### Boolean Short-Circuiting
```python
def is_comment(item):
    return isinstance(item, str) and item.startswith("#")
```
- Uses **short-circuit evaluation**: if `isinstance()` returns `False`, `startswith()` is never called.
- Prevents `AttributeError` when `item` is not a string.

### First While-else: Comment Filtering
```python
while program:
    item = program.pop()
    if not is_comment(item):
        program.append(item)  # Push back non-comment
        break
else:  # nobreak - search failure
    print("Empty program!")
    return
```

**Purpose**: Remove comments from top of stack until first non-comment is found.

**While-else behavior**:
- **Loop condition**: `program` (truthy while stack has items).
- **Break case**: Non-comment found → push back and exit loop.
- **Else case**: Stack becomes empty → no actual program found (**search failure**).

### Second While-else: Program Execution
```python
pending = []
while program:
    item = program.pop()
    if callable(item):
        try:
            result = item(*pending)
            program.append(result)
            pending.clear()
        except Exception as e:
            print(f"Error: {e}")
            break
    else:
        pending.append(item)
else:  # nobreak - successful completion
    print("Program complete.")
```

**Purpose**: Execute the stack program by processing operators and operands.

**Logic**:
- **Non-callable items**: Add to `pending` list (accumulate arguments).
- **Callable items**: Execute with `pending` arguments, push result back.
- **Error handling**: Break on exception (skips `else` clause).

**While-else behavior**:
- **Break case**: Error during execution → incomplete program.
- **Else case**: Stack becomes empty → successful program completion.

## Key Takeaways

### When While-else is Useful
1. **Search failure handling**: When you need to know if a loop ended due to condition becoming false vs. breaking early.
2. **Two-phase processing**: Distinguish between normal completion and early termination.

### Alternative Approaches
- Authors admit they've never used `while-else` in practice.
- Most cases can be implemented more clearly with other constructs.
- Always document with `# nobreak` comment for clarity.

## Example Usage

```python
import operator

program = list(reversed([
    "# A short stack program to add",
    "# and multiply some constants", 
    5, 2, operator.add,  # 5 + 2 = 7
    3, operator.mul      # 7 * 3 = 21
]))

execute(program)  # Output: "Program complete."
```
