# 1.7 Dispatching on Type

## Overview

Dispatching on type refers to the mechanism where the particular implementation of a function depends on the arguments passed to that function. Python naturally dispatches on type when calling methods on objects, but this polymorphism is not available for regular functions without additional techniques.

## Traditional Object-Oriented Approach

### Method Dispatch in Classes

Python automatically dispatches method calls based on the object type. Consider this inheritance hierarchy:

```python
class Shape:
    def __init__(self, solid):
        self.solid = solid
    
    def draw(self):
        raise NotImplementedError

class Circle(Shape):
    def __init__(self, center, radius, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.center = center
        self.radius = radius
    
    def draw(self):
        print("\u25cf" if self.solid else "\u25a1")

class Parallelogram(Shape):
    def __init__(self, pa, pb, pc, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.pa = pa
        self.pb = pb
        self.pc = pc
    
    def draw(self):
        print("\u25b0" if self.solid else "\u25b1")

class Triangle(Shape):
    def __init__(self, pa, pb, pc, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.pa = pa
        self.pb = pb
        self.pc = pc
    
    def draw(self):
        print("\u25b2" if self.solid else "\u25b3")
```

### Problems with This Approach

This approach violates the **Single Responsibility Principle** because:
- Drawing behavior is not inherent to shapes
- Shape classes should focus on "shapeness", not operations like drawing, serializing, or clipping
- It creates tight coupling between shape data and drawing implementation

## Separating Concerns

### Data-Only Classes

A better approach separates data from behavior:

#### Initializators

```python
class Shape:
    def __init__(self, solid):
        self.solid = solid

class Circle(Shape):
    def __init__(self, center, radius, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.center = center
        self.radius = radius

class Parallelogram(Shape):
    def __init__(self, pa, pb, pc, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.pa = pa
        self.pb = pb
        self.pc = pc

class Triangle(Shape):
    def __init__(self, pa, pb, pc, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.pa = pa
        self.pb = pb
        self.pc = pc
```

#### External Drawing Functions

```python
def draw_circle(shape):
    print("\u25cf" if shape.solid else "\u25a1")

def draw_parallelogram(shape):
    print("\u25b0" if shape.solid else "\u25b1")

def draw_triangle(shape):
    print("\u25b2" if shape.solid else "\u25b3")
```

## Traditional Solutions for Function Dispatch

### Using `isinstance` Checks

```python
def draw(shape):
    if isinstance(shape, Circle):
        draw_circle(shape)
    elif isinstance(shape, Parallelogram):
        draw_parallelogram(shape)
    elif isinstance(shape, Triangle):
        draw_triangle(shape)
    else:
        raise TypeError("Can't draw shape {!r}".format(shape))
```

**Problems**: Difficult to maintain and considered poor programming style.

### Dictionary-Based Dispatch

```python
def draw(shape):
    drawers = {
        Circle: draw_circle,
        Parallelogram: draw_parallelogram,
        Triangle: draw_triangle,
    }
    try:
        drawer = drawers[type(shape)]
    except KeyError as e:
        raise TypeError("Can't draw shape") from e
    else:
        drawer(shape)
```

**Problems**: More fragile due to exact type comparisons; subclasses won't work correctly.

## Single Dispatch Solution

### Introduction to Generic Functions

Python 3.4 introduced the `singledispatch` decorator from the `functools` module. This enables:
- **Generic functions**: Functions with multiple implementations based on argument types
- **Function overloading**: Providing different versions for different argument types
- **Overloads**: Each type-specific version of a generic function

### Implementation

```python
from functools import singledispatch

@singledispatch
def draw(shape):
    raise TypeError("Don't know how to draw {!r}".format(shape))

@draw.register(Circle)
def _(shape):
    print("\u25cf" if shape.solid else "\u25a1")

@draw.register(Parallelogram)
def _(shape):
    print("\u25b0" if shape.solid else "\u25b1")

@draw.register(Triangle)
def _(shape):
    print("\u25b2" if shape.solid else "\u25b3")
```

### Usage

```python
def main():
    shapes = [
        Circle(center=(0, 0), radius=5, solid=False),
        Parallelogram(pa=(0, 0), pb=(2, 0), pc=(1, 1), solid=False),
        Triangle(pa=(0, 0), pb=(1, 2), pc=(2, 0), solid=True),
    ]

    for shape in shapes:
        draw(shape)

if __name__ == "__main__":
    main()
```

## Key Concepts

### How singledispatch Works

1. The `@singledispatch` decorator wraps the function and binds the wrapper to the original function name
2. The wrapper has a `register` attribute (also a decorator) for adding type-specific overloads
3. The dispatch mechanism selects the most specific overload or falls back to the default implementation
4. Overload function names are conventionally `_` since they're ignored

### Benefits

- **Clean separation of concerns**: Drawing depends on shapes, but shapes don't depend on drawing
- **Extensible**: Easy to add new shape types or new operations
- **Polymorphic**: Works similarly to method dispatch but for functions
- **Type-aware**: Properly handles inheritance relationships

### Backward Compatibility

For Python versions before 3.4, install the `singledispatch` package from PyPI:

```bash
pip install singledispatch
```

## Best Practices

1. Use the default implementation to handle unknown types with meaningful error messages
2. Keep overload functions focused on a single responsibility
3. Consider using `_` as the conventional name for overload functions
4. Design generic functions to be extensible for new types
5. Prefer `singledispatch` over `isinstance` chains or dictionary lookups for type-based dispatch
