# 1.6 Emulating Switch Statements

## Key Idea

- **Python lacks a switch/case statement** but can emulate it using **dictionaries of callables**.
- **Dictionary lookups** are cleaner than long `if-elif-else` chains.
- **Functional approach** with callables promotes better code organization and maintainability.
- **Try-else** helps narrow the scope of exception handling in dictionary lookups.

## The Problem: Long If-Elif-Else Chains

### Traditional Switch Statement (C)
```c
switch (menu_option) {
    case 1: single_player();   break;
    case 2: multi_player();    break;
    case 3: load_game();       break;
    case 4: save_game();       break;
    case 5: reset_high_score(); break;
    default:
        printf("No such option!");
        break;
}
```

### Python If-Elif-Else Equivalent (Problematic)
```python
if menu_option == 1:
    single_player()
elif menu_option == 2:
    multi_player()
elif menu_option == 3:
    load_game()
elif menu_option == 4:
    save_game()
elif menu_option == 5:
    reset_high_score()
else:
    print("No such option!")
```

**Problems**:
- **Tedious to write** and error-prone
- **Repeated comparisons** of the same variable
- **Hard to maintain** as options grow

## Solution: Dictionary of Callables

## Practical Example: Adventure Game Refactoring

### Step 1: Initial Code (kafka_old.py)

**Starting point**: Simple adventure game with long if-elif-else chains.

```python
def play():
    position = (0, 0)
    alive = True

    while position:
        # Long if-elif chain for locations
        if position == (0, 0):
            print("You are in a maze of twisty passages, all alike.")
        elif position == (1, 0):
            print("You on a road in a dark forest. To the north you can see a tower.")
        elif position == (1, 1):
            print("There is a tall tower here, with no obvious door. A path leads east.")
        else:
            print("There is nothing here.")

        command = input()

        # Long if-elif chain for commands
        i, j = position
        if command == "N":
            position = (i, j + 1)
        elif command == "E":
            position = (i + 1, j)
        elif command == "S":
            position = (i, j - 1)
        elif command == "W":
            position = (i - 1, j)
        elif command == "L":
            pass
        elif command == "Q":
            position = None
        else:
            print("I don't understand")

    print("Game over")
```

### Step 2: Extract Location Functions

**Problem**: The first if-elif chain repeatedly compares `position` against different values.

**Solution**: Create a dictionary mapping positions to callable functions.

```python
def labyrinth(position, alive):
    print("You are in a maze of twisty passages, all alike.")
    return position, alive

def dark_forest_road(position, alive):
    print("You on a road in a dark forest. To the north you can see a tower.")
    return position, alive

def tall_tower(position, alive):
    print("There is a tall tower here, with no obvious door. A path leads east.")
    return position, alive

# Location mapping
locations = {
    (0, 0): labyrinth,
    (1, 0): dark_forest_road,
    (1, 1): tall_tower,
}
```

### Step 3: Use Try-Else for Location Lookup

**Goal**: Narrow the scope of exception handling to only the dictionary lookup.

```python
# Replace the if-elif chain with dictionary lookup
try:
    location_action = locations[position]
except KeyError:
    print("There is nothing here.")
else:
    # Only execute if lookup succeeded
    position, alive = location_action(position, alive)
```

**Key insight**: We separate the **lookup** from the **call** using try-else. This ensures we only catch `KeyError` from the dictionary lookup, not from the function execution.

### Step 4: Extract Command Functions

**Problem**: The second if-elif chain repeatedly compares `command` against different values.

**Solution**: Create named functions for each command action.

```python
def go_north(position):
    i, j = position
    new_position = (i, j + 1)
    return new_position

def go_east(position):
    i, j = position
    new_position = (i + 1, j)
    return new_position

def go_south(position):
    i, j = position
    new_position = (i, j - 1)
    return new_position

def go_west(position):
    i, j = position
    new_position = (i - 1, j)
    return new_position

def look(position):
    return position

def quit(position):
    return None
```

**Design choice**: Use named functions instead of lambdas because command actions involve statements, not just expressions.

### Step 5: Create Command Dictionary and Try-Else

```python
# Command mapping
actions = {
    "N": go_north,
    "E": go_east,
    "S": go_south,
    "W": go_west,
    "L": look,
    "Q": quit,
}

# Replace if-elif chain with dictionary lookup
try:
    command_action = actions[command]
except KeyError:
    print("I don't understand")
else:
    position = command_action(position)
```

### Step 6: Add Game State Management

**Enhancement**: Add more locations and deadly scenarios.

**New locations**:
```python
def rabbit_hole(position, alive):
    print("You fall down a rabbit hole into a labyrinth.")
    return (0, 0), alive  # Teleport back to start

def lava_pit(position, alive):
    print("You fall into a lava pit.")
    return position, False  # Player dies
```

**Updated location mapping**:
```python
locations = {
    (0, 0): labyrinth,
    (1, 0): dark_forest_road,
    (1, 1): tall_tower,
    (2, 1): rabbit_hole,    # New location
    (1, 2): lava_pit,       # Deadly location
}
```

### Step 7: Add Death Handling and While-Else

**Death detection**:
```python
if not alive:
    print("You're dead!")
    break  # Exit game loop
```

**While-else for game exit differentiation**:
```python
while position:
    # Game loop...
    
    if not alive:
        print("You're dead!")
        break  # Skips else block
        
else:  # nobreak
    print("You have chosen to leave the game.")
```

### Step 8: Final Refactored Code (kafka.py)

```python
def play():
    position = (0, 0)
    alive = True

    while position:
        locations = {
            (0, 0): labyrinth,
            (1, 0): dark_forest_road,
            (1, 1): tall_tower,
            (2, 1): rabbit_hole,
            (1, 2): lava_pit,
        }

        try:
            location_action = locations[position]
        except KeyError:
            print("There is nothing here.")
        else:
            position, alive = location_action(position, alive)

        if not alive:
            print("You're dead!")
            break

        command = input()

        actions = {
            "N": go_north,
            "E": go_east,
            "S": go_south,
            "W": go_west,
            "L": look,
            "Q": quit,
        }

        try:
            command_action = actions[command]
        except KeyError:
            print("I don't understand")
        else:
            position = command_action(position)
    else:  # nobreak
        print("You have chosen to leave the game.")
```

### Transformation Benefits

1. **Functional Style**: 
   - State passed explicitly, not modified globally
   - Position mutation happens in only one place instead of five
   - Pure functions are easier to test and reason about

2. **Maintainability**: 
   - Adding new game state (like inventory) requires updating all functions
   - Compile-time safety through consistent function signatures
   - Anyone maintaining location code can see what state needs to be maintained

3. **Extensibility**:
   - Easy to add new locations: just add to dictionary
   - Easy to add new commands: just add to dictionary and implement function
   - Runtime modification possible

4. **Error Handling**:
   - Try-else narrows exception scope
   - Clear separation between lookup errors and execution errors
   - Consistent error messages for unknown commands/locations

### Game Flow Examples

**Normal quit** (position becomes None):
```
You are in a maze of twisty passages, all alike.
Q
You have chosen to leave the game.
```

**Death scenario** (break from loop):
```
You are in a maze of twisty passages, all alike.
E
You on a road in a dark forest. To the north you can see a tower.
N
There is a tall tower here, with no obvious door. A path leads east.
N
You fall into a lava pit.
You're dead!
```

The while-else clause distinguishes between these two exit scenarios.

## Refactoring Techniques

### 1. Using Try-Else for Dictionary Lookups

**Purpose**: Narrow the scope of exception handling to only the dictionary lookup.

```python
try:
    location_action = locations[position]
except KeyError:
    print("There is nothing here.")
else:
    # Only execute if lookup succeeded
    position, alive = location_action(position, alive)
```

**Benefits**:
- **Separates lookup from execution**: Clear which operation might fail
- **Prevents masking other exceptions**: Function call exceptions propagate normally
- **Clarifies intent**: We're only handling missing keys, not function errors

### 2. Functional Command Handlers

```python
def go_north(position):
    i, j = position
    new_position = (i, j + 1)
    return new_position

def go_east(position):
    i, j = position
    new_position = (i + 1, j)
    return new_position

def quit(position):
    return None
```

**Key characteristics**:
- **Pure functions**: Don't modify global state
- **Explicit parameters**: State passed in explicitly
- **Return new state**: Immutable approach to state changes
- **Single responsibility**: Each function has one clear purpose

### 3. Location Functions with State Management

```python
def lava_pit(position, alive):
    print("You fall into a lava pit.")
    return position, False

def labyrinth(position, alive):
    print("You are in a maze of twisty passages, all alike.")
    return position, alive

def rabbit_hole(position, alive):
    print("You fall down a rabbit hole into a labyrinth.")
    return (0, 0), alive  # Teleport to start
```

**Design benefits**:
- **Consistent interface**: All location functions accept and return the same parameters
- **Explicit state management**: Easy to see what state each function can modify
- **Maintainable**: Adding new state requires updating all functions (compile-time safety)

## Advanced Patterns

### Using While-Else for Game Exit Handling

```python
while position:
    # Game loop logic...
    
    if not alive:
        print("You're dead!")
        break  # This skips the else block
        
else:  # nobreak
    print("You have chosen to leave the game.")
```

**Behavior**:
- **Normal exit** (quit command sets `position = None`): Executes else block
- **Death exit** (break due to `not alive`): Skips else block

### Lambda vs Named Functions

**For simple expressions** (like print statements):
```python
locations = {
    (0, 0): lambda pos, alive: (print("In maze"), pos, alive)[1:],
    (1, 0): lambda pos, alive: (print("Dark forest"), pos, alive)[1:],
}
```

**For complex logic** (recommended):
```python
locations = {
    (0, 0): labyrinth,
    (1, 0): dark_forest_road,
}
```

## Benefits of Dictionary Approach

### 1. **Maintainability**
- **Easy to add new cases**: Just add new dictionary entries
- **No repeated conditions**: Single point of definition
- **Forced consistency**: All handlers must follow same interface

### 2. **Readability**
- **Clear mapping**: Direct relationship between keys and actions
- **Separation of concerns**: Logic separated from dispatch
- **Self-documenting**: Dictionary structure shows available options

### 3. **Extensibility**
- **Runtime modification**: Dictionaries can be modified at runtime
- **Dynamic behavior**: Can be built programmatically
- **Pluggable architecture**: Easy to swap implementations

### 4. **Functional Style**
- **Immutable approach**: State passed explicitly rather than modified globally
- **Pure functions**: Easier to test and reason about
- **Composable**: Functions can be reused and combined

## Best Practices

### 1. **Use Try-Else for Lookups**
```python
try:
    handler = dispatch_table[key]
except KeyError:
    # Handle unknown key
    default_handler()
else:
    # Execute handler
    result = handler(args)
```

### 2. **Consistent Function Signatures**
- All callables in the dictionary should have **compatible signatures**
- Use **explicit parameters** rather than global state
- **Return values** rather than modifying state in place

### 3. **Meaningful Default Handling**
- Always handle the case where the key is not found
- Provide helpful error messages
- Consider whether defaults should be silent or explicit

## Key Takeaway

**Dictionary of callables** is Python's idiomatic way to emulate switch statements, providing:
- **Cleaner syntax** than if-elif-else chains
- **Better maintainability** and extensibility
- **Functional programming benefits**
- **Natural integration with try-else** for robust error handling
