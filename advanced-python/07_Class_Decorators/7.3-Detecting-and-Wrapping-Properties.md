# 7.3 Detecting and Wrapping Properties

## Key Ideas

- **Property Descriptor Problem**: Properties are descriptors, not callable functions, so they bypass simple callable detection
- **Enhanced Detection**: Need specialized logic to identify and wrap property objects
- **Descriptor Proxy Pattern**: Create proxy descriptors that wrap original properties with invariant checking
- **Complete Coverage**: Handle all descriptor methods (`__get__`, `__set__`, `__delete__`) for comprehensive protection
- **Practical Limitation**: Focus on `property` instances rather than all descriptors due to implementation complexity

## Understanding the Property Detection Problem

### Inspecting Class Attributes

```python
>>> from class_decorators import *
>>> from pprint import pprint as pp
>>> pp(vars(Temperature))
mappingproxy({'__dict__': <attribute '__dict__' of 'Temperature' objects>,
              '__doc__': None,
              '__init__': <function Temperature.__init__ at 0x1031bf158>,
              '__module__': 'class_decorators',
              '__weakref__': <attribute '__weakref__' of 'Temperature' objects>,
              'celsius': <property object at 0x1031bb138>,
              'fahrenheit': <property object at 0x1031bb188>,
              'get_kelvin': <function Temperature.get_kelvin at 0x1031bf620>,
              'set_kelvin': <function Temperature.set_kelvin at 0x1031bf598>})
```

**Key Observations**:
- **Property Objects**: `celsius` and `fahrenheit` are `<property object>` instances
- **Function Objects**: Methods like `get_kelvin` are `<function>` objects
- **Detection Challenge**: Properties are descriptors but not callable functions

### Detection Strategy Decision

**Ideal Approach**: Detect all descriptors (objects with `__get__`, `__set__`, or `__delete__`)
**Problem**: Functions and methods are also descriptors, creating excessive complexity
**Chosen Approach**: Specifically target `property` instances for simplicity and practicality

## Enhanced Class Decorator Implementation

```python
def invariant(predicate):
    """Create a class decorator which checks a class invariant.

    Args:
        predicate: A callable to which, after every method invocation,
                   the object on which the method was called will be passed.
                   The predicate should evaluate to True if the class invariant
                   has been maintained, or False if it has been violated.

    Returns:
        A class decorator for checking the class invariant tested by
        the supplied predicate function.
    """
    def invariant_checking_class_decorator(cls):
        """A class decorator for checking invariants."""

        method_names = [name for name, attr in vars(cls).items() if callable(attr)]
        for name in method_names:
            _wrap_method_with_invariant_checking_proxy(cls, name, predicate)

        property_names = [name for name, attr in vars(cls).items() if isinstance(attr, property)]
        for name in property_names:
            _wrap_property_with_invariant_checking_proxy(cls, name, predicate)

        return cls

    return invariant_checking_class_decorator
```

**Enhanced Detection Logic**:
- **Method Detection**: `callable(attr)` identifies functions and methods
- **Property Detection**: `isinstance(attr, property)` identifies property objects
- **Dual Processing**: Both methods and properties are wrapped with appropriate proxies
- **Delegation**: Property wrapping delegates to specialized function

### Property Wrapping Function

```python
def _wrap_property_with_invariant_checking_proxy(cls, name, predicate):
    prop = getattr(cls, name)
    assert isinstance(prop, property)

    invariant_checking_proxy = InvariantCheckingPropertyProxy(prop, predicate)

    setattr(cls, name, invariant_checking_proxy)
```

**Wrapping Process**:
1. **Retrieve Property**: Get the original property object from the class
2. **Validation**: Assert that the attribute is indeed a property instance
3. **Create Proxy**: Instantiate `InvariantCheckingPropertyProxy` with original property and predicate
4. **Replace Property**: Use `setattr()` to replace the original property with the proxy

## Property Proxy Implementation

```python
class InvariantCheckingPropertyProxy:
    def __init__(self, referent, predicate):
        self._referent = referent
        self._predicate = predicate

    def __get__(self, instance, owner):
        if instance is None:
            return self._referent
        result = self._referent.__get__(instance, owner)
        if not self._predicate(instance):
            raise RuntimeError("Class invariant {!r} violated for {!r}".format(
                self._predicate.__doc__, instance))
        return result

    def __set__(self, instance, value):
        result = self._referent.__set__(instance, value)
        if not self._predicate(instance):
            raise RuntimeError("Class invariant {!r} violated for {!r}".format(
                self._predicate.__doc__, instance))
        return result

    def __delete__(self, instance):
        result = self._referent.__delete__(instance)
        if not self._predicate(instance):
            raise RuntimeError("Class invariant {!r} violated for {!r}".format(
                self._predicate.__doc__, instance))
        return result
```

### Proxy Descriptor Design

**Class Structure**:
- **Descriptor Implementation**: Implements all three descriptor methods (`__get__`, `__set__`, `__delete__`)
- **Composition Pattern**: Stores reference to original property (`_referent`) and predicate function
- **Transparent Proxy**: Forwards all operations to the original property before checking invariants

**Method Implementations**:

**`__get__` (Property Getter)**:
- **Class Access**: Returns referent when `instance is None` (class-level access)
- **Instance Access**: Calls original getter, then validates invariant
- **Post-Access Check**: Ensures invariant holds after getter execution

**`__set__` (Property Setter)**:
- **Delegation**: Forwards to original property's setter
- **Post-Mutation Check**: Validates invariant after value assignment
- **Critical Point**: This is where invalid mutations are caught

**`__delete__` (Property Deleter)**:
- **Delegation**: Forwards to original property's deleter
- **Post-Deletion Check**: Validates invariant after property deletion
- **Complete Coverage**: Handles all possible property operations

## Testing the Enhanced Implementation

```python
>>> from class_decorators import *
>>> t = Temperature(42.0)
>>> t.celsius = -300
Traceback (most recent call last):
  File "<input>", line 1, in <module>
  File "/Users/rjs/training/tmp/class_decorators/class_decorators.py", line 76, in __set__
    if not self._predicate(instance):
RuntimeError: Class invariant 'Temperature not below absolute zero' violated for <class_decorators.Temperature object at ...
```

### Successful Invariant Protection

**Test Results**:
- **Property Creation**: `Temperature(42.0)` creates valid instance successfully
- **Invalid Assignment**: `t.celsius = -300` properly triggers `RuntimeError`
- **Immediate Detection**: Violation caught at the point of assignment, not during subsequent access
- **Proper Error Reporting**: Error includes predicate docstring for clear violation context

## Summary

The enhanced property detection and wrapping solution provides:

**Complete Coverage**:
- **Methods**: Wrapped via callable detection and function decorators
- **Properties**: Wrapped via property detection and descriptor proxies
- **All Operations**: Handles getting, setting, and deleting for properties

**Technical Achievements**:
- **Immediate Validation**: Invariants checked at mutation points, not query points
- **Transparent Proxying**: Original functionality preserved while adding protection
- **Error Clarity**: Meaningful error messages with predicate documentation
- **Practical Implementation**: Focuses on `property` objects rather than all descriptors for maintainability

**Key Design Patterns**:
- **Proxy Pattern**: Wrapping original objects with validation-enhanced versions
- **Decorator Factory**: Configurable decorators through higher-order functions
- **Composition**: Storing references to original objects rather than inheritance
- **Descriptor Protocol**: Implementing complete descriptor interface for full compatibility
