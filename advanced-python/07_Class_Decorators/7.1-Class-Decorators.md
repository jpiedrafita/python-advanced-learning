# 7.1 Class Decorators

## Key Ideas

- **Alternative to Metaclasses**: Class decorators provide a simpler alternative to metaclasses for class customization
- **Power Trade-off**: Less powerful than metaclasses but significantly easier to understand and implement
- **Preference Rule**: Use class decorators when the desired effect can be achieved with either approach
- **Execution Timing**: Applied after class body processing but before name binding
- **Function-like Behavior**: Work similarly to function decorators but operate on classes

## Class Decorators vs Metaclasses

### Capability Comparison

**Class Decorators**: 
- Subset of metaclass functionality
- Sufficient for many common class customization needs
- Easier to understand and debug

**Metaclasses**:
- Complete control over class creation process
- Can achieve everything class decorators can do
- More complex and harder to reason about

### When to Use Class Decorators

**Preferred Choice**: When the desired transformation can be achieved with either approach, choose class decorators for simplicity.

## Basic Class Decorator Mechanics

Class decorators function similarly to function decorators, applying transformations to classes at definition time:

### Simple Class Decorator Example

```python
def my_class_decorator(cls):
    for name, attr in vars(cls).items():
        print(name)
    return cls

@my_class_decorator
class Temperature:

    def __init__(self, kelvin):
        self._kelvin = kelvin

    def get_kelvin(self):
        return self._kelvin

    def set_kelvin(self, value):
        self._kelvin = value
```

**Class Decorator Requirements**:
- **Single Parameter**: Must accept the class object as its only argument (conventionally named `cls`)
- **Return Value**: Must return the modified class object or an alternative class object
- **Name Binding**: The returned class is bound to the name given in the class definition (`Temperature`)

**Functionality**: This simple decorator iterates through and prints all class attributes using `vars(cls).items()`.

### Execution Timing and Output

```python
>>> from class_decorators import *
__module__
get_kelvin
set_kelvin
__init__
__weakref__
__dict__
>>> 
```

**Execution Context**: The decorator executes during module import when the `Temperature` class is first defined.

**Discovered Attributes**:
- `__module__`: Module reference
- `get_kelvin`, `set_kelvin`: Custom methods
- `__init__`: Constructor
- `__weakref__`, `__dict__`: Standard Python class attributes

## Practical Application: Invariant Enforcement

### Problem Statement

The `Temperature` class must maintain a critical invariant: temperatures cannot be lower than absolute zero (0 Kelvin).

### Solution Approach

Instead of requiring each method to individually check this invariant, use a class decorator to wrap all methods with invariant-checking proxies automatically.
