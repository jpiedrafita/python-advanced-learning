# 7.4 Chaining Class Decorators

## Key Ideas

- **Decorator Chaining**: Class decorators can be chained like function decorators for multiple transformations
- **Multiple Invariants**: Apply different invariant checks using stacked decorators
- **Method Compatibility**: Chained decorators work well with methods and already-decorated methods
- **Property Limitation**: Chaining fails with properties due to type-specific detection (`isinstance(attr, property)`)
- **Proxy Recognition Problem**: Property proxies are not recognized as properties by subsequent decorators

## Implementing Multiple Invariants

### Dual Invariant Implementation

```python
def not_below_absolute_zero(temperature):
    """Temperature not below absolute zero"""
    return temperature._kelvin >= 0

def below_absolute_hot(temperature):
    """Temperature below absolute hot"""
    # See http://en.wikipedia.org/wiki/Absolute_hot
    return temperature._kelvin <= 1.416785e32

@invariant(below_absolute_hot)
@invariant(not_below_absolute_zero)
class Temperature:

    def __init__(self, kelvin):
        self._kelvin = kelvin

    def get_kelvin(self):
        return self._kelvin

    def set_kelvin(self, value):
        self._kelvin = value

    @property
    def celsius(self):
        return self._kelvin - 273.15

    @celsius.setter
    def celsius(self, value):
        self._kelvin = value + 273.15

    @property
    def fahrenheit(self):
        return self._kelvin * 9 / 5 - 459.67

    @fahrenheit.setter
    def fahrenheit(self, value):
        self._kelvin = (value + 459.67) * 5 / 9
```

**Dual Constraint System**:
- **Lower Bound**: `not_below_absolute_zero` prevents temperatures below 0 Kelvin
- **Upper Bound**: `below_absolute_hot` prevents temperatures above 1.416785e32 Kelvin (theoretical maximum temperature)
- **Decorator Stacking**: Applied in bottom-to-top order (closest to class applied first)

## Testing Method-Level Chaining

```python
from class_decoratoros import *
>>> t = Temperature(37.5)
>>> t.set_kelvin(-300)
Traceback (most recent call last):
  File "<input>", line 1, in <module>
  File "/Users/rjs/training/tmp/class_decorators/class_decorators.py", line 40, in invariant_checking_method_decorator
    result = method(self, *args, **kwargs)
  File "/Users/rjs/training/tmp/class_decorators/class_decorators.py", line 42, in invariant_checking_method_decorator
    raise RuntimeError("Class invariant {!r} violated for {!r}".format(predicate.__doc__, self))
RuntimeError: Class invariant 'Temperature not below absolute zero' violated for <class_decorators.Temperature object at ...

>>> t.set_kelvin(1e33)
Traceback (most recent call last):
  File "<input>", line 1, in <module>
  File "/Users/rjs/training/tmp/class_decorators/class_decorators.py", line 42, in invariant_checking_method_decorator
    raise RuntimeError("Class invariant {!r} violated for {!r}".format(predicate.__doc__, self))
RuntimeError: Class invariant 'Temperature below absolute hot' violated for <class_decorators.Temperature object at 0x103...>
```

### Successful Method Chaining

**Test Results**:
- **Lower Bound Enforcement**: `t.set_kelvin(-300)` correctly triggers "not below absolute zero" violation
- **Upper Bound Enforcement**: `t.set_kelvin(1e33)` correctly triggers "below absolute hot" violation  
- **Decorator Cooperation**: Both decorators successfully wrap the same method without conflicts
- **Already-Decorated Methods**: Second decorator has no problem decorating methods already wrapped by the first decorator

## Property Chaining Limitations


### Property Chaining Failure

```python
>>> t.celsius = -300
Traceback (most recent call last):
  File "<input>", line 1, in <module>
  File "/Users/rjs/training/tmp/class_decorators/class_decorators.py", line 76, in __set__
    self._predicate.__doc__, instance))
RuntimeError: Class invariant 'Temperature not below absolute zero' violated for <class_decorators.Temperature object at ...

>>> t.celsius = 1e34
```

**Asymmetric Behavior**:
- **Lower Bound Works**: `t.celsius = -300` correctly triggers violation (first decorator applied)
- **Upper Bound Fails**: `t.celsius = 1e34` silently succeeds (second decorator not applied)

## Root Cause Analysis

### The Property Recognition Problem

**Decorator Application Sequence**:
1. **First Decorator** (`@invariant(not_below_absolute_zero)`):
   - Detects `celsius` as `isinstance(attr, property)` → **True**
   - Replaces `celsius` with `InvariantCheckingPropertyProxy`
   
2. **Second Decorator** (`@invariant(below_absolute_hot)`):
   - Detects `celsius` as `isinstance(attr, property)` → **False** (it's now a proxy)
   - Skips wrapping the property entirely

**Core Issue**: The `isinstance(attr, property)` check is too restrictive for chained decorators because:
- **Type Change**: First decorator changes property to proxy object
- **Proxy Invisibility**: `InvariantCheckingPropertyProxy` is not a `property` instance
- **Detection Failure**: Second decorator cannot recognize the proxy as a property-like object

### Implications

**Partial Protection**: Only the first decorator in the chain provides property protection
**Inconsistent Behavior**: Methods get full protection, properties get partial protection
**Design Limitation**: Current approach cannot handle multiple property decorators

## Solution Preview

**Abstract Base Classes**: The next module will explore using Python's ABC mechanism to solve this recognition problem by:
- **Interface-Based Detection**: Checking for descriptor protocol rather than specific types
- **Proxy Registration**: Allowing proxies to identify as property-like objects
- **Complete Chaining**: Enabling full decorator chaining for all attribute types

## Summary

Class decorator chaining demonstrates both strengths and limitations:

**Successful Chaining**:
- **Methods**: Multiple decorators can wrap the same method successfully
- **Error Propagation**: All invariants are checked and violations properly reported
- **Decorator Cooperation**: No conflicts between multiple method decorators

**Chaining Limitations**:
- **Property Type Detection**: `isinstance(attr, property)` fails after first proxy replacement
- **Incomplete Protection**: Later decorators in chain don't apply to properties
- **Asymmetric Behavior**: Different behavior for methods vs properties in chained scenarios

**Key Insight**: Simple type checking (`isinstance`) is insufficient for complex decorator chaining scenarios requiring more sophisticated object recognition mechanisms.
