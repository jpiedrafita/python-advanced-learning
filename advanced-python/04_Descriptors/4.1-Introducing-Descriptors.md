# 4.1 Introducing Descriptors

## Key Ideas

- Descriptors are the mechanism that implements properties in Python
- They solve code duplication problems in validation scenarios
- Properties are entry points into the descriptor system
- Descriptors implement a protocol with `__get__`, `__set__`, and `__delete__` methods
- Two categories exist: data descriptors and non-data descriptors
- Descriptors interact with Python's attribute lookup rules

## The Problem: Validation Code Duplication

We'll explore descriptors using a `Planet` class that models celestial bodies with physical attributes.

### Basic Planet Class

```python
class Planet:
    def __init__(self,
                 name,
                 radius_metres,
                 mass_kilograms,
                 orbital_period_seconds,
                 surface_temperature_kelvin):
        self.name = name
        self.radius_metres = radius_metres
        self.mass_kilograms = mass_kilograms
        self.orbital_period_seconds = orbital_period_seconds
        self.surface_temperature_kelvin = surface_temperature_kelvin
```

### Using the Basic Class

```python
>>> from planet import Planet
>>> pluto = Planet(name='Pluto', radius_metres=1184e3, mass_kilograms=1.305e22, orbital_period_seconds=7816012992, surface_temperature_kelvin=55)
>>> pluto.radius_metres
1184000.0
```

### The Problem: Invalid Data

The basic class allows nonsensical situations:

```python
>>> pluto.radius_metres = -10000

>>> planet_x = Planet(name='X', radius_metres=10e3, mass_kilograms=0, orbital_period_seconds=-7293234, surface_temperature_kelvin=-5)
```

## Solution Attempt: Properties with Validation

We can wrap attributes in properties with validation:

```python
class Planet:
    def __init__(self,
                 name,
                 radius_metres,
                 mass_kilograms,
                 orbital_period_seconds,
                 surface_temperature_kelvin):
        self.name = name
        self.radius_metres = radius_metres
        self.mass_kilograms = mass_kilograms
        self.orbital_period_seconds = orbital_period_seconds
        self.surface_temperature_kelvin = surface_temperature_kelvin

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if not value:
            raise ValueError("Cannot set empty Planet.name")
        self._name = value

    @property
    def radius_metres(self):
        return self._radius_metres

    @radius_metres.setter
    def radius_metres(self, value):
        if value <= 0:
            raise ValueError("radius metres value {} is not positive.".format(value))
        self._radius_metres = value

    @property
    def mass_kilograms(self):
        return self._mass_kilograms

    @mass_kilograms.setter
    def mass_kilograms(self, value):
        if value <= 0:
            raise ValueError("mass_kilograms value {} is not positive.".format(value))
        self._mass_kilograms = value

    @property
    def orbital_period_seconds(self):
        return self._orbital_period_seconds

    @orbital_period_seconds.setter
    def orbital_period_seconds(self, value):
        if value <= 0:
            raise ValueError("orbital_period_seconds value {} is not positive.".format(value))
        self._orbital_period_seconds = value

    @property
    def surface_temperature_kelvin(self):
        return self._surface_temperature_kelvin

    @surface_temperature_kelvin.setter
    def surface_temperature_kelvin(self, value):
        if value <= 0:
            raise ValueError("surface_temperature_kelvin value {} is not positive.".format(value))
        self._surface_temperature_kelvin = value
```

### Improved Robustness

```python
>>> try:
...     invalid_planet = Planet(name='', radius_metres=-1000, mass_kilograms=0, orbital_period_seconds=-7293234, surface_temperature_kelvin=-5)
... except ValueError as e:
...     print(e)
Cannot set empty Planet.name
```

## The Code Explosion Problem

**Benefits:**
- Robust validation prevents invalid data
- Construction-time validation through property setters

**Problems:**
- **Code explosion**: Simple class becomes verbose and complex  
- **Duplication**: Each property repeats the same positive-value validation pattern
- **Maintenance burden**: Changes to validation logic require multiple updates

## What's Next: Descriptors to the Rescue

Descriptors provide a way to:
- Eliminate validation code duplication
- Create reusable validation components
- Maintain clean, readable class definitions
- Implement the underlying mechanism that powers properties

**The descriptor protocol** enables us to create custom attribute access behavior that can be shared across multiple attributes and classes, solving the duplication problem elegantly.

## Key Takeaways

- **Properties solve validation** but create code duplication when multiple attributes need similar validation
- **Descriptors are the foundation** that properties are built upon
- **Code duplication signals** the need for a more sophisticated solution
- **Physical validation example** demonstrates real-world scenarios where descriptors shine
- **Descriptors provide reusability** for common attribute patterns like positive number validation
