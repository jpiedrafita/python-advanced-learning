# 4.5 Data vs. Non-data Descriptors

## Key Ideas

- **Data descriptors** implement both `__get__` and `__set__` methods (writable)
- **Non-data descriptors** implement only `__get__` method (read-only)
- The distinction affects attribute lookup precedence in Python
- Data descriptors have higher precedence than instance `__dict__` entries
- Non-data descriptors have lower precedence than instance `__dict__` entries
- Attribute lookup follows a specific precedence chain

## Defining the Two Types

### Non-data Descriptor
A descriptor that implements **only** the `__get__` method, making it read-only.

### Data Descriptor  
A descriptor that implements **both** `__get__` and `__set__` methods, making it writable.

## Attribute Lookup Transformation

Behind the scenes, `object.__getattribute__` (responsible for all attribute lookup in Python) transforms:

```python
obj.attr
```

into:

```python
type(obj).__dict__['attr'].__get__(obj, type(obj))
```

## Precedence Rules

The precedence chain controls attribute lookup according to these rules:

1. **Data descriptor precedence**: If an instance's `__dict__` has an entry with the same name as a data descriptor, the **data descriptor takes precedence**

2. **Instance dict precedence**: If an instance's `__dict__` has an entry with the same name as a non-data descriptor, the **dictionary entry takes precedence**

### Simplified Precedence Order

Attribute lookup proceeds in this order:
1. **Data descriptors** (like properties defined in the class)
2. **Instance attributes** (in `__dict__`)  
3. **Non-data descriptors** (in the class)

## Demonstration with Examples

Let's define descriptors to demonstrate the precedence rules:

```python
class DataDescriptor:
    def __get__(self, instance, owner):
        print("DataDescriptor.__get__({!r}, {!r}, {!r})"
              .format(self, instance, owner))

    def __set__(self, instance, value):
        print("DataDescriptor.__set__({!r}, {!r}, {!r})"
              .format(self, instance, value))

class NonDataDescriptor:
    def __get__(self, instance, owner):
        print("NonDataDescriptor.__get__({!r}, {!r}, {!r})"
              .format(self, instance, owner))

class Owner:
    a = DataDescriptor()
    b = NonDataDescriptor()
```

## Testing Data Descriptor Precedence

```python
>>> from precedence import *
>>> obj = Owner()
>>> obj.a
DataDescriptor.__get__(<precedence.DataDescriptor object at 0x101a89400>, <precedence.Owner object at 0x101a5cb70>, <class 'precedence.Owner'>)

>>> obj.__dict__['a'] = 196883
>>> obj.a
DataDescriptor.__get__(<precedence.DataDescriptor object at 0x101a89400>, <precedence.Owner object at 0x101a5cb70>, <class 'precedence.Owner'>)
```

Since `a` is a data descriptor, the **data descriptor takes precedence** even after we add an entry with the same name to the instance dictionary.

## Testing Non-data Descriptor Precedence

```python
>>> obj.b
NonDataDescriptor.__get__(<precedence.NonDataDescriptor object at 0x101a89438>, <precedence.Owner object at 0x101a5cb70>, <class 'precedence.Owner'>)

>>> obj.__dict__['b'] = 744
>>> obj.b
744
```

With attribute `b`:
- **First access**: No entry in instance dictionary, so the NonDataDescriptor takes precedence
- **After adding to `__dict__`**: The dictionary entry takes precedence over the NonDataDescriptor

## Key Takeaways

- **Method presence determines type**: `__set__` method presence distinguishes data from non-data descriptors
- **Precedence matters**: Understanding precedence is crucial for attribute resolution behavior
- **Data descriptors win**: They always take precedence over instance `__dict__` entries
- **Non-data descriptors yield**: They give way to instance `__dict__` entries when present
- **Practical implications**: Properties (data descriptors) cannot be overridden by instance attributes
- **Debugging tool**: Understanding precedence helps explain unexpected attribute behavior
